
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Listing
 * 
 */
export type Listing = $Result.DefaultSelection<Prisma.$ListingPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model brands
 * 
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model category_attributes
 * 
 */
export type category_attributes = $Result.DefaultSelection<Prisma.$category_attributesPayload>
/**
 * Model cities
 * 
 */
export type cities = $Result.DefaultSelection<Prisma.$citiesPayload>
/**
 * Model complaints
 * 
 */
export type complaints = $Result.DefaultSelection<Prisma.$complaintsPayload>
/**
 * Model conversations
 * 
 */
export type conversations = $Result.DefaultSelection<Prisma.$conversationsPayload>
/**
 * Model districts
 * 
 */
export type districts = $Result.DefaultSelection<Prisma.$districtsPayload>
/**
 * Model feature_definitions
 * 
 */
export type feature_definitions = $Result.DefaultSelection<Prisma.$feature_definitionsPayload>
/**
 * Model feature_groups
 * 
 */
export type feature_groups = $Result.DefaultSelection<Prisma.$feature_groupsPayload>
/**
 * Model listing_images
 * 
 */
export type listing_images = $Result.DefaultSelection<Prisma.$listing_imagesPayload>
/**
 * Model listing_properties
 * 
 */
export type listing_properties = $Result.DefaultSelection<Prisma.$listing_propertiesPayload>
/**
 * Model models
 * 
 */
export type models = $Result.DefaultSelection<Prisma.$modelsPayload>
/**
 * Model variants
 * 
 */
export type variants = $Result.DefaultSelection<Prisma.$variantsPayload>
/**
 * Model vehicle_types
 * 
 */
export type vehicle_types = $Result.DefaultSelection<Prisma.$vehicle_typesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  CORPORATE: 'CORPORATE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ListingStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED',
  PENDING: 'PENDING'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const NotificationType: {
  LISTING_APPROVED: 'LISTING_APPROVED',
  LISTING_REJECTED: 'LISTING_REJECTED',
  LISTING_EXPIRED: 'LISTING_EXPIRED',
  GENERAL: 'GENERAL',
  COMPLAINT_RESPONSE: 'COMPLAINT_RESPONSE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const PropertyType: {
  STRING: 'STRING',
  NUMBER: 'NUMBER',
  BOOLEAN: 'BOOLEAN',
  SELECT: 'SELECT',
  MULTISELECT: 'MULTISELECT'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const ComplaintTarget: {
  LISTING: 'LISTING',
  USER: 'USER'
};

export type ComplaintTarget = (typeof ComplaintTarget)[keyof typeof ComplaintTarget]


export const ComplaintCategory: {
  MISLEADING_FAKE_AD: 'MISLEADING_FAKE_AD',
  WRONG_CATEGORY: 'WRONG_CATEGORY',
  SPAM_DUPLICATE: 'SPAM_DUPLICATE',
  FRAUD_SUSPICION: 'FRAUD_SUSPICION',
  INAPPROPRIATE_CONTENT: 'INAPPROPRIATE_CONTENT',
  HARASSMENT_ABUSE: 'HARASSMENT_ABUSE',
  PROHIBITED_ITEM: 'PROHIBITED_ITEM',
  OTHER: 'OTHER'
};

export type ComplaintCategory = (typeof ComplaintCategory)[keyof typeof ComplaintCategory]


export const ComplaintStatus: {
  PENDING: 'PENDING',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type ComplaintTarget = $Enums.ComplaintTarget

export const ComplaintTarget: typeof $Enums.ComplaintTarget

export type ComplaintCategory = $Enums.ComplaintCategory

export const ComplaintCategory: typeof $Enums.ComplaintCategory

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listings
    * const listings = await prisma.listing.findMany()
    * ```
    */
  get listing(): Prisma.ListingDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs>;

  /**
   * `prisma.category_attributes`: Exposes CRUD operations for the **category_attributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_attributes
    * const category_attributes = await prisma.category_attributes.findMany()
    * ```
    */
  get category_attributes(): Prisma.category_attributesDelegate<ExtArgs>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.citiesDelegate<ExtArgs>;

  /**
   * `prisma.complaints`: Exposes CRUD operations for the **complaints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaints.findMany()
    * ```
    */
  get complaints(): Prisma.complaintsDelegate<ExtArgs>;

  /**
   * `prisma.conversations`: Exposes CRUD operations for the **conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversations.findMany()
    * ```
    */
  get conversations(): Prisma.conversationsDelegate<ExtArgs>;

  /**
   * `prisma.districts`: Exposes CRUD operations for the **districts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.districts.findMany()
    * ```
    */
  get districts(): Prisma.districtsDelegate<ExtArgs>;

  /**
   * `prisma.feature_definitions`: Exposes CRUD operations for the **feature_definitions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feature_definitions
    * const feature_definitions = await prisma.feature_definitions.findMany()
    * ```
    */
  get feature_definitions(): Prisma.feature_definitionsDelegate<ExtArgs>;

  /**
   * `prisma.feature_groups`: Exposes CRUD operations for the **feature_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feature_groups
    * const feature_groups = await prisma.feature_groups.findMany()
    * ```
    */
  get feature_groups(): Prisma.feature_groupsDelegate<ExtArgs>;

  /**
   * `prisma.listing_images`: Exposes CRUD operations for the **listing_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listing_images
    * const listing_images = await prisma.listing_images.findMany()
    * ```
    */
  get listing_images(): Prisma.listing_imagesDelegate<ExtArgs>;

  /**
   * `prisma.listing_properties`: Exposes CRUD operations for the **listing_properties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listing_properties
    * const listing_properties = await prisma.listing_properties.findMany()
    * ```
    */
  get listing_properties(): Prisma.listing_propertiesDelegate<ExtArgs>;

  /**
   * `prisma.models`: Exposes CRUD operations for the **models** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.models.findMany()
    * ```
    */
  get models(): Prisma.modelsDelegate<ExtArgs>;

  /**
   * `prisma.variants`: Exposes CRUD operations for the **variants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variants.findMany()
    * ```
    */
  get variants(): Prisma.variantsDelegate<ExtArgs>;

  /**
   * `prisma.vehicle_types`: Exposes CRUD operations for the **vehicle_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_types
    * const vehicle_types = await prisma.vehicle_types.findMany()
    * ```
    */
  get vehicle_types(): Prisma.vehicle_typesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    Listing: 'Listing',
    Message: 'Message',
    Favorite: 'Favorite',
    Notification: 'Notification',
    brands: 'brands',
    category_attributes: 'category_attributes',
    cities: 'cities',
    complaints: 'complaints',
    conversations: 'conversations',
    districts: 'districts',
    feature_definitions: 'feature_definitions',
    feature_groups: 'feature_groups',
    listing_images: 'listing_images',
    listing_properties: 'listing_properties',
    models: 'models',
    variants: 'variants',
    vehicle_types: 'vehicle_types'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "category" | "listing" | "message" | "favorite" | "notification" | "brands" | "category_attributes" | "cities" | "complaints" | "conversations" | "districts" | "feature_definitions" | "feature_groups" | "listing_images" | "listing_properties" | "models" | "variants" | "vehicle_types"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Listing: {
        payload: Prisma.$ListingPayload<ExtArgs>
        fields: Prisma.ListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findFirst: {
            args: Prisma.ListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findMany: {
            args: Prisma.ListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          create: {
            args: Prisma.ListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          createMany: {
            args: Prisma.ListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          delete: {
            args: Prisma.ListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          update: {
            args: Prisma.ListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          deleteMany: {
            args: Prisma.ListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          aggregate: {
            args: Prisma.ListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing>
          }
          groupBy: {
            args: Prisma.ListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListingCountArgs<ExtArgs>
            result: $Utils.Optional<ListingCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.brandsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      category_attributes: {
        payload: Prisma.$category_attributesPayload<ExtArgs>
        fields: Prisma.category_attributesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.category_attributesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.category_attributesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          findFirst: {
            args: Prisma.category_attributesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.category_attributesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          findMany: {
            args: Prisma.category_attributesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>[]
          }
          create: {
            args: Prisma.category_attributesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          createMany: {
            args: Prisma.category_attributesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.category_attributesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>[]
          }
          delete: {
            args: Prisma.category_attributesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          update: {
            args: Prisma.category_attributesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          deleteMany: {
            args: Prisma.category_attributesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.category_attributesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.category_attributesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_attributesPayload>
          }
          aggregate: {
            args: Prisma.Category_attributesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory_attributes>
          }
          groupBy: {
            args: Prisma.category_attributesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Category_attributesGroupByOutputType>[]
          }
          count: {
            args: Prisma.category_attributesCountArgs<ExtArgs>
            result: $Utils.Optional<Category_attributesCountAggregateOutputType> | number
          }
        }
      }
      cities: {
        payload: Prisma.$citiesPayload<ExtArgs>
        fields: Prisma.citiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.citiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.citiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findFirst: {
            args: Prisma.citiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.citiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findMany: {
            args: Prisma.citiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          create: {
            args: Prisma.citiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          createMany: {
            args: Prisma.citiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.citiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          delete: {
            args: Prisma.citiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          update: {
            args: Prisma.citiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          deleteMany: {
            args: Prisma.citiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.citiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.citiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          aggregate: {
            args: Prisma.CitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCities>
          }
          groupBy: {
            args: Prisma.citiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.citiesCountArgs<ExtArgs>
            result: $Utils.Optional<CitiesCountAggregateOutputType> | number
          }
        }
      }
      complaints: {
        payload: Prisma.$complaintsPayload<ExtArgs>
        fields: Prisma.complaintsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.complaintsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.complaintsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findFirst: {
            args: Prisma.complaintsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.complaintsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          findMany: {
            args: Prisma.complaintsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          create: {
            args: Prisma.complaintsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          createMany: {
            args: Prisma.complaintsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.complaintsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>[]
          }
          delete: {
            args: Prisma.complaintsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          update: {
            args: Prisma.complaintsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          deleteMany: {
            args: Prisma.complaintsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.complaintsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.complaintsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintsPayload>
          }
          aggregate: {
            args: Prisma.ComplaintsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaints>
          }
          groupBy: {
            args: Prisma.complaintsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsGroupByOutputType>[]
          }
          count: {
            args: Prisma.complaintsCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsCountAggregateOutputType> | number
          }
        }
      }
      conversations: {
        payload: Prisma.$conversationsPayload<ExtArgs>
        fields: Prisma.conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findFirst: {
            args: Prisma.conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findMany: {
            args: Prisma.conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          create: {
            args: Prisma.conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          createMany: {
            args: Prisma.conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          delete: {
            args: Prisma.conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          update: {
            args: Prisma.conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          deleteMany: {
            args: Prisma.conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          aggregate: {
            args: Prisma.ConversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversations>
          }
          groupBy: {
            args: Prisma.conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationsCountAggregateOutputType> | number
          }
        }
      }
      districts: {
        payload: Prisma.$districtsPayload<ExtArgs>
        fields: Prisma.districtsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.districtsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.districtsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findFirst: {
            args: Prisma.districtsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.districtsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findMany: {
            args: Prisma.districtsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          create: {
            args: Prisma.districtsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          createMany: {
            args: Prisma.districtsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.districtsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          delete: {
            args: Prisma.districtsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          update: {
            args: Prisma.districtsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          deleteMany: {
            args: Prisma.districtsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.districtsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.districtsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          aggregate: {
            args: Prisma.DistrictsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistricts>
          }
          groupBy: {
            args: Prisma.districtsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictsGroupByOutputType>[]
          }
          count: {
            args: Prisma.districtsCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictsCountAggregateOutputType> | number
          }
        }
      }
      feature_definitions: {
        payload: Prisma.$feature_definitionsPayload<ExtArgs>
        fields: Prisma.feature_definitionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feature_definitionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feature_definitionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          findFirst: {
            args: Prisma.feature_definitionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feature_definitionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          findMany: {
            args: Prisma.feature_definitionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>[]
          }
          create: {
            args: Prisma.feature_definitionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          createMany: {
            args: Prisma.feature_definitionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feature_definitionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>[]
          }
          delete: {
            args: Prisma.feature_definitionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          update: {
            args: Prisma.feature_definitionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          deleteMany: {
            args: Prisma.feature_definitionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feature_definitionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feature_definitionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_definitionsPayload>
          }
          aggregate: {
            args: Prisma.Feature_definitionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature_definitions>
          }
          groupBy: {
            args: Prisma.feature_definitionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Feature_definitionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.feature_definitionsCountArgs<ExtArgs>
            result: $Utils.Optional<Feature_definitionsCountAggregateOutputType> | number
          }
        }
      }
      feature_groups: {
        payload: Prisma.$feature_groupsPayload<ExtArgs>
        fields: Prisma.feature_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feature_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feature_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          findFirst: {
            args: Prisma.feature_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feature_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          findMany: {
            args: Prisma.feature_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>[]
          }
          create: {
            args: Prisma.feature_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          createMany: {
            args: Prisma.feature_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feature_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>[]
          }
          delete: {
            args: Prisma.feature_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          update: {
            args: Prisma.feature_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          deleteMany: {
            args: Prisma.feature_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feature_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feature_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_groupsPayload>
          }
          aggregate: {
            args: Prisma.Feature_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature_groups>
          }
          groupBy: {
            args: Prisma.feature_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Feature_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.feature_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Feature_groupsCountAggregateOutputType> | number
          }
        }
      }
      listing_images: {
        payload: Prisma.$listing_imagesPayload<ExtArgs>
        fields: Prisma.listing_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.listing_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.listing_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          findFirst: {
            args: Prisma.listing_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.listing_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          findMany: {
            args: Prisma.listing_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>[]
          }
          create: {
            args: Prisma.listing_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          createMany: {
            args: Prisma.listing_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.listing_imagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>[]
          }
          delete: {
            args: Prisma.listing_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          update: {
            args: Prisma.listing_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          deleteMany: {
            args: Prisma.listing_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.listing_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.listing_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_imagesPayload>
          }
          aggregate: {
            args: Prisma.Listing_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing_images>
          }
          groupBy: {
            args: Prisma.listing_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Listing_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.listing_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Listing_imagesCountAggregateOutputType> | number
          }
        }
      }
      listing_properties: {
        payload: Prisma.$listing_propertiesPayload<ExtArgs>
        fields: Prisma.listing_propertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.listing_propertiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.listing_propertiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          findFirst: {
            args: Prisma.listing_propertiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.listing_propertiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          findMany: {
            args: Prisma.listing_propertiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>[]
          }
          create: {
            args: Prisma.listing_propertiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          createMany: {
            args: Prisma.listing_propertiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.listing_propertiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>[]
          }
          delete: {
            args: Prisma.listing_propertiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          update: {
            args: Prisma.listing_propertiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          deleteMany: {
            args: Prisma.listing_propertiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.listing_propertiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.listing_propertiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listing_propertiesPayload>
          }
          aggregate: {
            args: Prisma.Listing_propertiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing_properties>
          }
          groupBy: {
            args: Prisma.listing_propertiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Listing_propertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.listing_propertiesCountArgs<ExtArgs>
            result: $Utils.Optional<Listing_propertiesCountAggregateOutputType> | number
          }
        }
      }
      models: {
        payload: Prisma.$modelsPayload<ExtArgs>
        fields: Prisma.modelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          findFirst: {
            args: Prisma.modelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          findMany: {
            args: Prisma.modelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>[]
          }
          create: {
            args: Prisma.modelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          createMany: {
            args: Prisma.modelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.modelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>[]
          }
          delete: {
            args: Prisma.modelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          update: {
            args: Prisma.modelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          deleteMany: {
            args: Prisma.modelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.modelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          aggregate: {
            args: Prisma.ModelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModels>
          }
          groupBy: {
            args: Prisma.modelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.modelsCountArgs<ExtArgs>
            result: $Utils.Optional<ModelsCountAggregateOutputType> | number
          }
        }
      }
      variants: {
        payload: Prisma.$variantsPayload<ExtArgs>
        fields: Prisma.variantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.variantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.variantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          findFirst: {
            args: Prisma.variantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.variantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          findMany: {
            args: Prisma.variantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>[]
          }
          create: {
            args: Prisma.variantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          createMany: {
            args: Prisma.variantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.variantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>[]
          }
          delete: {
            args: Prisma.variantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          update: {
            args: Prisma.variantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          deleteMany: {
            args: Prisma.variantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.variantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.variantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          aggregate: {
            args: Prisma.VariantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariants>
          }
          groupBy: {
            args: Prisma.variantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.variantsCountArgs<ExtArgs>
            result: $Utils.Optional<VariantsCountAggregateOutputType> | number
          }
        }
      }
      vehicle_types: {
        payload: Prisma.$vehicle_typesPayload<ExtArgs>
        fields: Prisma.vehicle_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          findFirst: {
            args: Prisma.vehicle_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          findMany: {
            args: Prisma.vehicle_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>[]
          }
          create: {
            args: Prisma.vehicle_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          createMany: {
            args: Prisma.vehicle_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehicle_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>[]
          }
          delete: {
            args: Prisma.vehicle_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          update: {
            args: Prisma.vehicle_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typesPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_types>
          }
          groupBy: {
            args: Prisma.vehicle_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehicle_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_typesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    complaints_complaints_target_user_idTousers: number
    complaints_complaints_user_idTousers: number
    conversations_conversations_participant1_idTousers: number
    conversations_conversations_participant2_idTousers: number
    favorites: number
    listings: number
    messages: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints_complaints_target_user_idTousers?: boolean | UserCountOutputTypeCountComplaints_complaints_target_user_idTousersArgs
    complaints_complaints_user_idTousers?: boolean | UserCountOutputTypeCountComplaints_complaints_user_idTousersArgs
    conversations_conversations_participant1_idTousers?: boolean | UserCountOutputTypeCountConversations_conversations_participant1_idTousersArgs
    conversations_conversations_participant2_idTousers?: boolean | UserCountOutputTypeCountConversations_conversations_participant2_idTousersArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    listings?: boolean | UserCountOutputTypeCountListingsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaints_complaints_target_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaints_complaints_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversations_conversations_participant1_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversations_conversations_participant2_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    category_attributes: number
    listings: number
    vehicle_types: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category_attributes?: boolean | CategoryCountOutputTypeCountCategory_attributesArgs
    listings?: boolean | CategoryCountOutputTypeCountListingsArgs
    vehicle_types?: boolean | CategoryCountOutputTypeCountVehicle_typesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCategory_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_attributesWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountVehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_typesWhereInput
  }


  /**
   * Count Type ListingCountOutputType
   */

  export type ListingCountOutputType = {
    complaints: number
    conversations: number
    favorites: number
    listing_images: number
    listing_properties: number
  }

  export type ListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | ListingCountOutputTypeCountComplaintsArgs
    conversations?: boolean | ListingCountOutputTypeCountConversationsArgs
    favorites?: boolean | ListingCountOutputTypeCountFavoritesArgs
    listing_images?: boolean | ListingCountOutputTypeCountListing_imagesArgs
    listing_properties?: boolean | ListingCountOutputTypeCountListing_propertiesArgs
  }

  // Custom InputTypes
  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingCountOutputType
     */
    select?: ListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountListing_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listing_imagesWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountListing_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listing_propertiesWhereInput
  }


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    listings: number
    models: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | BrandsCountOutputTypeCountListingsArgs
    models?: boolean | BrandsCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelsWhereInput
  }


  /**
   * Count Type CitiesCountOutputType
   */

  export type CitiesCountOutputType = {
    districts: number
    listings: number
  }

  export type CitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | CitiesCountOutputTypeCountDistrictsArgs
    listings?: boolean | CitiesCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitiesCountOutputType
     */
    select?: CitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtsWhereInput
  }

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type ConversationsCountOutputType
   */

  export type ConversationsCountOutputType = {
    messages: number
  }

  export type ConversationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationsCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationsCountOutputType without action
   */
  export type ConversationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationsCountOutputType
     */
    select?: ConversationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationsCountOutputType without action
   */
  export type ConversationsCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type DistrictsCountOutputType
   */

  export type DistrictsCountOutputType = {
    listings: number
  }

  export type DistrictsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | DistrictsCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * DistrictsCountOutputType without action
   */
  export type DistrictsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictsCountOutputType
     */
    select?: DistrictsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictsCountOutputType without action
   */
  export type DistrictsCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type Feature_groupsCountOutputType
   */

  export type Feature_groupsCountOutputType = {
    feature_definitions: number
  }

  export type Feature_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature_definitions?: boolean | Feature_groupsCountOutputTypeCountFeature_definitionsArgs
  }

  // Custom InputTypes
  /**
   * Feature_groupsCountOutputType without action
   */
  export type Feature_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature_groupsCountOutputType
     */
    select?: Feature_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Feature_groupsCountOutputType without action
   */
  export type Feature_groupsCountOutputTypeCountFeature_definitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_definitionsWhereInput
  }


  /**
   * Count Type ModelsCountOutputType
   */

  export type ModelsCountOutputType = {
    listings: number
    variants: number
  }

  export type ModelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ModelsCountOutputTypeCountListingsArgs
    variants?: boolean | ModelsCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelsCountOutputType
     */
    select?: ModelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variantsWhereInput
  }


  /**
   * Count Type VariantsCountOutputType
   */

  export type VariantsCountOutputType = {
    listings: number
  }

  export type VariantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | VariantsCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantsCountOutputType
     */
    select?: VariantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type Vehicle_typesCountOutputType
   */

  export type Vehicle_typesCountOutputType = {
    brands: number
    category_attributes: number
    feature_groups: number
    listings: number
  }

  export type Vehicle_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | Vehicle_typesCountOutputTypeCountBrandsArgs
    category_attributes?: boolean | Vehicle_typesCountOutputTypeCountCategory_attributesArgs
    feature_groups?: boolean | Vehicle_typesCountOutputTypeCountFeature_groupsArgs
    listings?: boolean | Vehicle_typesCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_typesCountOutputType
     */
    select?: Vehicle_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeCountBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
  }

  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeCountCategory_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_attributesWhereInput
  }

  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeCountFeature_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_groupsWhereInput
  }

  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    login_attempts: number | null
  }

  export type UserSumAggregateOutputType = {
    login_attempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    username: string | null
    phone: string | null
    city: string | null
    district: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    is_email_verified: boolean | null
    reset_password_token: string | null
    reset_password_expires: Date | null
    last_login: Date | null
    login_attempts: number | null
    lock_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    email_verification_expires: Date | null
    email_verification_token: string | null
    google_id: string | null
    provider: string | null
    refresh_token: string | null
    refresh_token_expires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    username: string | null
    phone: string | null
    city: string | null
    district: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    is_email_verified: boolean | null
    reset_password_token: string | null
    reset_password_expires: Date | null
    last_login: Date | null
    login_attempts: number | null
    lock_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    email_verification_expires: Date | null
    email_verification_token: string | null
    google_id: string | null
    provider: string | null
    refresh_token: string | null
    refresh_token_expires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    first_name: number
    last_name: number
    username: number
    phone: number
    city: number
    district: number
    role: number
    is_active: number
    is_email_verified: number
    reset_password_token: number
    reset_password_expires: number
    last_login: number
    login_attempts: number
    lock_until: number
    created_at: number
    updated_at: number
    email_verification_expires: number
    email_verification_token: number
    google_id: number
    provider: number
    refresh_token: number
    refresh_token_expires: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    login_attempts?: true
  }

  export type UserSumAggregateInputType = {
    login_attempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    username?: true
    phone?: true
    city?: true
    district?: true
    role?: true
    is_active?: true
    is_email_verified?: true
    reset_password_token?: true
    reset_password_expires?: true
    last_login?: true
    login_attempts?: true
    lock_until?: true
    created_at?: true
    updated_at?: true
    email_verification_expires?: true
    email_verification_token?: true
    google_id?: true
    provider?: true
    refresh_token?: true
    refresh_token_expires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    username?: true
    phone?: true
    city?: true
    district?: true
    role?: true
    is_active?: true
    is_email_verified?: true
    reset_password_token?: true
    reset_password_expires?: true
    last_login?: true
    login_attempts?: true
    lock_until?: true
    created_at?: true
    updated_at?: true
    email_verification_expires?: true
    email_verification_token?: true
    google_id?: true
    provider?: true
    refresh_token?: true
    refresh_token_expires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    username?: true
    phone?: true
    city?: true
    district?: true
    role?: true
    is_active?: true
    is_email_verified?: true
    reset_password_token?: true
    reset_password_expires?: true
    last_login?: true
    login_attempts?: true
    lock_until?: true
    created_at?: true
    updated_at?: true
    email_verification_expires?: true
    email_verification_token?: true
    google_id?: true
    provider?: true
    refresh_token?: true
    refresh_token_expires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    first_name: string
    last_name: string
    username: string | null
    phone: string | null
    city: string | null
    district: string | null
    role: $Enums.UserRole
    is_active: boolean
    is_email_verified: boolean
    reset_password_token: string | null
    reset_password_expires: Date | null
    last_login: Date | null
    login_attempts: number
    lock_until: Date | null
    created_at: Date
    updated_at: Date
    email_verification_expires: Date | null
    email_verification_token: string | null
    google_id: string | null
    provider: string | null
    refresh_token: string | null
    refresh_token_expires: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    phone?: boolean
    city?: boolean
    district?: boolean
    role?: boolean
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    last_login?: boolean
    login_attempts?: boolean
    lock_until?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    google_id?: boolean
    provider?: boolean
    refresh_token?: boolean
    refresh_token_expires?: boolean
    complaints_complaints_target_user_idTousers?: boolean | User$complaints_complaints_target_user_idTousersArgs<ExtArgs>
    complaints_complaints_user_idTousers?: boolean | User$complaints_complaints_user_idTousersArgs<ExtArgs>
    conversations_conversations_participant1_idTousers?: boolean | User$conversations_conversations_participant1_idTousersArgs<ExtArgs>
    conversations_conversations_participant2_idTousers?: boolean | User$conversations_conversations_participant2_idTousersArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    phone?: boolean
    city?: boolean
    district?: boolean
    role?: boolean
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    last_login?: boolean
    login_attempts?: boolean
    lock_until?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    google_id?: boolean
    provider?: boolean
    refresh_token?: boolean
    refresh_token_expires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    phone?: boolean
    city?: boolean
    district?: boolean
    role?: boolean
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    last_login?: boolean
    login_attempts?: boolean
    lock_until?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    google_id?: boolean
    provider?: boolean
    refresh_token?: boolean
    refresh_token_expires?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints_complaints_target_user_idTousers?: boolean | User$complaints_complaints_target_user_idTousersArgs<ExtArgs>
    complaints_complaints_user_idTousers?: boolean | User$complaints_complaints_user_idTousersArgs<ExtArgs>
    conversations_conversations_participant1_idTousers?: boolean | User$conversations_conversations_participant1_idTousersArgs<ExtArgs>
    conversations_conversations_participant2_idTousers?: boolean | User$conversations_conversations_participant2_idTousersArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      complaints_complaints_target_user_idTousers: Prisma.$complaintsPayload<ExtArgs>[]
      complaints_complaints_user_idTousers: Prisma.$complaintsPayload<ExtArgs>[]
      conversations_conversations_participant1_idTousers: Prisma.$conversationsPayload<ExtArgs>[]
      conversations_conversations_participant2_idTousers: Prisma.$conversationsPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      first_name: string
      last_name: string
      username: string | null
      phone: string | null
      city: string | null
      district: string | null
      role: $Enums.UserRole
      is_active: boolean
      is_email_verified: boolean
      reset_password_token: string | null
      reset_password_expires: Date | null
      last_login: Date | null
      login_attempts: number
      lock_until: Date | null
      created_at: Date
      updated_at: Date
      email_verification_expires: Date | null
      email_verification_token: string | null
      google_id: string | null
      provider: string | null
      refresh_token: string | null
      refresh_token_expires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints_complaints_target_user_idTousers<T extends User$complaints_complaints_target_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$complaints_complaints_target_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany"> | Null>
    complaints_complaints_user_idTousers<T extends User$complaints_complaints_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$complaints_complaints_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany"> | Null>
    conversations_conversations_participant1_idTousers<T extends User$conversations_conversations_participant1_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$conversations_conversations_participant1_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany"> | Null>
    conversations_conversations_participant2_idTousers<T extends User$conversations_conversations_participant2_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$conversations_conversations_participant2_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany"> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends User$listingsArgs<ExtArgs> = {}>(args?: Subset<T, User$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly district: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly is_email_verified: FieldRef<"User", 'Boolean'>
    readonly reset_password_token: FieldRef<"User", 'String'>
    readonly reset_password_expires: FieldRef<"User", 'DateTime'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly login_attempts: FieldRef<"User", 'Int'>
    readonly lock_until: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly email_verification_expires: FieldRef<"User", 'DateTime'>
    readonly email_verification_token: FieldRef<"User", 'String'>
    readonly google_id: FieldRef<"User", 'String'>
    readonly provider: FieldRef<"User", 'String'>
    readonly refresh_token: FieldRef<"User", 'String'>
    readonly refresh_token_expires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.complaints_complaints_target_user_idTousers
   */
  export type User$complaints_complaints_target_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * User.complaints_complaints_user_idTousers
   */
  export type User$complaints_complaints_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * User.conversations_conversations_participant1_idTousers
   */
  export type User$conversations_conversations_participant1_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    cursor?: conversationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * User.conversations_conversations_participant2_idTousers
   */
  export type User$conversations_conversations_participant2_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    cursor?: conversationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.listings
   */
  export type User$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_attributes?: boolean | Category$category_attributesArgs<ExtArgs>
    listings?: boolean | Category$listingsArgs<ExtArgs>
    vehicle_types?: boolean | Category$vehicle_typesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category_attributes?: boolean | Category$category_attributesArgs<ExtArgs>
    listings?: boolean | Category$listingsArgs<ExtArgs>
    vehicle_types?: boolean | Category$vehicle_typesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      category_attributes: Prisma.$category_attributesPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
      vehicle_types: Prisma.$vehicle_typesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category_attributes<T extends Category$category_attributesArgs<ExtArgs> = {}>(args?: Subset<T, Category$category_attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends Category$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Category$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    vehicle_types<T extends Category$vehicle_typesArgs<ExtArgs> = {}>(args?: Subset<T, Category$vehicle_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly updated_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.category_attributes
   */
  export type Category$category_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    where?: category_attributesWhereInput
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    cursor?: category_attributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Category_attributesScalarFieldEnum | Category_attributesScalarFieldEnum[]
  }

  /**
   * Category.listings
   */
  export type Category$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Category.vehicle_types
   */
  export type Category$vehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    where?: vehicle_typesWhereInput
    orderBy?: vehicle_typesOrderByWithRelationInput | vehicle_typesOrderByWithRelationInput[]
    cursor?: vehicle_typesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_typesScalarFieldEnum | Vehicle_typesScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Listing
   */

  export type AggregateListing = {
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  export type ListingAvgAggregateOutputType = {
    price: Decimal | null
    year: number | null
    view_count: number | null
    km: number | null
  }

  export type ListingSumAggregateOutputType = {
    price: Decimal | null
    year: number | null
    view_count: number | null
    km: number | null
  }

  export type ListingMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    year: number | null
    category_id: string | null
    vehicle_type_id: string | null
    brand_id: string | null
    model_id: string | null
    variant_id: string | null
    status: $Enums.ListingStatus | null
    is_active: boolean | null
    is_approved: boolean | null
    is_pending: boolean | null
    view_count: number | null
    is_promoted: boolean | null
    approved_by: string | null
    approved_at: Date | null
    rejected_at: Date | null
    reject_reason: string | null
    seller_name: string | null
    seller_phone: string | null
    seller_email: string | null
    city_id: string | null
    district_id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    color: string | null
    engine_power: string | null
    engine_volume: string | null
    fuel_type: string | null
    is_exchangeable: boolean | null
    km: number | null
    license_plate: string | null
    neighborhood_id: string | null
    transmission: string | null
    vehicle_condition: string | null
  }

  export type ListingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    year: number | null
    category_id: string | null
    vehicle_type_id: string | null
    brand_id: string | null
    model_id: string | null
    variant_id: string | null
    status: $Enums.ListingStatus | null
    is_active: boolean | null
    is_approved: boolean | null
    is_pending: boolean | null
    view_count: number | null
    is_promoted: boolean | null
    approved_by: string | null
    approved_at: Date | null
    rejected_at: Date | null
    reject_reason: string | null
    seller_name: string | null
    seller_phone: string | null
    seller_email: string | null
    city_id: string | null
    district_id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    color: string | null
    engine_power: string | null
    engine_volume: string | null
    fuel_type: string | null
    is_exchangeable: boolean | null
    km: number | null
    license_plate: string | null
    neighborhood_id: string | null
    transmission: string | null
    vehicle_condition: string | null
  }

  export type ListingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    year: number
    category_id: number
    vehicle_type_id: number
    brand_id: number
    model_id: number
    variant_id: number
    status: number
    is_active: number
    is_approved: number
    is_pending: number
    view_count: number
    is_promoted: number
    approved_by: number
    approved_at: number
    rejected_at: number
    reject_reason: number
    seller_name: number
    seller_phone: number
    seller_email: number
    city_id: number
    district_id: number
    created_at: number
    updated_at: number
    user_id: number
    color: number
    engine_power: number
    engine_volume: number
    fuel_type: number
    is_exchangeable: number
    km: number
    license_plate: number
    neighborhood_id: number
    transmission: number
    vehicle_condition: number
    _all: number
  }


  export type ListingAvgAggregateInputType = {
    price?: true
    year?: true
    view_count?: true
    km?: true
  }

  export type ListingSumAggregateInputType = {
    price?: true
    year?: true
    view_count?: true
    km?: true
  }

  export type ListingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    year?: true
    category_id?: true
    vehicle_type_id?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    status?: true
    is_active?: true
    is_approved?: true
    is_pending?: true
    view_count?: true
    is_promoted?: true
    approved_by?: true
    approved_at?: true
    rejected_at?: true
    reject_reason?: true
    seller_name?: true
    seller_phone?: true
    seller_email?: true
    city_id?: true
    district_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    color?: true
    engine_power?: true
    engine_volume?: true
    fuel_type?: true
    is_exchangeable?: true
    km?: true
    license_plate?: true
    neighborhood_id?: true
    transmission?: true
    vehicle_condition?: true
  }

  export type ListingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    year?: true
    category_id?: true
    vehicle_type_id?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    status?: true
    is_active?: true
    is_approved?: true
    is_pending?: true
    view_count?: true
    is_promoted?: true
    approved_by?: true
    approved_at?: true
    rejected_at?: true
    reject_reason?: true
    seller_name?: true
    seller_phone?: true
    seller_email?: true
    city_id?: true
    district_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    color?: true
    engine_power?: true
    engine_volume?: true
    fuel_type?: true
    is_exchangeable?: true
    km?: true
    license_plate?: true
    neighborhood_id?: true
    transmission?: true
    vehicle_condition?: true
  }

  export type ListingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    year?: true
    category_id?: true
    vehicle_type_id?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    status?: true
    is_active?: true
    is_approved?: true
    is_pending?: true
    view_count?: true
    is_promoted?: true
    approved_by?: true
    approved_at?: true
    rejected_at?: true
    reject_reason?: true
    seller_name?: true
    seller_phone?: true
    seller_email?: true
    city_id?: true
    district_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    color?: true
    engine_power?: true
    engine_volume?: true
    fuel_type?: true
    is_exchangeable?: true
    km?: true
    license_plate?: true
    neighborhood_id?: true
    transmission?: true
    vehicle_condition?: true
    _all?: true
  }

  export type ListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listing to aggregate.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Listings
    **/
    _count?: true | ListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingMaxAggregateInputType
  }

  export type GetListingAggregateType<T extends ListingAggregateArgs> = {
        [P in keyof T & keyof AggregateListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing[P]>
      : GetScalarType<T[P], AggregateListing[P]>
  }




  export type ListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithAggregationInput | ListingOrderByWithAggregationInput[]
    by: ListingScalarFieldEnum[] | ListingScalarFieldEnum
    having?: ListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingCountAggregateInputType | true
    _avg?: ListingAvgAggregateInputType
    _sum?: ListingSumAggregateInputType
    _min?: ListingMinAggregateInputType
    _max?: ListingMaxAggregateInputType
  }

  export type ListingGroupByOutputType = {
    id: string
    title: string
    description: string | null
    price: Decimal
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id: string | null
    model_id: string | null
    variant_id: string | null
    status: $Enums.ListingStatus
    is_active: boolean
    is_approved: boolean
    is_pending: boolean
    view_count: number
    is_promoted: boolean
    approved_by: string | null
    approved_at: Date | null
    rejected_at: Date | null
    reject_reason: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id: string | null
    district_id: string | null
    created_at: Date
    updated_at: Date
    user_id: string
    color: string | null
    engine_power: string | null
    engine_volume: string | null
    fuel_type: string | null
    is_exchangeable: boolean
    km: number | null
    license_plate: string | null
    neighborhood_id: string | null
    transmission: string | null
    vehicle_condition: string | null
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  type GetListingGroupByPayload<T extends ListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingGroupByOutputType[P]>
            : GetScalarType<T[P], ListingGroupByOutputType[P]>
        }
      >
    >


  export type ListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    year?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    brand_id?: boolean
    model_id?: boolean
    variant_id?: boolean
    status?: boolean
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: boolean
    is_promoted?: boolean
    approved_by?: boolean
    approved_at?: boolean
    rejected_at?: boolean
    reject_reason?: boolean
    seller_name?: boolean
    seller_phone?: boolean
    seller_email?: boolean
    city_id?: boolean
    district_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    color?: boolean
    engine_power?: boolean
    engine_volume?: boolean
    fuel_type?: boolean
    is_exchangeable?: boolean
    km?: boolean
    license_plate?: boolean
    neighborhood_id?: boolean
    transmission?: boolean
    vehicle_condition?: boolean
    complaints?: boolean | Listing$complaintsArgs<ExtArgs>
    conversations?: boolean | Listing$conversationsArgs<ExtArgs>
    favorites?: boolean | Listing$favoritesArgs<ExtArgs>
    listing_images?: boolean | Listing$listing_imagesArgs<ExtArgs>
    listing_properties?: boolean | Listing$listing_propertiesArgs<ExtArgs>
    brands?: boolean | Listing$brandsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    cities?: boolean | Listing$citiesArgs<ExtArgs>
    districts?: boolean | Listing$districtsArgs<ExtArgs>
    models?: boolean | Listing$modelsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    variants?: boolean | Listing$variantsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    year?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    brand_id?: boolean
    model_id?: boolean
    variant_id?: boolean
    status?: boolean
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: boolean
    is_promoted?: boolean
    approved_by?: boolean
    approved_at?: boolean
    rejected_at?: boolean
    reject_reason?: boolean
    seller_name?: boolean
    seller_phone?: boolean
    seller_email?: boolean
    city_id?: boolean
    district_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    color?: boolean
    engine_power?: boolean
    engine_volume?: boolean
    fuel_type?: boolean
    is_exchangeable?: boolean
    km?: boolean
    license_plate?: boolean
    neighborhood_id?: boolean
    transmission?: boolean
    vehicle_condition?: boolean
    brands?: boolean | Listing$brandsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    cities?: boolean | Listing$citiesArgs<ExtArgs>
    districts?: boolean | Listing$districtsArgs<ExtArgs>
    models?: boolean | Listing$modelsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    variants?: boolean | Listing$variantsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    year?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    brand_id?: boolean
    model_id?: boolean
    variant_id?: boolean
    status?: boolean
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: boolean
    is_promoted?: boolean
    approved_by?: boolean
    approved_at?: boolean
    rejected_at?: boolean
    reject_reason?: boolean
    seller_name?: boolean
    seller_phone?: boolean
    seller_email?: boolean
    city_id?: boolean
    district_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    color?: boolean
    engine_power?: boolean
    engine_volume?: boolean
    fuel_type?: boolean
    is_exchangeable?: boolean
    km?: boolean
    license_plate?: boolean
    neighborhood_id?: boolean
    transmission?: boolean
    vehicle_condition?: boolean
  }

  export type ListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    complaints?: boolean | Listing$complaintsArgs<ExtArgs>
    conversations?: boolean | Listing$conversationsArgs<ExtArgs>
    favorites?: boolean | Listing$favoritesArgs<ExtArgs>
    listing_images?: boolean | Listing$listing_imagesArgs<ExtArgs>
    listing_properties?: boolean | Listing$listing_propertiesArgs<ExtArgs>
    brands?: boolean | Listing$brandsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    cities?: boolean | Listing$citiesArgs<ExtArgs>
    districts?: boolean | Listing$districtsArgs<ExtArgs>
    models?: boolean | Listing$modelsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    variants?: boolean | Listing$variantsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | Listing$brandsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    cities?: boolean | Listing$citiesArgs<ExtArgs>
    districts?: boolean | Listing$districtsArgs<ExtArgs>
    models?: boolean | Listing$modelsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    variants?: boolean | Listing$variantsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }

  export type $ListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Listing"
    objects: {
      complaints: Prisma.$complaintsPayload<ExtArgs>[]
      conversations: Prisma.$conversationsPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      listing_images: Prisma.$listing_imagesPayload<ExtArgs>[]
      listing_properties: Prisma.$listing_propertiesPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs> | null
      categories: Prisma.$CategoryPayload<ExtArgs>
      cities: Prisma.$citiesPayload<ExtArgs> | null
      districts: Prisma.$districtsPayload<ExtArgs> | null
      models: Prisma.$modelsPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>
      variants: Prisma.$variantsPayload<ExtArgs> | null
      vehicle_types: Prisma.$vehicle_typesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      price: Prisma.Decimal
      year: number
      category_id: string
      vehicle_type_id: string
      brand_id: string | null
      model_id: string | null
      variant_id: string | null
      status: $Enums.ListingStatus
      is_active: boolean
      is_approved: boolean
      is_pending: boolean
      view_count: number
      is_promoted: boolean
      approved_by: string | null
      approved_at: Date | null
      rejected_at: Date | null
      reject_reason: string | null
      seller_name: string
      seller_phone: string
      seller_email: string
      city_id: string | null
      district_id: string | null
      created_at: Date
      updated_at: Date
      user_id: string
      color: string | null
      engine_power: string | null
      engine_volume: string | null
      fuel_type: string | null
      is_exchangeable: boolean
      km: number | null
      license_plate: string | null
      neighborhood_id: string | null
      transmission: string | null
      vehicle_condition: string | null
    }, ExtArgs["result"]["listing"]>
    composites: {}
  }

  type ListingGetPayload<S extends boolean | null | undefined | ListingDefaultArgs> = $Result.GetResult<Prisma.$ListingPayload, S>

  type ListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ListingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListingCountAggregateInputType | true
    }

  export interface ListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Listing'], meta: { name: 'Listing' } }
    /**
     * Find zero or one Listing that matches the filter.
     * @param {ListingFindUniqueArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListingFindUniqueArgs>(args: SelectSubset<T, ListingFindUniqueArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Listing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ListingFindUniqueOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Listing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListingFindFirstArgs>(args?: SelectSubset<T, ListingFindFirstArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Listing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Listings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listings
     * const listings = await prisma.listing.findMany()
     * 
     * // Get first 10 Listings
     * const listings = await prisma.listing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingWithIdOnly = await prisma.listing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListingFindManyArgs>(args?: SelectSubset<T, ListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Listing.
     * @param {ListingCreateArgs} args - Arguments to create a Listing.
     * @example
     * // Create one Listing
     * const Listing = await prisma.listing.create({
     *   data: {
     *     // ... data to create a Listing
     *   }
     * })
     * 
     */
    create<T extends ListingCreateArgs>(args: SelectSubset<T, ListingCreateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Listings.
     * @param {ListingCreateManyArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListingCreateManyArgs>(args?: SelectSubset<T, ListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listings and returns the data saved in the database.
     * @param {ListingCreateManyAndReturnArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Listing.
     * @param {ListingDeleteArgs} args - Arguments to delete one Listing.
     * @example
     * // Delete one Listing
     * const Listing = await prisma.listing.delete({
     *   where: {
     *     // ... filter to delete one Listing
     *   }
     * })
     * 
     */
    delete<T extends ListingDeleteArgs>(args: SelectSubset<T, ListingDeleteArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Listing.
     * @param {ListingUpdateArgs} args - Arguments to update one Listing.
     * @example
     * // Update one Listing
     * const listing = await prisma.listing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListingUpdateArgs>(args: SelectSubset<T, ListingUpdateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Listings.
     * @param {ListingDeleteManyArgs} args - Arguments to filter Listings to delete.
     * @example
     * // Delete a few Listings
     * const { count } = await prisma.listing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListingDeleteManyArgs>(args?: SelectSubset<T, ListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListingUpdateManyArgs>(args: SelectSubset<T, ListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listing.
     * @param {ListingUpsertArgs} args - Arguments to update or create a Listing.
     * @example
     * // Update or create a Listing
     * const listing = await prisma.listing.upsert({
     *   create: {
     *     // ... data to create a Listing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing we want to update
     *   }
     * })
     */
    upsert<T extends ListingUpsertArgs>(args: SelectSubset<T, ListingUpsertArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingCountArgs} args - Arguments to filter Listings to count.
     * @example
     * // Count the number of Listings
     * const count = await prisma.listing.count({
     *   where: {
     *     // ... the filter for the Listings we want to count
     *   }
     * })
    **/
    count<T extends ListingCountArgs>(
      args?: Subset<T, ListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingAggregateArgs>(args: Subset<T, ListingAggregateArgs>): Prisma.PrismaPromise<GetListingAggregateType<T>>

    /**
     * Group by Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingGroupByArgs['orderBy'] }
        : { orderBy?: ListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Listing model
   */
  readonly fields: ListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Listing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    complaints<T extends Listing$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany"> | Null>
    conversations<T extends Listing$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany"> | Null>
    favorites<T extends Listing$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany"> | Null>
    listing_images<T extends Listing$listing_imagesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$listing_imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findMany"> | Null>
    listing_properties<T extends Listing$listing_propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$listing_propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findMany"> | Null>
    brands<T extends Listing$brandsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$brandsArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    categories<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cities<T extends Listing$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$citiesArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    districts<T extends Listing$districtsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$districtsArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    models<T extends Listing$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$modelsArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variants<T extends Listing$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$variantsArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vehicle_types<T extends vehicle_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_typesDefaultArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Listing model
   */ 
  interface ListingFieldRefs {
    readonly id: FieldRef<"Listing", 'String'>
    readonly title: FieldRef<"Listing", 'String'>
    readonly description: FieldRef<"Listing", 'String'>
    readonly price: FieldRef<"Listing", 'Decimal'>
    readonly year: FieldRef<"Listing", 'Int'>
    readonly category_id: FieldRef<"Listing", 'String'>
    readonly vehicle_type_id: FieldRef<"Listing", 'String'>
    readonly brand_id: FieldRef<"Listing", 'String'>
    readonly model_id: FieldRef<"Listing", 'String'>
    readonly variant_id: FieldRef<"Listing", 'String'>
    readonly status: FieldRef<"Listing", 'ListingStatus'>
    readonly is_active: FieldRef<"Listing", 'Boolean'>
    readonly is_approved: FieldRef<"Listing", 'Boolean'>
    readonly is_pending: FieldRef<"Listing", 'Boolean'>
    readonly view_count: FieldRef<"Listing", 'Int'>
    readonly is_promoted: FieldRef<"Listing", 'Boolean'>
    readonly approved_by: FieldRef<"Listing", 'String'>
    readonly approved_at: FieldRef<"Listing", 'DateTime'>
    readonly rejected_at: FieldRef<"Listing", 'DateTime'>
    readonly reject_reason: FieldRef<"Listing", 'String'>
    readonly seller_name: FieldRef<"Listing", 'String'>
    readonly seller_phone: FieldRef<"Listing", 'String'>
    readonly seller_email: FieldRef<"Listing", 'String'>
    readonly city_id: FieldRef<"Listing", 'String'>
    readonly district_id: FieldRef<"Listing", 'String'>
    readonly created_at: FieldRef<"Listing", 'DateTime'>
    readonly updated_at: FieldRef<"Listing", 'DateTime'>
    readonly user_id: FieldRef<"Listing", 'String'>
    readonly color: FieldRef<"Listing", 'String'>
    readonly engine_power: FieldRef<"Listing", 'String'>
    readonly engine_volume: FieldRef<"Listing", 'String'>
    readonly fuel_type: FieldRef<"Listing", 'String'>
    readonly is_exchangeable: FieldRef<"Listing", 'Boolean'>
    readonly km: FieldRef<"Listing", 'Int'>
    readonly license_plate: FieldRef<"Listing", 'String'>
    readonly neighborhood_id: FieldRef<"Listing", 'String'>
    readonly transmission: FieldRef<"Listing", 'String'>
    readonly vehicle_condition: FieldRef<"Listing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Listing findUnique
   */
  export type ListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findUniqueOrThrow
   */
  export type ListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findFirst
   */
  export type ListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findFirstOrThrow
   */
  export type ListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findMany
   */
  export type ListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listings to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing create
   */
  export type ListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to create a Listing.
     */
    data: XOR<ListingCreateInput, ListingUncheckedCreateInput>
  }

  /**
   * Listing createMany
   */
  export type ListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Listing createManyAndReturn
   */
  export type ListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing update
   */
  export type ListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to update a Listing.
     */
    data: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
    /**
     * Choose, which Listing to update.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing updateMany
   */
  export type ListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
  }

  /**
   * Listing upsert
   */
  export type ListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The filter to search for the Listing to update in case it exists.
     */
    where: ListingWhereUniqueInput
    /**
     * In case the Listing found by the `where` argument doesn't exist, create a new Listing with this data.
     */
    create: XOR<ListingCreateInput, ListingUncheckedCreateInput>
    /**
     * In case the Listing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
  }

  /**
   * Listing delete
   */
  export type ListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter which Listing to delete.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing deleteMany
   */
  export type ListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listings to delete
     */
    where?: ListingWhereInput
  }

  /**
   * Listing.complaints
   */
  export type Listing$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    cursor?: complaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Listing.conversations
   */
  export type Listing$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    cursor?: conversationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * Listing.favorites
   */
  export type Listing$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Listing.listing_images
   */
  export type Listing$listing_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    where?: listing_imagesWhereInput
    orderBy?: listing_imagesOrderByWithRelationInput | listing_imagesOrderByWithRelationInput[]
    cursor?: listing_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Listing_imagesScalarFieldEnum | Listing_imagesScalarFieldEnum[]
  }

  /**
   * Listing.listing_properties
   */
  export type Listing$listing_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    where?: listing_propertiesWhereInput
    orderBy?: listing_propertiesOrderByWithRelationInput | listing_propertiesOrderByWithRelationInput[]
    cursor?: listing_propertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Listing_propertiesScalarFieldEnum | Listing_propertiesScalarFieldEnum[]
  }

  /**
   * Listing.brands
   */
  export type Listing$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * Listing.cities
   */
  export type Listing$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    where?: citiesWhereInput
  }

  /**
   * Listing.districts
   */
  export type Listing$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    where?: districtsWhereInput
  }

  /**
   * Listing.models
   */
  export type Listing$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    where?: modelsWhereInput
  }

  /**
   * Listing.variants
   */
  export type Listing$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    where?: variantsWhereInput
  }

  /**
   * Listing without action
   */
  export type ListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversation_id: string | null
    sender_id: string | null
    content: string | null
    is_read: boolean | null
    is_edited: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversation_id: string | null
    sender_id: string | null
    content: string | null
    is_read: boolean | null
    is_edited: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversation_id: number
    sender_id: number
    content: number
    is_read: number
    is_edited: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    content?: true
    is_read?: true
    is_edited?: true
    created_at?: true
    updated_at?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    content?: true
    is_read?: true
    is_edited?: true
    created_at?: true
    updated_at?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    content?: true
    is_read?: true
    is_edited?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversation_id: string
    sender_id: string
    content: string
    is_read: boolean
    is_edited: boolean
    created_at: Date
    updated_at: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    content?: boolean
    is_read?: boolean
    is_edited?: boolean
    created_at?: boolean
    updated_at?: boolean
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    content?: boolean
    is_read?: boolean
    is_edited?: boolean
    created_at?: boolean
    updated_at?: boolean
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    content?: boolean
    is_read?: boolean
    is_edited?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversations: Prisma.$conversationsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversation_id: string
      sender_id: string
      content: string
      is_read: boolean
      is_edited: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends conversationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conversationsDefaultArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversation_id: FieldRef<"Message", 'String'>
    readonly sender_id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly is_read: FieldRef<"Message", 'Boolean'>
    readonly is_edited: FieldRef<"Message", 'Boolean'>
    readonly created_at: FieldRef<"Message", 'DateTime'>
    readonly updated_at: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    listing_id: string | null
    created_at: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    listing_id: string | null
    created_at: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    user_id: number
    listing_id: number
    created_at: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    user_id?: true
    listing_id?: true
    created_at?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    user_id?: true
    listing_id?: true
    created_at?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    user_id?: true
    listing_id?: true
    created_at?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    user_id: string
    listing_id: string
    created_at: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    listing_id?: boolean
    created_at?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    listing_id?: boolean
    created_at?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    user_id?: boolean
    listing_id?: boolean
    created_at?: boolean
  }

  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      listing_id: string
      created_at: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */ 
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly user_id: FieldRef<"Favorite", 'String'>
    readonly listing_id: FieldRef<"Favorite", 'String'>
    readonly created_at: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    title: number
    message: number
    data: number
    is_read: number
    created_at: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    title?: true
    message?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    title?: true
    message?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    title?: true
    message?: true
    data?: true
    is_read?: true
    created_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    user_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    data: JsonValue | null
    is_read: boolean
    created_at: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    is_read?: boolean
    created_at?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    is_read?: boolean
    created_at?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    is_read?: boolean
    created_at?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: $Enums.NotificationType
      title: string
      message: string
      data: Prisma.JsonValue | null
      is_read: boolean
      created_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly user_id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsMinAggregateOutputType = {
    id: string | null
    name: string | null
    vehicle_type_id: string | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vehicle_type_id: string | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    name: number
    vehicle_type_id: number
    created_at: number
    updated_at: number
    image_url: number
    _all: number
  }


  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    vehicle_type_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    vehicle_type_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    name?: true
    vehicle_type_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: string
    name: string
    vehicle_type_id: string
    created_at: Date
    updated_at: Date
    image_url: string | null
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vehicle_type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    listings?: boolean | brands$listingsArgs<ExtArgs>
    models?: boolean | brands$modelsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>

  export type brandsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vehicle_type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>

  export type brandsSelectScalar = {
    id?: boolean
    name?: boolean
    vehicle_type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
  }

  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    listings?: boolean | brands$listingsArgs<ExtArgs>
    models?: boolean | brands$modelsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type brandsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      vehicle_types: Prisma.$vehicle_typesPayload<ExtArgs>
      listings: Prisma.$ListingPayload<ExtArgs>[]
      models: Prisma.$modelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vehicle_type_id: string
      created_at: Date
      updated_at: Date
      image_url: string | null
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandsFindUniqueArgs>(args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandsFindFirstArgs>(args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandsFindManyArgs>(args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends brandsCreateArgs>(args: SelectSubset<T, brandsCreateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandsCreateManyArgs>(args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {brandsCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandsWithIdOnly = await prisma.brands.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends brandsCreateManyAndReturnArgs>(args?: SelectSubset<T, brandsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends brandsDeleteArgs>(args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandsUpdateArgs>(args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandsDeleteManyArgs>(args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandsUpdateManyArgs>(args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends brandsUpsertArgs>(args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle_types<T extends vehicle_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_typesDefaultArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    listings<T extends brands$listingsArgs<ExtArgs> = {}>(args?: Subset<T, brands$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    models<T extends brands$modelsArgs<ExtArgs> = {}>(args?: Subset<T, brands$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brands model
   */ 
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'String'>
    readonly name: FieldRef<"brands", 'String'>
    readonly vehicle_type_id: FieldRef<"brands", 'String'>
    readonly created_at: FieldRef<"brands", 'DateTime'>
    readonly updated_at: FieldRef<"brands", 'DateTime'>
    readonly image_url: FieldRef<"brands", 'String'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brands createManyAndReturn
   */
  export type brandsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
  }

  /**
   * brands.listings
   */
  export type brands$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * brands.models
   */
  export type brands$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    where?: modelsWhereInput
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    cursor?: modelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model category_attributes
   */

  export type AggregateCategory_attributes = {
    _count: Category_attributesCountAggregateOutputType | null
    _avg: Category_attributesAvgAggregateOutputType | null
    _sum: Category_attributesSumAggregateOutputType | null
    _min: Category_attributesMinAggregateOutputType | null
    _max: Category_attributesMaxAggregateOutputType | null
  }

  export type Category_attributesAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type Category_attributesSumAggregateOutputType = {
    sort_order: number | null
  }

  export type Category_attributesMinAggregateOutputType = {
    id: string | null
    category_id: string | null
    vehicle_type_id: string | null
    key: string | null
    label: string | null
    type: $Enums.PropertyType | null
    is_required: boolean | null
    is_filterable: boolean | null
    sort_order: number | null
  }

  export type Category_attributesMaxAggregateOutputType = {
    id: string | null
    category_id: string | null
    vehicle_type_id: string | null
    key: string | null
    label: string | null
    type: $Enums.PropertyType | null
    is_required: boolean | null
    is_filterable: boolean | null
    sort_order: number | null
  }

  export type Category_attributesCountAggregateOutputType = {
    id: number
    category_id: number
    vehicle_type_id: number
    key: number
    label: number
    type: number
    is_required: number
    is_filterable: number
    sort_order: number
    options: number
    _all: number
  }


  export type Category_attributesAvgAggregateInputType = {
    sort_order?: true
  }

  export type Category_attributesSumAggregateInputType = {
    sort_order?: true
  }

  export type Category_attributesMinAggregateInputType = {
    id?: true
    category_id?: true
    vehicle_type_id?: true
    key?: true
    label?: true
    type?: true
    is_required?: true
    is_filterable?: true
    sort_order?: true
  }

  export type Category_attributesMaxAggregateInputType = {
    id?: true
    category_id?: true
    vehicle_type_id?: true
    key?: true
    label?: true
    type?: true
    is_required?: true
    is_filterable?: true
    sort_order?: true
  }

  export type Category_attributesCountAggregateInputType = {
    id?: true
    category_id?: true
    vehicle_type_id?: true
    key?: true
    label?: true
    type?: true
    is_required?: true
    is_filterable?: true
    sort_order?: true
    options?: true
    _all?: true
  }

  export type Category_attributesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_attributes to aggregate.
     */
    where?: category_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_attributes to fetch.
     */
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_attributes
    **/
    _count?: true | Category_attributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Category_attributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Category_attributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_attributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_attributesMaxAggregateInputType
  }

  export type GetCategory_attributesAggregateType<T extends Category_attributesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_attributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_attributes[P]>
      : GetScalarType<T[P], AggregateCategory_attributes[P]>
  }




  export type category_attributesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_attributesWhereInput
    orderBy?: category_attributesOrderByWithAggregationInput | category_attributesOrderByWithAggregationInput[]
    by: Category_attributesScalarFieldEnum[] | Category_attributesScalarFieldEnum
    having?: category_attributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_attributesCountAggregateInputType | true
    _avg?: Category_attributesAvgAggregateInputType
    _sum?: Category_attributesSumAggregateInputType
    _min?: Category_attributesMinAggregateInputType
    _max?: Category_attributesMaxAggregateInputType
  }

  export type Category_attributesGroupByOutputType = {
    id: string
    category_id: string
    vehicle_type_id: string | null
    key: string
    label: string
    type: $Enums.PropertyType
    is_required: boolean
    is_filterable: boolean
    sort_order: number
    options: JsonValue | null
    _count: Category_attributesCountAggregateOutputType | null
    _avg: Category_attributesAvgAggregateOutputType | null
    _sum: Category_attributesSumAggregateOutputType | null
    _min: Category_attributesMinAggregateOutputType | null
    _max: Category_attributesMaxAggregateOutputType | null
  }

  type GetCategory_attributesGroupByPayload<T extends category_attributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Category_attributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_attributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_attributesGroupByOutputType[P]>
            : GetScalarType<T[P], Category_attributesGroupByOutputType[P]>
        }
      >
    >


  export type category_attributesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: boolean
    options?: boolean
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    vehicle_types?: boolean | category_attributes$vehicle_typesArgs<ExtArgs>
  }, ExtArgs["result"]["category_attributes"]>

  export type category_attributesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: boolean
    options?: boolean
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    vehicle_types?: boolean | category_attributes$vehicle_typesArgs<ExtArgs>
  }, ExtArgs["result"]["category_attributes"]>

  export type category_attributesSelectScalar = {
    id?: boolean
    category_id?: boolean
    vehicle_type_id?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: boolean
    options?: boolean
  }

  export type category_attributesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    vehicle_types?: boolean | category_attributes$vehicle_typesArgs<ExtArgs>
  }
  export type category_attributesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    vehicle_types?: boolean | category_attributes$vehicle_typesArgs<ExtArgs>
  }

  export type $category_attributesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category_attributes"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>
      vehicle_types: Prisma.$vehicle_typesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category_id: string
      vehicle_type_id: string | null
      key: string
      label: string
      type: $Enums.PropertyType
      is_required: boolean
      is_filterable: boolean
      sort_order: number
      options: Prisma.JsonValue | null
    }, ExtArgs["result"]["category_attributes"]>
    composites: {}
  }

  type category_attributesGetPayload<S extends boolean | null | undefined | category_attributesDefaultArgs> = $Result.GetResult<Prisma.$category_attributesPayload, S>

  type category_attributesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<category_attributesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Category_attributesCountAggregateInputType | true
    }

  export interface category_attributesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category_attributes'], meta: { name: 'category_attributes' } }
    /**
     * Find zero or one Category_attributes that matches the filter.
     * @param {category_attributesFindUniqueArgs} args - Arguments to find a Category_attributes
     * @example
     * // Get one Category_attributes
     * const category_attributes = await prisma.category_attributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends category_attributesFindUniqueArgs>(args: SelectSubset<T, category_attributesFindUniqueArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category_attributes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {category_attributesFindUniqueOrThrowArgs} args - Arguments to find a Category_attributes
     * @example
     * // Get one Category_attributes
     * const category_attributes = await prisma.category_attributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends category_attributesFindUniqueOrThrowArgs>(args: SelectSubset<T, category_attributesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category_attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesFindFirstArgs} args - Arguments to find a Category_attributes
     * @example
     * // Get one Category_attributes
     * const category_attributes = await prisma.category_attributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends category_attributesFindFirstArgs>(args?: SelectSubset<T, category_attributesFindFirstArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category_attributes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesFindFirstOrThrowArgs} args - Arguments to find a Category_attributes
     * @example
     * // Get one Category_attributes
     * const category_attributes = await prisma.category_attributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends category_attributesFindFirstOrThrowArgs>(args?: SelectSubset<T, category_attributesFindFirstOrThrowArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Category_attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_attributes
     * const category_attributes = await prisma.category_attributes.findMany()
     * 
     * // Get first 10 Category_attributes
     * const category_attributes = await prisma.category_attributes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_attributesWithIdOnly = await prisma.category_attributes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends category_attributesFindManyArgs>(args?: SelectSubset<T, category_attributesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category_attributes.
     * @param {category_attributesCreateArgs} args - Arguments to create a Category_attributes.
     * @example
     * // Create one Category_attributes
     * const Category_attributes = await prisma.category_attributes.create({
     *   data: {
     *     // ... data to create a Category_attributes
     *   }
     * })
     * 
     */
    create<T extends category_attributesCreateArgs>(args: SelectSubset<T, category_attributesCreateArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Category_attributes.
     * @param {category_attributesCreateManyArgs} args - Arguments to create many Category_attributes.
     * @example
     * // Create many Category_attributes
     * const category_attributes = await prisma.category_attributes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends category_attributesCreateManyArgs>(args?: SelectSubset<T, category_attributesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Category_attributes and returns the data saved in the database.
     * @param {category_attributesCreateManyAndReturnArgs} args - Arguments to create many Category_attributes.
     * @example
     * // Create many Category_attributes
     * const category_attributes = await prisma.category_attributes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Category_attributes and only return the `id`
     * const category_attributesWithIdOnly = await prisma.category_attributes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends category_attributesCreateManyAndReturnArgs>(args?: SelectSubset<T, category_attributesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category_attributes.
     * @param {category_attributesDeleteArgs} args - Arguments to delete one Category_attributes.
     * @example
     * // Delete one Category_attributes
     * const Category_attributes = await prisma.category_attributes.delete({
     *   where: {
     *     // ... filter to delete one Category_attributes
     *   }
     * })
     * 
     */
    delete<T extends category_attributesDeleteArgs>(args: SelectSubset<T, category_attributesDeleteArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category_attributes.
     * @param {category_attributesUpdateArgs} args - Arguments to update one Category_attributes.
     * @example
     * // Update one Category_attributes
     * const category_attributes = await prisma.category_attributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends category_attributesUpdateArgs>(args: SelectSubset<T, category_attributesUpdateArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Category_attributes.
     * @param {category_attributesDeleteManyArgs} args - Arguments to filter Category_attributes to delete.
     * @example
     * // Delete a few Category_attributes
     * const { count } = await prisma.category_attributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends category_attributesDeleteManyArgs>(args?: SelectSubset<T, category_attributesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_attributes
     * const category_attributes = await prisma.category_attributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends category_attributesUpdateManyArgs>(args: SelectSubset<T, category_attributesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category_attributes.
     * @param {category_attributesUpsertArgs} args - Arguments to update or create a Category_attributes.
     * @example
     * // Update or create a Category_attributes
     * const category_attributes = await prisma.category_attributes.upsert({
     *   create: {
     *     // ... data to create a Category_attributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_attributes we want to update
     *   }
     * })
     */
    upsert<T extends category_attributesUpsertArgs>(args: SelectSubset<T, category_attributesUpsertArgs<ExtArgs>>): Prisma__category_attributesClient<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Category_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesCountArgs} args - Arguments to filter Category_attributes to count.
     * @example
     * // Count the number of Category_attributes
     * const count = await prisma.category_attributes.count({
     *   where: {
     *     // ... the filter for the Category_attributes we want to count
     *   }
     * })
    **/
    count<T extends category_attributesCountArgs>(
      args?: Subset<T, category_attributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_attributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_attributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_attributesAggregateArgs>(args: Subset<T, Category_attributesAggregateArgs>): Prisma.PrismaPromise<GetCategory_attributesAggregateType<T>>

    /**
     * Group by Category_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_attributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends category_attributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: category_attributesGroupByArgs['orderBy'] }
        : { orderBy?: category_attributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, category_attributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_attributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category_attributes model
   */
  readonly fields: category_attributesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category_attributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__category_attributesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle_types<T extends category_attributes$vehicle_typesArgs<ExtArgs> = {}>(args?: Subset<T, category_attributes$vehicle_typesArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category_attributes model
   */ 
  interface category_attributesFieldRefs {
    readonly id: FieldRef<"category_attributes", 'String'>
    readonly category_id: FieldRef<"category_attributes", 'String'>
    readonly vehicle_type_id: FieldRef<"category_attributes", 'String'>
    readonly key: FieldRef<"category_attributes", 'String'>
    readonly label: FieldRef<"category_attributes", 'String'>
    readonly type: FieldRef<"category_attributes", 'PropertyType'>
    readonly is_required: FieldRef<"category_attributes", 'Boolean'>
    readonly is_filterable: FieldRef<"category_attributes", 'Boolean'>
    readonly sort_order: FieldRef<"category_attributes", 'Int'>
    readonly options: FieldRef<"category_attributes", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * category_attributes findUnique
   */
  export type category_attributesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter, which category_attributes to fetch.
     */
    where: category_attributesWhereUniqueInput
  }

  /**
   * category_attributes findUniqueOrThrow
   */
  export type category_attributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter, which category_attributes to fetch.
     */
    where: category_attributesWhereUniqueInput
  }

  /**
   * category_attributes findFirst
   */
  export type category_attributesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter, which category_attributes to fetch.
     */
    where?: category_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_attributes to fetch.
     */
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_attributes.
     */
    cursor?: category_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_attributes.
     */
    distinct?: Category_attributesScalarFieldEnum | Category_attributesScalarFieldEnum[]
  }

  /**
   * category_attributes findFirstOrThrow
   */
  export type category_attributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter, which category_attributes to fetch.
     */
    where?: category_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_attributes to fetch.
     */
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_attributes.
     */
    cursor?: category_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_attributes.
     */
    distinct?: Category_attributesScalarFieldEnum | Category_attributesScalarFieldEnum[]
  }

  /**
   * category_attributes findMany
   */
  export type category_attributesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter, which category_attributes to fetch.
     */
    where?: category_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_attributes to fetch.
     */
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_attributes.
     */
    cursor?: category_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_attributes.
     */
    skip?: number
    distinct?: Category_attributesScalarFieldEnum | Category_attributesScalarFieldEnum[]
  }

  /**
   * category_attributes create
   */
  export type category_attributesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * The data needed to create a category_attributes.
     */
    data: XOR<category_attributesCreateInput, category_attributesUncheckedCreateInput>
  }

  /**
   * category_attributes createMany
   */
  export type category_attributesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many category_attributes.
     */
    data: category_attributesCreateManyInput | category_attributesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category_attributes createManyAndReturn
   */
  export type category_attributesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many category_attributes.
     */
    data: category_attributesCreateManyInput | category_attributesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * category_attributes update
   */
  export type category_attributesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * The data needed to update a category_attributes.
     */
    data: XOR<category_attributesUpdateInput, category_attributesUncheckedUpdateInput>
    /**
     * Choose, which category_attributes to update.
     */
    where: category_attributesWhereUniqueInput
  }

  /**
   * category_attributes updateMany
   */
  export type category_attributesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update category_attributes.
     */
    data: XOR<category_attributesUpdateManyMutationInput, category_attributesUncheckedUpdateManyInput>
    /**
     * Filter which category_attributes to update
     */
    where?: category_attributesWhereInput
  }

  /**
   * category_attributes upsert
   */
  export type category_attributesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * The filter to search for the category_attributes to update in case it exists.
     */
    where: category_attributesWhereUniqueInput
    /**
     * In case the category_attributes found by the `where` argument doesn't exist, create a new category_attributes with this data.
     */
    create: XOR<category_attributesCreateInput, category_attributesUncheckedCreateInput>
    /**
     * In case the category_attributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_attributesUpdateInput, category_attributesUncheckedUpdateInput>
  }

  /**
   * category_attributes delete
   */
  export type category_attributesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    /**
     * Filter which category_attributes to delete.
     */
    where: category_attributesWhereUniqueInput
  }

  /**
   * category_attributes deleteMany
   */
  export type category_attributesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_attributes to delete
     */
    where?: category_attributesWhereInput
  }

  /**
   * category_attributes.vehicle_types
   */
  export type category_attributes$vehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    where?: vehicle_typesWhereInput
  }

  /**
   * category_attributes without action
   */
  export type category_attributesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
  }


  /**
   * Model cities
   */

  export type AggregateCities = {
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    plate_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    plate_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CitiesCountAggregateOutputType = {
    id: number
    name: number
    plate_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CitiesMinAggregateInputType = {
    id?: true
    name?: true
    plate_code?: true
    created_at?: true
    updated_at?: true
  }

  export type CitiesMaxAggregateInputType = {
    id?: true
    name?: true
    plate_code?: true
    created_at?: true
    updated_at?: true
  }

  export type CitiesCountAggregateInputType = {
    id?: true
    name?: true
    plate_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to aggregate.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }




  export type citiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citiesWhereInput
    orderBy?: citiesOrderByWithAggregationInput | citiesOrderByWithAggregationInput[]
    by: CitiesScalarFieldEnum[] | CitiesScalarFieldEnum
    having?: citiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitiesCountAggregateInputType | true
    _min?: CitiesMinAggregateInputType
    _max?: CitiesMaxAggregateInputType
  }

  export type CitiesGroupByOutputType = {
    id: string
    name: string
    plate_code: string | null
    created_at: Date
    updated_at: Date
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  type GetCitiesGroupByPayload<T extends citiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CitiesGroupByOutputType[P]>
        }
      >
    >


  export type citiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plate_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    districts?: boolean | cities$districtsArgs<ExtArgs>
    listings?: boolean | cities$listingsArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cities"]>

  export type citiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plate_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["cities"]>

  export type citiesSelectScalar = {
    id?: boolean
    name?: boolean
    plate_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type citiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | cities$districtsArgs<ExtArgs>
    listings?: boolean | cities$listingsArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type citiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $citiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cities"
    objects: {
      districts: Prisma.$districtsPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      plate_code: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["cities"]>
    composites: {}
  }

  type citiesGetPayload<S extends boolean | null | undefined | citiesDefaultArgs> = $Result.GetResult<Prisma.$citiesPayload, S>

  type citiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<citiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CitiesCountAggregateInputType | true
    }

  export interface citiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cities'], meta: { name: 'cities' } }
    /**
     * Find zero or one Cities that matches the filter.
     * @param {citiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends citiesFindUniqueArgs>(args: SelectSubset<T, citiesFindUniqueArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {citiesFindUniqueOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends citiesFindUniqueOrThrowArgs>(args: SelectSubset<T, citiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends citiesFindFirstArgs>(args?: SelectSubset<T, citiesFindFirstArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends citiesFindFirstOrThrowArgs>(args?: SelectSubset<T, citiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citiesWithIdOnly = await prisma.cities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends citiesFindManyArgs>(args?: SelectSubset<T, citiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cities.
     * @param {citiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
     */
    create<T extends citiesCreateArgs>(args: SelectSubset<T, citiesCreateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {citiesCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const cities = await prisma.cities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends citiesCreateManyArgs>(args?: SelectSubset<T, citiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {citiesCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const cities = await prisma.cities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const citiesWithIdOnly = await prisma.cities.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends citiesCreateManyAndReturnArgs>(args?: SelectSubset<T, citiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cities.
     * @param {citiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
     */
    delete<T extends citiesDeleteArgs>(args: SelectSubset<T, citiesDeleteArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cities.
     * @param {citiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends citiesUpdateArgs>(args: SelectSubset<T, citiesUpdateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {citiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends citiesDeleteManyArgs>(args?: SelectSubset<T, citiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends citiesUpdateManyArgs>(args: SelectSubset<T, citiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities.
     * @param {citiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
     */
    upsert<T extends citiesUpsertArgs>(args: SelectSubset<T, citiesUpsertArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends citiesCountArgs>(
      args?: Subset<T, citiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): Prisma.PrismaPromise<GetCitiesAggregateType<T>>

    /**
     * Group by Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends citiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: citiesGroupByArgs['orderBy'] }
        : { orderBy?: citiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, citiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cities model
   */
  readonly fields: citiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__citiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    districts<T extends cities$districtsArgs<ExtArgs> = {}>(args?: Subset<T, cities$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends cities$listingsArgs<ExtArgs> = {}>(args?: Subset<T, cities$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cities model
   */ 
  interface citiesFieldRefs {
    readonly id: FieldRef<"cities", 'String'>
    readonly name: FieldRef<"cities", 'String'>
    readonly plate_code: FieldRef<"cities", 'String'>
    readonly created_at: FieldRef<"cities", 'DateTime'>
    readonly updated_at: FieldRef<"cities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cities findUnique
   */
  export type citiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findUniqueOrThrow
   */
  export type citiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findFirst
   */
  export type citiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findFirstOrThrow
   */
  export type citiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findMany
   */
  export type citiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities create
   */
  export type citiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to create a cities.
     */
    data: XOR<citiesCreateInput, citiesUncheckedCreateInput>
  }

  /**
   * cities createMany
   */
  export type citiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities.
     */
    data: citiesCreateManyInput | citiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cities createManyAndReturn
   */
  export type citiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many cities.
     */
    data: citiesCreateManyInput | citiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cities update
   */
  export type citiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to update a cities.
     */
    data: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
    /**
     * Choose, which cities to update.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities updateMany
   */
  export type citiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities.
     */
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: citiesWhereInput
  }

  /**
   * cities upsert
   */
  export type citiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The filter to search for the cities to update in case it exists.
     */
    where: citiesWhereUniqueInput
    /**
     * In case the cities found by the `where` argument doesn't exist, create a new cities with this data.
     */
    create: XOR<citiesCreateInput, citiesUncheckedCreateInput>
    /**
     * In case the cities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
  }

  /**
   * cities delete
   */
  export type citiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter which cities to delete.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities deleteMany
   */
  export type citiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to delete
     */
    where?: citiesWhereInput
  }

  /**
   * cities.districts
   */
  export type cities$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    where?: districtsWhereInput
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    cursor?: districtsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * cities.listings
   */
  export type cities$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * cities without action
   */
  export type citiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
  }


  /**
   * Model complaints
   */

  export type AggregateComplaints = {
    _count: ComplaintsCountAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  export type ComplaintsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    target_type: $Enums.ComplaintTarget | null
    target_user_id: string | null
    target_listing_id: string | null
    category: $Enums.ComplaintCategory | null
    description: string | null
    status: $Enums.ComplaintStatus | null
    admin_response: string | null
    admin_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    target_type: $Enums.ComplaintTarget | null
    target_user_id: string | null
    target_listing_id: string | null
    category: $Enums.ComplaintCategory | null
    description: string | null
    status: $Enums.ComplaintStatus | null
    admin_response: string | null
    admin_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintsCountAggregateOutputType = {
    id: number
    user_id: number
    target_type: number
    target_user_id: number
    target_listing_id: number
    category: number
    description: number
    status: number
    admin_response: number
    admin_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComplaintsMinAggregateInputType = {
    id?: true
    user_id?: true
    target_type?: true
    target_user_id?: true
    target_listing_id?: true
    category?: true
    description?: true
    status?: true
    admin_response?: true
    admin_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintsMaxAggregateInputType = {
    id?: true
    user_id?: true
    target_type?: true
    target_user_id?: true
    target_listing_id?: true
    category?: true
    description?: true
    status?: true
    admin_response?: true
    admin_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintsCountAggregateInputType = {
    id?: true
    user_id?: true
    target_type?: true
    target_user_id?: true
    target_listing_id?: true
    category?: true
    description?: true
    status?: true
    admin_response?: true
    admin_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComplaintsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to aggregate.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints
    **/
    _count?: true | ComplaintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintsMaxAggregateInputType
  }

  export type GetComplaintsAggregateType<T extends ComplaintsAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaints[P]>
      : GetScalarType<T[P], AggregateComplaints[P]>
  }




  export type complaintsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintsWhereInput
    orderBy?: complaintsOrderByWithAggregationInput | complaintsOrderByWithAggregationInput[]
    by: ComplaintsScalarFieldEnum[] | ComplaintsScalarFieldEnum
    having?: complaintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintsCountAggregateInputType | true
    _min?: ComplaintsMinAggregateInputType
    _max?: ComplaintsMaxAggregateInputType
  }

  export type ComplaintsGroupByOutputType = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_user_id: string | null
    target_listing_id: string | null
    category: $Enums.ComplaintCategory
    description: string | null
    status: $Enums.ComplaintStatus
    admin_response: string | null
    admin_id: string | null
    created_at: Date
    updated_at: Date
    _count: ComplaintsCountAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  type GetComplaintsGroupByPayload<T extends complaintsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
        }
      >
    >


  export type complaintsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    target_type?: boolean
    target_user_id?: boolean
    target_listing_id?: boolean
    category?: boolean
    description?: boolean
    status?: boolean
    admin_response?: boolean
    admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | complaints$listingsArgs<ExtArgs>
    users_complaints_target_user_idTousers?: boolean | complaints$users_complaints_target_user_idTousersArgs<ExtArgs>
    users_complaints_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    target_type?: boolean
    target_user_id?: boolean
    target_listing_id?: boolean
    category?: boolean
    description?: boolean
    status?: boolean
    admin_response?: boolean
    admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | complaints$listingsArgs<ExtArgs>
    users_complaints_target_user_idTousers?: boolean | complaints$users_complaints_target_user_idTousersArgs<ExtArgs>
    users_complaints_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type complaintsSelectScalar = {
    id?: boolean
    user_id?: boolean
    target_type?: boolean
    target_user_id?: boolean
    target_listing_id?: boolean
    category?: boolean
    description?: boolean
    status?: boolean
    admin_response?: boolean
    admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type complaintsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | complaints$listingsArgs<ExtArgs>
    users_complaints_target_user_idTousers?: boolean | complaints$users_complaints_target_user_idTousersArgs<ExtArgs>
    users_complaints_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type complaintsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | complaints$listingsArgs<ExtArgs>
    users_complaints_target_user_idTousers?: boolean | complaints$users_complaints_target_user_idTousersArgs<ExtArgs>
    users_complaints_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $complaintsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "complaints"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs> | null
      users_complaints_target_user_idTousers: Prisma.$UserPayload<ExtArgs> | null
      users_complaints_user_idTousers: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      target_type: $Enums.ComplaintTarget
      target_user_id: string | null
      target_listing_id: string | null
      category: $Enums.ComplaintCategory
      description: string | null
      status: $Enums.ComplaintStatus
      admin_response: string | null
      admin_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["complaints"]>
    composites: {}
  }

  type complaintsGetPayload<S extends boolean | null | undefined | complaintsDefaultArgs> = $Result.GetResult<Prisma.$complaintsPayload, S>

  type complaintsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<complaintsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintsCountAggregateInputType | true
    }

  export interface complaintsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['complaints'], meta: { name: 'complaints' } }
    /**
     * Find zero or one Complaints that matches the filter.
     * @param {complaintsFindUniqueArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends complaintsFindUniqueArgs>(args: SelectSubset<T, complaintsFindUniqueArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Complaints that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {complaintsFindUniqueOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends complaintsFindUniqueOrThrowArgs>(args: SelectSubset<T, complaintsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends complaintsFindFirstArgs>(args?: SelectSubset<T, complaintsFindFirstArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Complaints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindFirstOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends complaintsFindFirstOrThrowArgs>(args?: SelectSubset<T, complaintsFindFirstOrThrowArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaints.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintsWithIdOnly = await prisma.complaints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends complaintsFindManyArgs>(args?: SelectSubset<T, complaintsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Complaints.
     * @param {complaintsCreateArgs} args - Arguments to create a Complaints.
     * @example
     * // Create one Complaints
     * const Complaints = await prisma.complaints.create({
     *   data: {
     *     // ... data to create a Complaints
     *   }
     * })
     * 
     */
    create<T extends complaintsCreateArgs>(args: SelectSubset<T, complaintsCreateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Complaints.
     * @param {complaintsCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends complaintsCreateManyArgs>(args?: SelectSubset<T, complaintsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {complaintsCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends complaintsCreateManyAndReturnArgs>(args?: SelectSubset<T, complaintsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Complaints.
     * @param {complaintsDeleteArgs} args - Arguments to delete one Complaints.
     * @example
     * // Delete one Complaints
     * const Complaints = await prisma.complaints.delete({
     *   where: {
     *     // ... filter to delete one Complaints
     *   }
     * })
     * 
     */
    delete<T extends complaintsDeleteArgs>(args: SelectSubset<T, complaintsDeleteArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Complaints.
     * @param {complaintsUpdateArgs} args - Arguments to update one Complaints.
     * @example
     * // Update one Complaints
     * const complaints = await prisma.complaints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends complaintsUpdateArgs>(args: SelectSubset<T, complaintsUpdateArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Complaints.
     * @param {complaintsDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends complaintsDeleteManyArgs>(args?: SelectSubset<T, complaintsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends complaintsUpdateManyArgs>(args: SelectSubset<T, complaintsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaints.
     * @param {complaintsUpsertArgs} args - Arguments to update or create a Complaints.
     * @example
     * // Update or create a Complaints
     * const complaints = await prisma.complaints.upsert({
     *   create: {
     *     // ... data to create a Complaints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaints we want to update
     *   }
     * })
     */
    upsert<T extends complaintsUpsertArgs>(args: SelectSubset<T, complaintsUpsertArgs<ExtArgs>>): Prisma__complaintsClient<$Result.GetResult<Prisma.$complaintsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaints.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends complaintsCountArgs>(
      args?: Subset<T, complaintsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintsAggregateArgs>(args: Subset<T, ComplaintsAggregateArgs>): Prisma.PrismaPromise<GetComplaintsAggregateType<T>>

    /**
     * Group by Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends complaintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: complaintsGroupByArgs['orderBy'] }
        : { orderBy?: complaintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, complaintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the complaints model
   */
  readonly fields: complaintsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__complaintsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends complaints$listingsArgs<ExtArgs> = {}>(args?: Subset<T, complaints$listingsArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users_complaints_target_user_idTousers<T extends complaints$users_complaints_target_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, complaints$users_complaints_target_user_idTousersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users_complaints_user_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the complaints model
   */ 
  interface complaintsFieldRefs {
    readonly id: FieldRef<"complaints", 'String'>
    readonly user_id: FieldRef<"complaints", 'String'>
    readonly target_type: FieldRef<"complaints", 'ComplaintTarget'>
    readonly target_user_id: FieldRef<"complaints", 'String'>
    readonly target_listing_id: FieldRef<"complaints", 'String'>
    readonly category: FieldRef<"complaints", 'ComplaintCategory'>
    readonly description: FieldRef<"complaints", 'String'>
    readonly status: FieldRef<"complaints", 'ComplaintStatus'>
    readonly admin_response: FieldRef<"complaints", 'String'>
    readonly admin_id: FieldRef<"complaints", 'String'>
    readonly created_at: FieldRef<"complaints", 'DateTime'>
    readonly updated_at: FieldRef<"complaints", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * complaints findUnique
   */
  export type complaintsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findUniqueOrThrow
   */
  export type complaintsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints findFirst
   */
  export type complaintsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findFirstOrThrow
   */
  export type complaintsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints findMany
   */
  export type complaintsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintsOrderByWithRelationInput | complaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints.
     */
    cursor?: complaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * complaints create
   */
  export type complaintsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to create a complaints.
     */
    data: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
  }

  /**
   * complaints createMany
   */
  export type complaintsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * complaints createManyAndReturn
   */
  export type complaintsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many complaints.
     */
    data: complaintsCreateManyInput | complaintsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * complaints update
   */
  export type complaintsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The data needed to update a complaints.
     */
    data: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
    /**
     * Choose, which complaints to update.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints updateMany
   */
  export type complaintsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintsWhereInput
  }

  /**
   * complaints upsert
   */
  export type complaintsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * The filter to search for the complaints to update in case it exists.
     */
    where: complaintsWhereUniqueInput
    /**
     * In case the complaints found by the `where` argument doesn't exist, create a new complaints with this data.
     */
    create: XOR<complaintsCreateInput, complaintsUncheckedCreateInput>
    /**
     * In case the complaints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<complaintsUpdateInput, complaintsUncheckedUpdateInput>
  }

  /**
   * complaints delete
   */
  export type complaintsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
    /**
     * Filter which complaints to delete.
     */
    where: complaintsWhereUniqueInput
  }

  /**
   * complaints deleteMany
   */
  export type complaintsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to delete
     */
    where?: complaintsWhereInput
  }

  /**
   * complaints.listings
   */
  export type complaints$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
  }

  /**
   * complaints.users_complaints_target_user_idTousers
   */
  export type complaints$users_complaints_target_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * complaints without action
   */
  export type complaintsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints
     */
    select?: complaintsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintsInclude<ExtArgs> | null
  }


  /**
   * Model conversations
   */

  export type AggregateConversations = {
    _count: ConversationsCountAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  export type ConversationsMinAggregateOutputType = {
    id: string | null
    participant1_id: string | null
    participant2_id: string | null
    listing_id: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConversationsMaxAggregateOutputType = {
    id: string | null
    participant1_id: string | null
    participant2_id: string | null
    listing_id: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConversationsCountAggregateOutputType = {
    id: number
    participant1_id: number
    participant2_id: number
    listing_id: number
    last_message_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ConversationsMinAggregateInputType = {
    id?: true
    participant1_id?: true
    participant2_id?: true
    listing_id?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ConversationsMaxAggregateInputType = {
    id?: true
    participant1_id?: true
    participant2_id?: true
    listing_id?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ConversationsCountAggregateInputType = {
    id?: true
    participant1_id?: true
    participant2_id?: true
    listing_id?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ConversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to aggregate.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationsMaxAggregateInputType
  }

  export type GetConversationsAggregateType<T extends ConversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations[P]>
      : GetScalarType<T[P], AggregateConversations[P]>
  }




  export type conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithAggregationInput | conversationsOrderByWithAggregationInput[]
    by: ConversationsScalarFieldEnum[] | ConversationsScalarFieldEnum
    having?: conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationsCountAggregateInputType | true
    _min?: ConversationsMinAggregateInputType
    _max?: ConversationsMaxAggregateInputType
  }

  export type ConversationsGroupByOutputType = {
    id: string
    participant1_id: string
    participant2_id: string
    listing_id: string | null
    last_message_at: Date | null
    created_at: Date
    updated_at: Date
    _count: ConversationsCountAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  type GetConversationsGroupByPayload<T extends conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
        }
      >
    >


  export type conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1_id?: boolean
    participant2_id?: boolean
    listing_id?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | conversations$listingsArgs<ExtArgs>
    users_conversations_participant1_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_conversations_participant2_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | conversations$messagesArgs<ExtArgs>
    _count?: boolean | ConversationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1_id?: boolean
    participant2_id?: boolean
    listing_id?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | conversations$listingsArgs<ExtArgs>
    users_conversations_participant1_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_conversations_participant2_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectScalar = {
    id?: boolean
    participant1_id?: boolean
    participant2_id?: boolean
    listing_id?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type conversationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | conversations$listingsArgs<ExtArgs>
    users_conversations_participant1_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_conversations_participant2_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | conversations$messagesArgs<ExtArgs>
    _count?: boolean | ConversationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type conversationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | conversations$listingsArgs<ExtArgs>
    users_conversations_participant1_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_conversations_participant2_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs> | null
      users_conversations_participant1_idTousers: Prisma.$UserPayload<ExtArgs>
      users_conversations_participant2_idTousers: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participant1_id: string
      participant2_id: string
      listing_id: string | null
      last_message_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["conversations"]>
    composites: {}
  }

  type conversationsGetPayload<S extends boolean | null | undefined | conversationsDefaultArgs> = $Result.GetResult<Prisma.$conversationsPayload, S>

  type conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationsCountAggregateInputType | true
    }

  export interface conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations'], meta: { name: 'conversations' } }
    /**
     * Find zero or one Conversations that matches the filter.
     * @param {conversationsFindUniqueArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationsFindUniqueArgs>(args: SelectSubset<T, conversationsFindUniqueArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {conversationsFindUniqueOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationsFindFirstArgs>(args?: SelectSubset<T, conversationsFindFirstArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversations.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationsWithIdOnly = await prisma.conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationsFindManyArgs>(args?: SelectSubset<T, conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversations.
     * @param {conversationsCreateArgs} args - Arguments to create a Conversations.
     * @example
     * // Create one Conversations
     * const Conversations = await prisma.conversations.create({
     *   data: {
     *     // ... data to create a Conversations
     *   }
     * })
     * 
     */
    create<T extends conversationsCreateArgs>(args: SelectSubset<T, conversationsCreateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {conversationsCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationsCreateManyArgs>(args?: SelectSubset<T, conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationsCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationsWithIdOnly = await prisma.conversations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversations.
     * @param {conversationsDeleteArgs} args - Arguments to delete one Conversations.
     * @example
     * // Delete one Conversations
     * const Conversations = await prisma.conversations.delete({
     *   where: {
     *     // ... filter to delete one Conversations
     *   }
     * })
     * 
     */
    delete<T extends conversationsDeleteArgs>(args: SelectSubset<T, conversationsDeleteArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversations.
     * @param {conversationsUpdateArgs} args - Arguments to update one Conversations.
     * @example
     * // Update one Conversations
     * const conversations = await prisma.conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationsUpdateArgs>(args: SelectSubset<T, conversationsUpdateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {conversationsDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationsDeleteManyArgs>(args?: SelectSubset<T, conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversations = await prisma.conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationsUpdateManyArgs>(args: SelectSubset<T, conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations.
     * @param {conversationsUpsertArgs} args - Arguments to update or create a Conversations.
     * @example
     * // Update or create a Conversations
     * const conversations = await prisma.conversations.upsert({
     *   create: {
     *     // ... data to create a Conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations we want to update
     *   }
     * })
     */
    upsert<T extends conversationsUpsertArgs>(args: SelectSubset<T, conversationsUpsertArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversations.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationsCountArgs>(
      args?: Subset<T, conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationsAggregateArgs>(args: Subset<T, ConversationsAggregateArgs>): Prisma.PrismaPromise<GetConversationsAggregateType<T>>

    /**
     * Group by Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationsGroupByArgs['orderBy'] }
        : { orderBy?: conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations model
   */
  readonly fields: conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends conversations$listingsArgs<ExtArgs> = {}>(args?: Subset<T, conversations$listingsArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users_conversations_participant1_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users_conversations_participant2_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends conversations$messagesArgs<ExtArgs> = {}>(args?: Subset<T, conversations$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversations model
   */ 
  interface conversationsFieldRefs {
    readonly id: FieldRef<"conversations", 'String'>
    readonly participant1_id: FieldRef<"conversations", 'String'>
    readonly participant2_id: FieldRef<"conversations", 'String'>
    readonly listing_id: FieldRef<"conversations", 'String'>
    readonly last_message_at: FieldRef<"conversations", 'DateTime'>
    readonly created_at: FieldRef<"conversations", 'DateTime'>
    readonly updated_at: FieldRef<"conversations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversations findUnique
   */
  export type conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findUniqueOrThrow
   */
  export type conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findFirst
   */
  export type conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findFirstOrThrow
   */
  export type conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findMany
   */
  export type conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations create
   */
  export type conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The data needed to create a conversations.
     */
    data: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
  }

  /**
   * conversations createMany
   */
  export type conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversations createManyAndReturn
   */
  export type conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversations update
   */
  export type conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The data needed to update a conversations.
     */
    data: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
    /**
     * Choose, which conversations to update.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations updateMany
   */
  export type conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations upsert
   */
  export type conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The filter to search for the conversations to update in case it exists.
     */
    where: conversationsWhereUniqueInput
    /**
     * In case the conversations found by the `where` argument doesn't exist, create a new conversations with this data.
     */
    create: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
    /**
     * In case the conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
  }

  /**
   * conversations delete
   */
  export type conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter which conversations to delete.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations deleteMany
   */
  export type conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations.listings
   */
  export type conversations$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
  }

  /**
   * conversations.messages
   */
  export type conversations$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * conversations without action
   */
  export type conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationsInclude<ExtArgs> | null
  }


  /**
   * Model districts
   */

  export type AggregateDistricts = {
    _count: DistrictsCountAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  export type DistrictsMinAggregateOutputType = {
    id: string | null
    name: string | null
    city_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictsCountAggregateOutputType = {
    id: number
    name: number
    city_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DistrictsMinAggregateInputType = {
    id?: true
    name?: true
    city_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictsMaxAggregateInputType = {
    id?: true
    name?: true
    city_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictsCountAggregateInputType = {
    id?: true
    name?: true
    city_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DistrictsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to aggregate.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned districts
    **/
    _count?: true | DistrictsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictsMaxAggregateInputType
  }

  export type GetDistrictsAggregateType<T extends DistrictsAggregateArgs> = {
        [P in keyof T & keyof AggregateDistricts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistricts[P]>
      : GetScalarType<T[P], AggregateDistricts[P]>
  }




  export type districtsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtsWhereInput
    orderBy?: districtsOrderByWithAggregationInput | districtsOrderByWithAggregationInput[]
    by: DistrictsScalarFieldEnum[] | DistrictsScalarFieldEnum
    having?: districtsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictsCountAggregateInputType | true
    _min?: DistrictsMinAggregateInputType
    _max?: DistrictsMaxAggregateInputType
  }

  export type DistrictsGroupByOutputType = {
    id: string
    name: string
    city_id: string
    created_at: Date
    updated_at: Date
    _count: DistrictsCountAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  type GetDistrictsGroupByPayload<T extends districtsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
        }
      >
    >


  export type districtsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    cities?: boolean | citiesDefaultArgs<ExtArgs>
    listings?: boolean | districts$listingsArgs<ExtArgs>
    _count?: boolean | DistrictsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    cities?: boolean | citiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectScalar = {
    id?: boolean
    name?: boolean
    city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type districtsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | citiesDefaultArgs<ExtArgs>
    listings?: boolean | districts$listingsArgs<ExtArgs>
    _count?: boolean | DistrictsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type districtsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | citiesDefaultArgs<ExtArgs>
  }

  export type $districtsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "districts"
    objects: {
      cities: Prisma.$citiesPayload<ExtArgs>
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      city_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["districts"]>
    composites: {}
  }

  type districtsGetPayload<S extends boolean | null | undefined | districtsDefaultArgs> = $Result.GetResult<Prisma.$districtsPayload, S>

  type districtsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<districtsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictsCountAggregateInputType | true
    }

  export interface districtsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['districts'], meta: { name: 'districts' } }
    /**
     * Find zero or one Districts that matches the filter.
     * @param {districtsFindUniqueArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends districtsFindUniqueArgs>(args: SelectSubset<T, districtsFindUniqueArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Districts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {districtsFindUniqueOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends districtsFindUniqueOrThrowArgs>(args: SelectSubset<T, districtsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends districtsFindFirstArgs>(args?: SelectSubset<T, districtsFindFirstArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Districts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends districtsFindFirstOrThrowArgs>(args?: SelectSubset<T, districtsFindFirstOrThrowArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.districts.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.districts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtsWithIdOnly = await prisma.districts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends districtsFindManyArgs>(args?: SelectSubset<T, districtsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Districts.
     * @param {districtsCreateArgs} args - Arguments to create a Districts.
     * @example
     * // Create one Districts
     * const Districts = await prisma.districts.create({
     *   data: {
     *     // ... data to create a Districts
     *   }
     * })
     * 
     */
    create<T extends districtsCreateArgs>(args: SelectSubset<T, districtsCreateArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Districts.
     * @param {districtsCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const districts = await prisma.districts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends districtsCreateManyArgs>(args?: SelectSubset<T, districtsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {districtsCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const districts = await prisma.districts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtsWithIdOnly = await prisma.districts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends districtsCreateManyAndReturnArgs>(args?: SelectSubset<T, districtsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Districts.
     * @param {districtsDeleteArgs} args - Arguments to delete one Districts.
     * @example
     * // Delete one Districts
     * const Districts = await prisma.districts.delete({
     *   where: {
     *     // ... filter to delete one Districts
     *   }
     * })
     * 
     */
    delete<T extends districtsDeleteArgs>(args: SelectSubset<T, districtsDeleteArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Districts.
     * @param {districtsUpdateArgs} args - Arguments to update one Districts.
     * @example
     * // Update one Districts
     * const districts = await prisma.districts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends districtsUpdateArgs>(args: SelectSubset<T, districtsUpdateArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {districtsDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.districts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends districtsDeleteManyArgs>(args?: SelectSubset<T, districtsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const districts = await prisma.districts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends districtsUpdateManyArgs>(args: SelectSubset<T, districtsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Districts.
     * @param {districtsUpsertArgs} args - Arguments to update or create a Districts.
     * @example
     * // Update or create a Districts
     * const districts = await prisma.districts.upsert({
     *   create: {
     *     // ... data to create a Districts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Districts we want to update
     *   }
     * })
     */
    upsert<T extends districtsUpsertArgs>(args: SelectSubset<T, districtsUpsertArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.districts.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends districtsCountArgs>(
      args?: Subset<T, districtsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictsAggregateArgs>(args: Subset<T, DistrictsAggregateArgs>): Prisma.PrismaPromise<GetDistrictsAggregateType<T>>

    /**
     * Group by Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends districtsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: districtsGroupByArgs['orderBy'] }
        : { orderBy?: districtsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, districtsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the districts model
   */
  readonly fields: districtsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for districts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__districtsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends citiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, citiesDefaultArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    listings<T extends districts$listingsArgs<ExtArgs> = {}>(args?: Subset<T, districts$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the districts model
   */ 
  interface districtsFieldRefs {
    readonly id: FieldRef<"districts", 'String'>
    readonly name: FieldRef<"districts", 'String'>
    readonly city_id: FieldRef<"districts", 'String'>
    readonly created_at: FieldRef<"districts", 'DateTime'>
    readonly updated_at: FieldRef<"districts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * districts findUnique
   */
  export type districtsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts findUniqueOrThrow
   */
  export type districtsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts findFirst
   */
  export type districtsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts findFirstOrThrow
   */
  export type districtsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts findMany
   */
  export type districtsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts create
   */
  export type districtsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The data needed to create a districts.
     */
    data: XOR<districtsCreateInput, districtsUncheckedCreateInput>
  }

  /**
   * districts createMany
   */
  export type districtsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many districts.
     */
    data: districtsCreateManyInput | districtsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * districts createManyAndReturn
   */
  export type districtsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many districts.
     */
    data: districtsCreateManyInput | districtsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * districts update
   */
  export type districtsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The data needed to update a districts.
     */
    data: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
    /**
     * Choose, which districts to update.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts updateMany
   */
  export type districtsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update districts.
     */
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyInput>
    /**
     * Filter which districts to update
     */
    where?: districtsWhereInput
  }

  /**
   * districts upsert
   */
  export type districtsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The filter to search for the districts to update in case it exists.
     */
    where: districtsWhereUniqueInput
    /**
     * In case the districts found by the `where` argument doesn't exist, create a new districts with this data.
     */
    create: XOR<districtsCreateInput, districtsUncheckedCreateInput>
    /**
     * In case the districts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
  }

  /**
   * districts delete
   */
  export type districtsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter which districts to delete.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts deleteMany
   */
  export type districtsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to delete
     */
    where?: districtsWhereInput
  }

  /**
   * districts.listings
   */
  export type districts$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * districts without action
   */
  export type districtsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
  }


  /**
   * Model feature_definitions
   */

  export type AggregateFeature_definitions = {
    _count: Feature_definitionsCountAggregateOutputType | null
    _avg: Feature_definitionsAvgAggregateOutputType | null
    _sum: Feature_definitionsSumAggregateOutputType | null
    _min: Feature_definitionsMinAggregateOutputType | null
    _max: Feature_definitionsMaxAggregateOutputType | null
  }

  export type Feature_definitionsAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type Feature_definitionsSumAggregateOutputType = {
    sort_order: number | null
  }

  export type Feature_definitionsMinAggregateOutputType = {
    id: string | null
    group_id: string | null
    key: string | null
    label: string | null
    sort_order: number | null
  }

  export type Feature_definitionsMaxAggregateOutputType = {
    id: string | null
    group_id: string | null
    key: string | null
    label: string | null
    sort_order: number | null
  }

  export type Feature_definitionsCountAggregateOutputType = {
    id: number
    group_id: number
    key: number
    label: number
    sort_order: number
    _all: number
  }


  export type Feature_definitionsAvgAggregateInputType = {
    sort_order?: true
  }

  export type Feature_definitionsSumAggregateInputType = {
    sort_order?: true
  }

  export type Feature_definitionsMinAggregateInputType = {
    id?: true
    group_id?: true
    key?: true
    label?: true
    sort_order?: true
  }

  export type Feature_definitionsMaxAggregateInputType = {
    id?: true
    group_id?: true
    key?: true
    label?: true
    sort_order?: true
  }

  export type Feature_definitionsCountAggregateInputType = {
    id?: true
    group_id?: true
    key?: true
    label?: true
    sort_order?: true
    _all?: true
  }

  export type Feature_definitionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_definitions to aggregate.
     */
    where?: feature_definitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_definitions to fetch.
     */
    orderBy?: feature_definitionsOrderByWithRelationInput | feature_definitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feature_definitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feature_definitions
    **/
    _count?: true | Feature_definitionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Feature_definitionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Feature_definitionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Feature_definitionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Feature_definitionsMaxAggregateInputType
  }

  export type GetFeature_definitionsAggregateType<T extends Feature_definitionsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature_definitions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature_definitions[P]>
      : GetScalarType<T[P], AggregateFeature_definitions[P]>
  }




  export type feature_definitionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_definitionsWhereInput
    orderBy?: feature_definitionsOrderByWithAggregationInput | feature_definitionsOrderByWithAggregationInput[]
    by: Feature_definitionsScalarFieldEnum[] | Feature_definitionsScalarFieldEnum
    having?: feature_definitionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Feature_definitionsCountAggregateInputType | true
    _avg?: Feature_definitionsAvgAggregateInputType
    _sum?: Feature_definitionsSumAggregateInputType
    _min?: Feature_definitionsMinAggregateInputType
    _max?: Feature_definitionsMaxAggregateInputType
  }

  export type Feature_definitionsGroupByOutputType = {
    id: string
    group_id: string
    key: string
    label: string
    sort_order: number
    _count: Feature_definitionsCountAggregateOutputType | null
    _avg: Feature_definitionsAvgAggregateOutputType | null
    _sum: Feature_definitionsSumAggregateOutputType | null
    _min: Feature_definitionsMinAggregateOutputType | null
    _max: Feature_definitionsMaxAggregateOutputType | null
  }

  type GetFeature_definitionsGroupByPayload<T extends feature_definitionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Feature_definitionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Feature_definitionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Feature_definitionsGroupByOutputType[P]>
            : GetScalarType<T[P], Feature_definitionsGroupByOutputType[P]>
        }
      >
    >


  export type feature_definitionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    key?: boolean
    label?: boolean
    sort_order?: boolean
    feature_groups?: boolean | feature_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature_definitions"]>

  export type feature_definitionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    key?: boolean
    label?: boolean
    sort_order?: boolean
    feature_groups?: boolean | feature_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature_definitions"]>

  export type feature_definitionsSelectScalar = {
    id?: boolean
    group_id?: boolean
    key?: boolean
    label?: boolean
    sort_order?: boolean
  }

  export type feature_definitionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature_groups?: boolean | feature_groupsDefaultArgs<ExtArgs>
  }
  export type feature_definitionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature_groups?: boolean | feature_groupsDefaultArgs<ExtArgs>
  }

  export type $feature_definitionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feature_definitions"
    objects: {
      feature_groups: Prisma.$feature_groupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      group_id: string
      key: string
      label: string
      sort_order: number
    }, ExtArgs["result"]["feature_definitions"]>
    composites: {}
  }

  type feature_definitionsGetPayload<S extends boolean | null | undefined | feature_definitionsDefaultArgs> = $Result.GetResult<Prisma.$feature_definitionsPayload, S>

  type feature_definitionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feature_definitionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Feature_definitionsCountAggregateInputType | true
    }

  export interface feature_definitionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feature_definitions'], meta: { name: 'feature_definitions' } }
    /**
     * Find zero or one Feature_definitions that matches the filter.
     * @param {feature_definitionsFindUniqueArgs} args - Arguments to find a Feature_definitions
     * @example
     * // Get one Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feature_definitionsFindUniqueArgs>(args: SelectSubset<T, feature_definitionsFindUniqueArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feature_definitions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {feature_definitionsFindUniqueOrThrowArgs} args - Arguments to find a Feature_definitions
     * @example
     * // Get one Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feature_definitionsFindUniqueOrThrowArgs>(args: SelectSubset<T, feature_definitionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feature_definitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsFindFirstArgs} args - Arguments to find a Feature_definitions
     * @example
     * // Get one Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feature_definitionsFindFirstArgs>(args?: SelectSubset<T, feature_definitionsFindFirstArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feature_definitions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsFindFirstOrThrowArgs} args - Arguments to find a Feature_definitions
     * @example
     * // Get one Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feature_definitionsFindFirstOrThrowArgs>(args?: SelectSubset<T, feature_definitionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feature_definitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findMany()
     * 
     * // Get first 10 Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feature_definitionsWithIdOnly = await prisma.feature_definitions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feature_definitionsFindManyArgs>(args?: SelectSubset<T, feature_definitionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feature_definitions.
     * @param {feature_definitionsCreateArgs} args - Arguments to create a Feature_definitions.
     * @example
     * // Create one Feature_definitions
     * const Feature_definitions = await prisma.feature_definitions.create({
     *   data: {
     *     // ... data to create a Feature_definitions
     *   }
     * })
     * 
     */
    create<T extends feature_definitionsCreateArgs>(args: SelectSubset<T, feature_definitionsCreateArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feature_definitions.
     * @param {feature_definitionsCreateManyArgs} args - Arguments to create many Feature_definitions.
     * @example
     * // Create many Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feature_definitionsCreateManyArgs>(args?: SelectSubset<T, feature_definitionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feature_definitions and returns the data saved in the database.
     * @param {feature_definitionsCreateManyAndReturnArgs} args - Arguments to create many Feature_definitions.
     * @example
     * // Create many Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feature_definitions and only return the `id`
     * const feature_definitionsWithIdOnly = await prisma.feature_definitions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feature_definitionsCreateManyAndReturnArgs>(args?: SelectSubset<T, feature_definitionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feature_definitions.
     * @param {feature_definitionsDeleteArgs} args - Arguments to delete one Feature_definitions.
     * @example
     * // Delete one Feature_definitions
     * const Feature_definitions = await prisma.feature_definitions.delete({
     *   where: {
     *     // ... filter to delete one Feature_definitions
     *   }
     * })
     * 
     */
    delete<T extends feature_definitionsDeleteArgs>(args: SelectSubset<T, feature_definitionsDeleteArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feature_definitions.
     * @param {feature_definitionsUpdateArgs} args - Arguments to update one Feature_definitions.
     * @example
     * // Update one Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feature_definitionsUpdateArgs>(args: SelectSubset<T, feature_definitionsUpdateArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feature_definitions.
     * @param {feature_definitionsDeleteManyArgs} args - Arguments to filter Feature_definitions to delete.
     * @example
     * // Delete a few Feature_definitions
     * const { count } = await prisma.feature_definitions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feature_definitionsDeleteManyArgs>(args?: SelectSubset<T, feature_definitionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feature_definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feature_definitionsUpdateManyArgs>(args: SelectSubset<T, feature_definitionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature_definitions.
     * @param {feature_definitionsUpsertArgs} args - Arguments to update or create a Feature_definitions.
     * @example
     * // Update or create a Feature_definitions
     * const feature_definitions = await prisma.feature_definitions.upsert({
     *   create: {
     *     // ... data to create a Feature_definitions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature_definitions we want to update
     *   }
     * })
     */
    upsert<T extends feature_definitionsUpsertArgs>(args: SelectSubset<T, feature_definitionsUpsertArgs<ExtArgs>>): Prisma__feature_definitionsClient<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feature_definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsCountArgs} args - Arguments to filter Feature_definitions to count.
     * @example
     * // Count the number of Feature_definitions
     * const count = await prisma.feature_definitions.count({
     *   where: {
     *     // ... the filter for the Feature_definitions we want to count
     *   }
     * })
    **/
    count<T extends feature_definitionsCountArgs>(
      args?: Subset<T, feature_definitionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Feature_definitionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature_definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Feature_definitionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Feature_definitionsAggregateArgs>(args: Subset<T, Feature_definitionsAggregateArgs>): Prisma.PrismaPromise<GetFeature_definitionsAggregateType<T>>

    /**
     * Group by Feature_definitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_definitionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feature_definitionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feature_definitionsGroupByArgs['orderBy'] }
        : { orderBy?: feature_definitionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feature_definitionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeature_definitionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feature_definitions model
   */
  readonly fields: feature_definitionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feature_definitions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feature_definitionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature_groups<T extends feature_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, feature_groupsDefaultArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feature_definitions model
   */ 
  interface feature_definitionsFieldRefs {
    readonly id: FieldRef<"feature_definitions", 'String'>
    readonly group_id: FieldRef<"feature_definitions", 'String'>
    readonly key: FieldRef<"feature_definitions", 'String'>
    readonly label: FieldRef<"feature_definitions", 'String'>
    readonly sort_order: FieldRef<"feature_definitions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * feature_definitions findUnique
   */
  export type feature_definitionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter, which feature_definitions to fetch.
     */
    where: feature_definitionsWhereUniqueInput
  }

  /**
   * feature_definitions findUniqueOrThrow
   */
  export type feature_definitionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter, which feature_definitions to fetch.
     */
    where: feature_definitionsWhereUniqueInput
  }

  /**
   * feature_definitions findFirst
   */
  export type feature_definitionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter, which feature_definitions to fetch.
     */
    where?: feature_definitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_definitions to fetch.
     */
    orderBy?: feature_definitionsOrderByWithRelationInput | feature_definitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_definitions.
     */
    cursor?: feature_definitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_definitions.
     */
    distinct?: Feature_definitionsScalarFieldEnum | Feature_definitionsScalarFieldEnum[]
  }

  /**
   * feature_definitions findFirstOrThrow
   */
  export type feature_definitionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter, which feature_definitions to fetch.
     */
    where?: feature_definitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_definitions to fetch.
     */
    orderBy?: feature_definitionsOrderByWithRelationInput | feature_definitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_definitions.
     */
    cursor?: feature_definitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_definitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_definitions.
     */
    distinct?: Feature_definitionsScalarFieldEnum | Feature_definitionsScalarFieldEnum[]
  }

  /**
   * feature_definitions findMany
   */
  export type feature_definitionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter, which feature_definitions to fetch.
     */
    where?: feature_definitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_definitions to fetch.
     */
    orderBy?: feature_definitionsOrderByWithRelationInput | feature_definitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feature_definitions.
     */
    cursor?: feature_definitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_definitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_definitions.
     */
    skip?: number
    distinct?: Feature_definitionsScalarFieldEnum | Feature_definitionsScalarFieldEnum[]
  }

  /**
   * feature_definitions create
   */
  export type feature_definitionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * The data needed to create a feature_definitions.
     */
    data: XOR<feature_definitionsCreateInput, feature_definitionsUncheckedCreateInput>
  }

  /**
   * feature_definitions createMany
   */
  export type feature_definitionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feature_definitions.
     */
    data: feature_definitionsCreateManyInput | feature_definitionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feature_definitions createManyAndReturn
   */
  export type feature_definitionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many feature_definitions.
     */
    data: feature_definitionsCreateManyInput | feature_definitionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * feature_definitions update
   */
  export type feature_definitionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * The data needed to update a feature_definitions.
     */
    data: XOR<feature_definitionsUpdateInput, feature_definitionsUncheckedUpdateInput>
    /**
     * Choose, which feature_definitions to update.
     */
    where: feature_definitionsWhereUniqueInput
  }

  /**
   * feature_definitions updateMany
   */
  export type feature_definitionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feature_definitions.
     */
    data: XOR<feature_definitionsUpdateManyMutationInput, feature_definitionsUncheckedUpdateManyInput>
    /**
     * Filter which feature_definitions to update
     */
    where?: feature_definitionsWhereInput
  }

  /**
   * feature_definitions upsert
   */
  export type feature_definitionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * The filter to search for the feature_definitions to update in case it exists.
     */
    where: feature_definitionsWhereUniqueInput
    /**
     * In case the feature_definitions found by the `where` argument doesn't exist, create a new feature_definitions with this data.
     */
    create: XOR<feature_definitionsCreateInput, feature_definitionsUncheckedCreateInput>
    /**
     * In case the feature_definitions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feature_definitionsUpdateInput, feature_definitionsUncheckedUpdateInput>
  }

  /**
   * feature_definitions delete
   */
  export type feature_definitionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    /**
     * Filter which feature_definitions to delete.
     */
    where: feature_definitionsWhereUniqueInput
  }

  /**
   * feature_definitions deleteMany
   */
  export type feature_definitionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_definitions to delete
     */
    where?: feature_definitionsWhereInput
  }

  /**
   * feature_definitions without action
   */
  export type feature_definitionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
  }


  /**
   * Model feature_groups
   */

  export type AggregateFeature_groups = {
    _count: Feature_groupsCountAggregateOutputType | null
    _avg: Feature_groupsAvgAggregateOutputType | null
    _sum: Feature_groupsSumAggregateOutputType | null
    _min: Feature_groupsMinAggregateOutputType | null
    _max: Feature_groupsMaxAggregateOutputType | null
  }

  export type Feature_groupsAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type Feature_groupsSumAggregateOutputType = {
    sort_order: number | null
  }

  export type Feature_groupsMinAggregateOutputType = {
    id: string | null
    vehicle_type_id: string | null
    name: string | null
    label: string | null
    sort_order: number | null
  }

  export type Feature_groupsMaxAggregateOutputType = {
    id: string | null
    vehicle_type_id: string | null
    name: string | null
    label: string | null
    sort_order: number | null
  }

  export type Feature_groupsCountAggregateOutputType = {
    id: number
    vehicle_type_id: number
    name: number
    label: number
    sort_order: number
    _all: number
  }


  export type Feature_groupsAvgAggregateInputType = {
    sort_order?: true
  }

  export type Feature_groupsSumAggregateInputType = {
    sort_order?: true
  }

  export type Feature_groupsMinAggregateInputType = {
    id?: true
    vehicle_type_id?: true
    name?: true
    label?: true
    sort_order?: true
  }

  export type Feature_groupsMaxAggregateInputType = {
    id?: true
    vehicle_type_id?: true
    name?: true
    label?: true
    sort_order?: true
  }

  export type Feature_groupsCountAggregateInputType = {
    id?: true
    vehicle_type_id?: true
    name?: true
    label?: true
    sort_order?: true
    _all?: true
  }

  export type Feature_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_groups to aggregate.
     */
    where?: feature_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_groups to fetch.
     */
    orderBy?: feature_groupsOrderByWithRelationInput | feature_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feature_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feature_groups
    **/
    _count?: true | Feature_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Feature_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Feature_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Feature_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Feature_groupsMaxAggregateInputType
  }

  export type GetFeature_groupsAggregateType<T extends Feature_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature_groups[P]>
      : GetScalarType<T[P], AggregateFeature_groups[P]>
  }




  export type feature_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_groupsWhereInput
    orderBy?: feature_groupsOrderByWithAggregationInput | feature_groupsOrderByWithAggregationInput[]
    by: Feature_groupsScalarFieldEnum[] | Feature_groupsScalarFieldEnum
    having?: feature_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Feature_groupsCountAggregateInputType | true
    _avg?: Feature_groupsAvgAggregateInputType
    _sum?: Feature_groupsSumAggregateInputType
    _min?: Feature_groupsMinAggregateInputType
    _max?: Feature_groupsMaxAggregateInputType
  }

  export type Feature_groupsGroupByOutputType = {
    id: string
    vehicle_type_id: string
    name: string
    label: string
    sort_order: number
    _count: Feature_groupsCountAggregateOutputType | null
    _avg: Feature_groupsAvgAggregateOutputType | null
    _sum: Feature_groupsSumAggregateOutputType | null
    _min: Feature_groupsMinAggregateOutputType | null
    _max: Feature_groupsMaxAggregateOutputType | null
  }

  type GetFeature_groupsGroupByPayload<T extends feature_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Feature_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Feature_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Feature_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Feature_groupsGroupByOutputType[P]>
        }
      >
    >


  export type feature_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_type_id?: boolean
    name?: boolean
    label?: boolean
    sort_order?: boolean
    feature_definitions?: boolean | feature_groups$feature_definitionsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    _count?: boolean | Feature_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature_groups"]>

  export type feature_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_type_id?: boolean
    name?: boolean
    label?: boolean
    sort_order?: boolean
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature_groups"]>

  export type feature_groupsSelectScalar = {
    id?: boolean
    vehicle_type_id?: boolean
    name?: boolean
    label?: boolean
    sort_order?: boolean
  }

  export type feature_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature_definitions?: boolean | feature_groups$feature_definitionsArgs<ExtArgs>
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
    _count?: boolean | Feature_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type feature_groupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_types?: boolean | vehicle_typesDefaultArgs<ExtArgs>
  }

  export type $feature_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feature_groups"
    objects: {
      feature_definitions: Prisma.$feature_definitionsPayload<ExtArgs>[]
      vehicle_types: Prisma.$vehicle_typesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_type_id: string
      name: string
      label: string
      sort_order: number
    }, ExtArgs["result"]["feature_groups"]>
    composites: {}
  }

  type feature_groupsGetPayload<S extends boolean | null | undefined | feature_groupsDefaultArgs> = $Result.GetResult<Prisma.$feature_groupsPayload, S>

  type feature_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feature_groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Feature_groupsCountAggregateInputType | true
    }

  export interface feature_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feature_groups'], meta: { name: 'feature_groups' } }
    /**
     * Find zero or one Feature_groups that matches the filter.
     * @param {feature_groupsFindUniqueArgs} args - Arguments to find a Feature_groups
     * @example
     * // Get one Feature_groups
     * const feature_groups = await prisma.feature_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feature_groupsFindUniqueArgs>(args: SelectSubset<T, feature_groupsFindUniqueArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feature_groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {feature_groupsFindUniqueOrThrowArgs} args - Arguments to find a Feature_groups
     * @example
     * // Get one Feature_groups
     * const feature_groups = await prisma.feature_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feature_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, feature_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feature_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsFindFirstArgs} args - Arguments to find a Feature_groups
     * @example
     * // Get one Feature_groups
     * const feature_groups = await prisma.feature_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feature_groupsFindFirstArgs>(args?: SelectSubset<T, feature_groupsFindFirstArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feature_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsFindFirstOrThrowArgs} args - Arguments to find a Feature_groups
     * @example
     * // Get one Feature_groups
     * const feature_groups = await prisma.feature_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feature_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, feature_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feature_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feature_groups
     * const feature_groups = await prisma.feature_groups.findMany()
     * 
     * // Get first 10 Feature_groups
     * const feature_groups = await prisma.feature_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feature_groupsWithIdOnly = await prisma.feature_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feature_groupsFindManyArgs>(args?: SelectSubset<T, feature_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feature_groups.
     * @param {feature_groupsCreateArgs} args - Arguments to create a Feature_groups.
     * @example
     * // Create one Feature_groups
     * const Feature_groups = await prisma.feature_groups.create({
     *   data: {
     *     // ... data to create a Feature_groups
     *   }
     * })
     * 
     */
    create<T extends feature_groupsCreateArgs>(args: SelectSubset<T, feature_groupsCreateArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feature_groups.
     * @param {feature_groupsCreateManyArgs} args - Arguments to create many Feature_groups.
     * @example
     * // Create many Feature_groups
     * const feature_groups = await prisma.feature_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feature_groupsCreateManyArgs>(args?: SelectSubset<T, feature_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feature_groups and returns the data saved in the database.
     * @param {feature_groupsCreateManyAndReturnArgs} args - Arguments to create many Feature_groups.
     * @example
     * // Create many Feature_groups
     * const feature_groups = await prisma.feature_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feature_groups and only return the `id`
     * const feature_groupsWithIdOnly = await prisma.feature_groups.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feature_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, feature_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feature_groups.
     * @param {feature_groupsDeleteArgs} args - Arguments to delete one Feature_groups.
     * @example
     * // Delete one Feature_groups
     * const Feature_groups = await prisma.feature_groups.delete({
     *   where: {
     *     // ... filter to delete one Feature_groups
     *   }
     * })
     * 
     */
    delete<T extends feature_groupsDeleteArgs>(args: SelectSubset<T, feature_groupsDeleteArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feature_groups.
     * @param {feature_groupsUpdateArgs} args - Arguments to update one Feature_groups.
     * @example
     * // Update one Feature_groups
     * const feature_groups = await prisma.feature_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feature_groupsUpdateArgs>(args: SelectSubset<T, feature_groupsUpdateArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feature_groups.
     * @param {feature_groupsDeleteManyArgs} args - Arguments to filter Feature_groups to delete.
     * @example
     * // Delete a few Feature_groups
     * const { count } = await prisma.feature_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feature_groupsDeleteManyArgs>(args?: SelectSubset<T, feature_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feature_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feature_groups
     * const feature_groups = await prisma.feature_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feature_groupsUpdateManyArgs>(args: SelectSubset<T, feature_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature_groups.
     * @param {feature_groupsUpsertArgs} args - Arguments to update or create a Feature_groups.
     * @example
     * // Update or create a Feature_groups
     * const feature_groups = await prisma.feature_groups.upsert({
     *   create: {
     *     // ... data to create a Feature_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature_groups we want to update
     *   }
     * })
     */
    upsert<T extends feature_groupsUpsertArgs>(args: SelectSubset<T, feature_groupsUpsertArgs<ExtArgs>>): Prisma__feature_groupsClient<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feature_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsCountArgs} args - Arguments to filter Feature_groups to count.
     * @example
     * // Count the number of Feature_groups
     * const count = await prisma.feature_groups.count({
     *   where: {
     *     // ... the filter for the Feature_groups we want to count
     *   }
     * })
    **/
    count<T extends feature_groupsCountArgs>(
      args?: Subset<T, feature_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Feature_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Feature_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Feature_groupsAggregateArgs>(args: Subset<T, Feature_groupsAggregateArgs>): Prisma.PrismaPromise<GetFeature_groupsAggregateType<T>>

    /**
     * Group by Feature_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feature_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feature_groupsGroupByArgs['orderBy'] }
        : { orderBy?: feature_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feature_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeature_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feature_groups model
   */
  readonly fields: feature_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feature_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feature_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature_definitions<T extends feature_groups$feature_definitionsArgs<ExtArgs> = {}>(args?: Subset<T, feature_groups$feature_definitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_definitionsPayload<ExtArgs>, T, "findMany"> | Null>
    vehicle_types<T extends vehicle_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_typesDefaultArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feature_groups model
   */ 
  interface feature_groupsFieldRefs {
    readonly id: FieldRef<"feature_groups", 'String'>
    readonly vehicle_type_id: FieldRef<"feature_groups", 'String'>
    readonly name: FieldRef<"feature_groups", 'String'>
    readonly label: FieldRef<"feature_groups", 'String'>
    readonly sort_order: FieldRef<"feature_groups", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * feature_groups findUnique
   */
  export type feature_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter, which feature_groups to fetch.
     */
    where: feature_groupsWhereUniqueInput
  }

  /**
   * feature_groups findUniqueOrThrow
   */
  export type feature_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter, which feature_groups to fetch.
     */
    where: feature_groupsWhereUniqueInput
  }

  /**
   * feature_groups findFirst
   */
  export type feature_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter, which feature_groups to fetch.
     */
    where?: feature_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_groups to fetch.
     */
    orderBy?: feature_groupsOrderByWithRelationInput | feature_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_groups.
     */
    cursor?: feature_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_groups.
     */
    distinct?: Feature_groupsScalarFieldEnum | Feature_groupsScalarFieldEnum[]
  }

  /**
   * feature_groups findFirstOrThrow
   */
  export type feature_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter, which feature_groups to fetch.
     */
    where?: feature_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_groups to fetch.
     */
    orderBy?: feature_groupsOrderByWithRelationInput | feature_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_groups.
     */
    cursor?: feature_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_groups.
     */
    distinct?: Feature_groupsScalarFieldEnum | Feature_groupsScalarFieldEnum[]
  }

  /**
   * feature_groups findMany
   */
  export type feature_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter, which feature_groups to fetch.
     */
    where?: feature_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_groups to fetch.
     */
    orderBy?: feature_groupsOrderByWithRelationInput | feature_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feature_groups.
     */
    cursor?: feature_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_groups.
     */
    skip?: number
    distinct?: Feature_groupsScalarFieldEnum | Feature_groupsScalarFieldEnum[]
  }

  /**
   * feature_groups create
   */
  export type feature_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a feature_groups.
     */
    data: XOR<feature_groupsCreateInput, feature_groupsUncheckedCreateInput>
  }

  /**
   * feature_groups createMany
   */
  export type feature_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feature_groups.
     */
    data: feature_groupsCreateManyInput | feature_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feature_groups createManyAndReturn
   */
  export type feature_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many feature_groups.
     */
    data: feature_groupsCreateManyInput | feature_groupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * feature_groups update
   */
  export type feature_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a feature_groups.
     */
    data: XOR<feature_groupsUpdateInput, feature_groupsUncheckedUpdateInput>
    /**
     * Choose, which feature_groups to update.
     */
    where: feature_groupsWhereUniqueInput
  }

  /**
   * feature_groups updateMany
   */
  export type feature_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feature_groups.
     */
    data: XOR<feature_groupsUpdateManyMutationInput, feature_groupsUncheckedUpdateManyInput>
    /**
     * Filter which feature_groups to update
     */
    where?: feature_groupsWhereInput
  }

  /**
   * feature_groups upsert
   */
  export type feature_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the feature_groups to update in case it exists.
     */
    where: feature_groupsWhereUniqueInput
    /**
     * In case the feature_groups found by the `where` argument doesn't exist, create a new feature_groups with this data.
     */
    create: XOR<feature_groupsCreateInput, feature_groupsUncheckedCreateInput>
    /**
     * In case the feature_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feature_groupsUpdateInput, feature_groupsUncheckedUpdateInput>
  }

  /**
   * feature_groups delete
   */
  export type feature_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    /**
     * Filter which feature_groups to delete.
     */
    where: feature_groupsWhereUniqueInput
  }

  /**
   * feature_groups deleteMany
   */
  export type feature_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_groups to delete
     */
    where?: feature_groupsWhereInput
  }

  /**
   * feature_groups.feature_definitions
   */
  export type feature_groups$feature_definitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_definitions
     */
    select?: feature_definitionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_definitionsInclude<ExtArgs> | null
    where?: feature_definitionsWhereInput
    orderBy?: feature_definitionsOrderByWithRelationInput | feature_definitionsOrderByWithRelationInput[]
    cursor?: feature_definitionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Feature_definitionsScalarFieldEnum | Feature_definitionsScalarFieldEnum[]
  }

  /**
   * feature_groups without action
   */
  export type feature_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
  }


  /**
   * Model listing_images
   */

  export type AggregateListing_images = {
    _count: Listing_imagesCountAggregateOutputType | null
    _avg: Listing_imagesAvgAggregateOutputType | null
    _sum: Listing_imagesSumAggregateOutputType | null
    _min: Listing_imagesMinAggregateOutputType | null
    _max: Listing_imagesMaxAggregateOutputType | null
  }

  export type Listing_imagesAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type Listing_imagesSumAggregateOutputType = {
    sort_order: number | null
  }

  export type Listing_imagesMinAggregateOutputType = {
    id: string | null
    listing_id: string | null
    url: string | null
    alt: string | null
    sort_order: number | null
  }

  export type Listing_imagesMaxAggregateOutputType = {
    id: string | null
    listing_id: string | null
    url: string | null
    alt: string | null
    sort_order: number | null
  }

  export type Listing_imagesCountAggregateOutputType = {
    id: number
    listing_id: number
    url: number
    alt: number
    sort_order: number
    _all: number
  }


  export type Listing_imagesAvgAggregateInputType = {
    sort_order?: true
  }

  export type Listing_imagesSumAggregateInputType = {
    sort_order?: true
  }

  export type Listing_imagesMinAggregateInputType = {
    id?: true
    listing_id?: true
    url?: true
    alt?: true
    sort_order?: true
  }

  export type Listing_imagesMaxAggregateInputType = {
    id?: true
    listing_id?: true
    url?: true
    alt?: true
    sort_order?: true
  }

  export type Listing_imagesCountAggregateInputType = {
    id?: true
    listing_id?: true
    url?: true
    alt?: true
    sort_order?: true
    _all?: true
  }

  export type Listing_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listing_images to aggregate.
     */
    where?: listing_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_images to fetch.
     */
    orderBy?: listing_imagesOrderByWithRelationInput | listing_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: listing_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned listing_images
    **/
    _count?: true | Listing_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Listing_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Listing_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Listing_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Listing_imagesMaxAggregateInputType
  }

  export type GetListing_imagesAggregateType<T extends Listing_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateListing_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing_images[P]>
      : GetScalarType<T[P], AggregateListing_images[P]>
  }




  export type listing_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listing_imagesWhereInput
    orderBy?: listing_imagesOrderByWithAggregationInput | listing_imagesOrderByWithAggregationInput[]
    by: Listing_imagesScalarFieldEnum[] | Listing_imagesScalarFieldEnum
    having?: listing_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Listing_imagesCountAggregateInputType | true
    _avg?: Listing_imagesAvgAggregateInputType
    _sum?: Listing_imagesSumAggregateInputType
    _min?: Listing_imagesMinAggregateInputType
    _max?: Listing_imagesMaxAggregateInputType
  }

  export type Listing_imagesGroupByOutputType = {
    id: string
    listing_id: string
    url: string
    alt: string | null
    sort_order: number
    _count: Listing_imagesCountAggregateOutputType | null
    _avg: Listing_imagesAvgAggregateOutputType | null
    _sum: Listing_imagesSumAggregateOutputType | null
    _min: Listing_imagesMinAggregateOutputType | null
    _max: Listing_imagesMaxAggregateOutputType | null
  }

  type GetListing_imagesGroupByPayload<T extends listing_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Listing_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Listing_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Listing_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Listing_imagesGroupByOutputType[P]>
        }
      >
    >


  export type listing_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listing_id?: boolean
    url?: boolean
    alt?: boolean
    sort_order?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing_images"]>

  export type listing_imagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listing_id?: boolean
    url?: boolean
    alt?: boolean
    sort_order?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing_images"]>

  export type listing_imagesSelectScalar = {
    id?: boolean
    listing_id?: boolean
    url?: boolean
    alt?: boolean
    sort_order?: boolean
  }

  export type listing_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type listing_imagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }

  export type $listing_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "listing_images"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listing_id: string
      url: string
      alt: string | null
      sort_order: number
    }, ExtArgs["result"]["listing_images"]>
    composites: {}
  }

  type listing_imagesGetPayload<S extends boolean | null | undefined | listing_imagesDefaultArgs> = $Result.GetResult<Prisma.$listing_imagesPayload, S>

  type listing_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<listing_imagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Listing_imagesCountAggregateInputType | true
    }

  export interface listing_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['listing_images'], meta: { name: 'listing_images' } }
    /**
     * Find zero or one Listing_images that matches the filter.
     * @param {listing_imagesFindUniqueArgs} args - Arguments to find a Listing_images
     * @example
     * // Get one Listing_images
     * const listing_images = await prisma.listing_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends listing_imagesFindUniqueArgs>(args: SelectSubset<T, listing_imagesFindUniqueArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Listing_images that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {listing_imagesFindUniqueOrThrowArgs} args - Arguments to find a Listing_images
     * @example
     * // Get one Listing_images
     * const listing_images = await prisma.listing_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends listing_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, listing_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Listing_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesFindFirstArgs} args - Arguments to find a Listing_images
     * @example
     * // Get one Listing_images
     * const listing_images = await prisma.listing_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends listing_imagesFindFirstArgs>(args?: SelectSubset<T, listing_imagesFindFirstArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Listing_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesFindFirstOrThrowArgs} args - Arguments to find a Listing_images
     * @example
     * // Get one Listing_images
     * const listing_images = await prisma.listing_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends listing_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, listing_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Listing_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listing_images
     * const listing_images = await prisma.listing_images.findMany()
     * 
     * // Get first 10 Listing_images
     * const listing_images = await prisma.listing_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listing_imagesWithIdOnly = await prisma.listing_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends listing_imagesFindManyArgs>(args?: SelectSubset<T, listing_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Listing_images.
     * @param {listing_imagesCreateArgs} args - Arguments to create a Listing_images.
     * @example
     * // Create one Listing_images
     * const Listing_images = await prisma.listing_images.create({
     *   data: {
     *     // ... data to create a Listing_images
     *   }
     * })
     * 
     */
    create<T extends listing_imagesCreateArgs>(args: SelectSubset<T, listing_imagesCreateArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Listing_images.
     * @param {listing_imagesCreateManyArgs} args - Arguments to create many Listing_images.
     * @example
     * // Create many Listing_images
     * const listing_images = await prisma.listing_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends listing_imagesCreateManyArgs>(args?: SelectSubset<T, listing_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listing_images and returns the data saved in the database.
     * @param {listing_imagesCreateManyAndReturnArgs} args - Arguments to create many Listing_images.
     * @example
     * // Create many Listing_images
     * const listing_images = await prisma.listing_images.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listing_images and only return the `id`
     * const listing_imagesWithIdOnly = await prisma.listing_images.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends listing_imagesCreateManyAndReturnArgs>(args?: SelectSubset<T, listing_imagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Listing_images.
     * @param {listing_imagesDeleteArgs} args - Arguments to delete one Listing_images.
     * @example
     * // Delete one Listing_images
     * const Listing_images = await prisma.listing_images.delete({
     *   where: {
     *     // ... filter to delete one Listing_images
     *   }
     * })
     * 
     */
    delete<T extends listing_imagesDeleteArgs>(args: SelectSubset<T, listing_imagesDeleteArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Listing_images.
     * @param {listing_imagesUpdateArgs} args - Arguments to update one Listing_images.
     * @example
     * // Update one Listing_images
     * const listing_images = await prisma.listing_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends listing_imagesUpdateArgs>(args: SelectSubset<T, listing_imagesUpdateArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Listing_images.
     * @param {listing_imagesDeleteManyArgs} args - Arguments to filter Listing_images to delete.
     * @example
     * // Delete a few Listing_images
     * const { count } = await prisma.listing_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends listing_imagesDeleteManyArgs>(args?: SelectSubset<T, listing_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listing_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listing_images
     * const listing_images = await prisma.listing_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends listing_imagesUpdateManyArgs>(args: SelectSubset<T, listing_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listing_images.
     * @param {listing_imagesUpsertArgs} args - Arguments to update or create a Listing_images.
     * @example
     * // Update or create a Listing_images
     * const listing_images = await prisma.listing_images.upsert({
     *   create: {
     *     // ... data to create a Listing_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing_images we want to update
     *   }
     * })
     */
    upsert<T extends listing_imagesUpsertArgs>(args: SelectSubset<T, listing_imagesUpsertArgs<ExtArgs>>): Prisma__listing_imagesClient<$Result.GetResult<Prisma.$listing_imagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Listing_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesCountArgs} args - Arguments to filter Listing_images to count.
     * @example
     * // Count the number of Listing_images
     * const count = await prisma.listing_images.count({
     *   where: {
     *     // ... the filter for the Listing_images we want to count
     *   }
     * })
    **/
    count<T extends listing_imagesCountArgs>(
      args?: Subset<T, listing_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Listing_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Listing_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Listing_imagesAggregateArgs>(args: Subset<T, Listing_imagesAggregateArgs>): Prisma.PrismaPromise<GetListing_imagesAggregateType<T>>

    /**
     * Group by Listing_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends listing_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listing_imagesGroupByArgs['orderBy'] }
        : { orderBy?: listing_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, listing_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListing_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the listing_images model
   */
  readonly fields: listing_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for listing_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listing_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the listing_images model
   */ 
  interface listing_imagesFieldRefs {
    readonly id: FieldRef<"listing_images", 'String'>
    readonly listing_id: FieldRef<"listing_images", 'String'>
    readonly url: FieldRef<"listing_images", 'String'>
    readonly alt: FieldRef<"listing_images", 'String'>
    readonly sort_order: FieldRef<"listing_images", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * listing_images findUnique
   */
  export type listing_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter, which listing_images to fetch.
     */
    where: listing_imagesWhereUniqueInput
  }

  /**
   * listing_images findUniqueOrThrow
   */
  export type listing_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter, which listing_images to fetch.
     */
    where: listing_imagesWhereUniqueInput
  }

  /**
   * listing_images findFirst
   */
  export type listing_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter, which listing_images to fetch.
     */
    where?: listing_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_images to fetch.
     */
    orderBy?: listing_imagesOrderByWithRelationInput | listing_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listing_images.
     */
    cursor?: listing_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listing_images.
     */
    distinct?: Listing_imagesScalarFieldEnum | Listing_imagesScalarFieldEnum[]
  }

  /**
   * listing_images findFirstOrThrow
   */
  export type listing_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter, which listing_images to fetch.
     */
    where?: listing_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_images to fetch.
     */
    orderBy?: listing_imagesOrderByWithRelationInput | listing_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listing_images.
     */
    cursor?: listing_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listing_images.
     */
    distinct?: Listing_imagesScalarFieldEnum | Listing_imagesScalarFieldEnum[]
  }

  /**
   * listing_images findMany
   */
  export type listing_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter, which listing_images to fetch.
     */
    where?: listing_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_images to fetch.
     */
    orderBy?: listing_imagesOrderByWithRelationInput | listing_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing listing_images.
     */
    cursor?: listing_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_images.
     */
    skip?: number
    distinct?: Listing_imagesScalarFieldEnum | Listing_imagesScalarFieldEnum[]
  }

  /**
   * listing_images create
   */
  export type listing_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a listing_images.
     */
    data: XOR<listing_imagesCreateInput, listing_imagesUncheckedCreateInput>
  }

  /**
   * listing_images createMany
   */
  export type listing_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many listing_images.
     */
    data: listing_imagesCreateManyInput | listing_imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * listing_images createManyAndReturn
   */
  export type listing_imagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many listing_images.
     */
    data: listing_imagesCreateManyInput | listing_imagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * listing_images update
   */
  export type listing_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a listing_images.
     */
    data: XOR<listing_imagesUpdateInput, listing_imagesUncheckedUpdateInput>
    /**
     * Choose, which listing_images to update.
     */
    where: listing_imagesWhereUniqueInput
  }

  /**
   * listing_images updateMany
   */
  export type listing_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update listing_images.
     */
    data: XOR<listing_imagesUpdateManyMutationInput, listing_imagesUncheckedUpdateManyInput>
    /**
     * Filter which listing_images to update
     */
    where?: listing_imagesWhereInput
  }

  /**
   * listing_images upsert
   */
  export type listing_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the listing_images to update in case it exists.
     */
    where: listing_imagesWhereUniqueInput
    /**
     * In case the listing_images found by the `where` argument doesn't exist, create a new listing_images with this data.
     */
    create: XOR<listing_imagesCreateInput, listing_imagesUncheckedCreateInput>
    /**
     * In case the listing_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listing_imagesUpdateInput, listing_imagesUncheckedUpdateInput>
  }

  /**
   * listing_images delete
   */
  export type listing_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
    /**
     * Filter which listing_images to delete.
     */
    where: listing_imagesWhereUniqueInput
  }

  /**
   * listing_images deleteMany
   */
  export type listing_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listing_images to delete
     */
    where?: listing_imagesWhereInput
  }

  /**
   * listing_images without action
   */
  export type listing_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_images
     */
    select?: listing_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_imagesInclude<ExtArgs> | null
  }


  /**
   * Model listing_properties
   */

  export type AggregateListing_properties = {
    _count: Listing_propertiesCountAggregateOutputType | null
    _min: Listing_propertiesMinAggregateOutputType | null
    _max: Listing_propertiesMaxAggregateOutputType | null
  }

  export type Listing_propertiesMinAggregateOutputType = {
    id: string | null
    listing_id: string | null
    key: string | null
    value: string | null
    type: $Enums.PropertyType | null
  }

  export type Listing_propertiesMaxAggregateOutputType = {
    id: string | null
    listing_id: string | null
    key: string | null
    value: string | null
    type: $Enums.PropertyType | null
  }

  export type Listing_propertiesCountAggregateOutputType = {
    id: number
    listing_id: number
    key: number
    value: number
    type: number
    _all: number
  }


  export type Listing_propertiesMinAggregateInputType = {
    id?: true
    listing_id?: true
    key?: true
    value?: true
    type?: true
  }

  export type Listing_propertiesMaxAggregateInputType = {
    id?: true
    listing_id?: true
    key?: true
    value?: true
    type?: true
  }

  export type Listing_propertiesCountAggregateInputType = {
    id?: true
    listing_id?: true
    key?: true
    value?: true
    type?: true
    _all?: true
  }

  export type Listing_propertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listing_properties to aggregate.
     */
    where?: listing_propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_properties to fetch.
     */
    orderBy?: listing_propertiesOrderByWithRelationInput | listing_propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: listing_propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned listing_properties
    **/
    _count?: true | Listing_propertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Listing_propertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Listing_propertiesMaxAggregateInputType
  }

  export type GetListing_propertiesAggregateType<T extends Listing_propertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateListing_properties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing_properties[P]>
      : GetScalarType<T[P], AggregateListing_properties[P]>
  }




  export type listing_propertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listing_propertiesWhereInput
    orderBy?: listing_propertiesOrderByWithAggregationInput | listing_propertiesOrderByWithAggregationInput[]
    by: Listing_propertiesScalarFieldEnum[] | Listing_propertiesScalarFieldEnum
    having?: listing_propertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Listing_propertiesCountAggregateInputType | true
    _min?: Listing_propertiesMinAggregateInputType
    _max?: Listing_propertiesMaxAggregateInputType
  }

  export type Listing_propertiesGroupByOutputType = {
    id: string
    listing_id: string
    key: string
    value: string
    type: $Enums.PropertyType
    _count: Listing_propertiesCountAggregateOutputType | null
    _min: Listing_propertiesMinAggregateOutputType | null
    _max: Listing_propertiesMaxAggregateOutputType | null
  }

  type GetListing_propertiesGroupByPayload<T extends listing_propertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Listing_propertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Listing_propertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Listing_propertiesGroupByOutputType[P]>
            : GetScalarType<T[P], Listing_propertiesGroupByOutputType[P]>
        }
      >
    >


  export type listing_propertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listing_id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing_properties"]>

  export type listing_propertiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listing_id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing_properties"]>

  export type listing_propertiesSelectScalar = {
    id?: boolean
    listing_id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
  }

  export type listing_propertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type listing_propertiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | ListingDefaultArgs<ExtArgs>
  }

  export type $listing_propertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "listing_properties"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listing_id: string
      key: string
      value: string
      type: $Enums.PropertyType
    }, ExtArgs["result"]["listing_properties"]>
    composites: {}
  }

  type listing_propertiesGetPayload<S extends boolean | null | undefined | listing_propertiesDefaultArgs> = $Result.GetResult<Prisma.$listing_propertiesPayload, S>

  type listing_propertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<listing_propertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Listing_propertiesCountAggregateInputType | true
    }

  export interface listing_propertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['listing_properties'], meta: { name: 'listing_properties' } }
    /**
     * Find zero or one Listing_properties that matches the filter.
     * @param {listing_propertiesFindUniqueArgs} args - Arguments to find a Listing_properties
     * @example
     * // Get one Listing_properties
     * const listing_properties = await prisma.listing_properties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends listing_propertiesFindUniqueArgs>(args: SelectSubset<T, listing_propertiesFindUniqueArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Listing_properties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {listing_propertiesFindUniqueOrThrowArgs} args - Arguments to find a Listing_properties
     * @example
     * // Get one Listing_properties
     * const listing_properties = await prisma.listing_properties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends listing_propertiesFindUniqueOrThrowArgs>(args: SelectSubset<T, listing_propertiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Listing_properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesFindFirstArgs} args - Arguments to find a Listing_properties
     * @example
     * // Get one Listing_properties
     * const listing_properties = await prisma.listing_properties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends listing_propertiesFindFirstArgs>(args?: SelectSubset<T, listing_propertiesFindFirstArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Listing_properties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesFindFirstOrThrowArgs} args - Arguments to find a Listing_properties
     * @example
     * // Get one Listing_properties
     * const listing_properties = await prisma.listing_properties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends listing_propertiesFindFirstOrThrowArgs>(args?: SelectSubset<T, listing_propertiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Listing_properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listing_properties
     * const listing_properties = await prisma.listing_properties.findMany()
     * 
     * // Get first 10 Listing_properties
     * const listing_properties = await prisma.listing_properties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listing_propertiesWithIdOnly = await prisma.listing_properties.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends listing_propertiesFindManyArgs>(args?: SelectSubset<T, listing_propertiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Listing_properties.
     * @param {listing_propertiesCreateArgs} args - Arguments to create a Listing_properties.
     * @example
     * // Create one Listing_properties
     * const Listing_properties = await prisma.listing_properties.create({
     *   data: {
     *     // ... data to create a Listing_properties
     *   }
     * })
     * 
     */
    create<T extends listing_propertiesCreateArgs>(args: SelectSubset<T, listing_propertiesCreateArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Listing_properties.
     * @param {listing_propertiesCreateManyArgs} args - Arguments to create many Listing_properties.
     * @example
     * // Create many Listing_properties
     * const listing_properties = await prisma.listing_properties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends listing_propertiesCreateManyArgs>(args?: SelectSubset<T, listing_propertiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listing_properties and returns the data saved in the database.
     * @param {listing_propertiesCreateManyAndReturnArgs} args - Arguments to create many Listing_properties.
     * @example
     * // Create many Listing_properties
     * const listing_properties = await prisma.listing_properties.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listing_properties and only return the `id`
     * const listing_propertiesWithIdOnly = await prisma.listing_properties.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends listing_propertiesCreateManyAndReturnArgs>(args?: SelectSubset<T, listing_propertiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Listing_properties.
     * @param {listing_propertiesDeleteArgs} args - Arguments to delete one Listing_properties.
     * @example
     * // Delete one Listing_properties
     * const Listing_properties = await prisma.listing_properties.delete({
     *   where: {
     *     // ... filter to delete one Listing_properties
     *   }
     * })
     * 
     */
    delete<T extends listing_propertiesDeleteArgs>(args: SelectSubset<T, listing_propertiesDeleteArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Listing_properties.
     * @param {listing_propertiesUpdateArgs} args - Arguments to update one Listing_properties.
     * @example
     * // Update one Listing_properties
     * const listing_properties = await prisma.listing_properties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends listing_propertiesUpdateArgs>(args: SelectSubset<T, listing_propertiesUpdateArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Listing_properties.
     * @param {listing_propertiesDeleteManyArgs} args - Arguments to filter Listing_properties to delete.
     * @example
     * // Delete a few Listing_properties
     * const { count } = await prisma.listing_properties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends listing_propertiesDeleteManyArgs>(args?: SelectSubset<T, listing_propertiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listing_properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listing_properties
     * const listing_properties = await prisma.listing_properties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends listing_propertiesUpdateManyArgs>(args: SelectSubset<T, listing_propertiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listing_properties.
     * @param {listing_propertiesUpsertArgs} args - Arguments to update or create a Listing_properties.
     * @example
     * // Update or create a Listing_properties
     * const listing_properties = await prisma.listing_properties.upsert({
     *   create: {
     *     // ... data to create a Listing_properties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing_properties we want to update
     *   }
     * })
     */
    upsert<T extends listing_propertiesUpsertArgs>(args: SelectSubset<T, listing_propertiesUpsertArgs<ExtArgs>>): Prisma__listing_propertiesClient<$Result.GetResult<Prisma.$listing_propertiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Listing_properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesCountArgs} args - Arguments to filter Listing_properties to count.
     * @example
     * // Count the number of Listing_properties
     * const count = await prisma.listing_properties.count({
     *   where: {
     *     // ... the filter for the Listing_properties we want to count
     *   }
     * })
    **/
    count<T extends listing_propertiesCountArgs>(
      args?: Subset<T, listing_propertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Listing_propertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing_properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Listing_propertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Listing_propertiesAggregateArgs>(args: Subset<T, Listing_propertiesAggregateArgs>): Prisma.PrismaPromise<GetListing_propertiesAggregateType<T>>

    /**
     * Group by Listing_properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listing_propertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends listing_propertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listing_propertiesGroupByArgs['orderBy'] }
        : { orderBy?: listing_propertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, listing_propertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListing_propertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the listing_properties model
   */
  readonly fields: listing_propertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for listing_properties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listing_propertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the listing_properties model
   */ 
  interface listing_propertiesFieldRefs {
    readonly id: FieldRef<"listing_properties", 'String'>
    readonly listing_id: FieldRef<"listing_properties", 'String'>
    readonly key: FieldRef<"listing_properties", 'String'>
    readonly value: FieldRef<"listing_properties", 'String'>
    readonly type: FieldRef<"listing_properties", 'PropertyType'>
  }
    

  // Custom InputTypes
  /**
   * listing_properties findUnique
   */
  export type listing_propertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter, which listing_properties to fetch.
     */
    where: listing_propertiesWhereUniqueInput
  }

  /**
   * listing_properties findUniqueOrThrow
   */
  export type listing_propertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter, which listing_properties to fetch.
     */
    where: listing_propertiesWhereUniqueInput
  }

  /**
   * listing_properties findFirst
   */
  export type listing_propertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter, which listing_properties to fetch.
     */
    where?: listing_propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_properties to fetch.
     */
    orderBy?: listing_propertiesOrderByWithRelationInput | listing_propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listing_properties.
     */
    cursor?: listing_propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listing_properties.
     */
    distinct?: Listing_propertiesScalarFieldEnum | Listing_propertiesScalarFieldEnum[]
  }

  /**
   * listing_properties findFirstOrThrow
   */
  export type listing_propertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter, which listing_properties to fetch.
     */
    where?: listing_propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_properties to fetch.
     */
    orderBy?: listing_propertiesOrderByWithRelationInput | listing_propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listing_properties.
     */
    cursor?: listing_propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listing_properties.
     */
    distinct?: Listing_propertiesScalarFieldEnum | Listing_propertiesScalarFieldEnum[]
  }

  /**
   * listing_properties findMany
   */
  export type listing_propertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter, which listing_properties to fetch.
     */
    where?: listing_propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listing_properties to fetch.
     */
    orderBy?: listing_propertiesOrderByWithRelationInput | listing_propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing listing_properties.
     */
    cursor?: listing_propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listing_properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listing_properties.
     */
    skip?: number
    distinct?: Listing_propertiesScalarFieldEnum | Listing_propertiesScalarFieldEnum[]
  }

  /**
   * listing_properties create
   */
  export type listing_propertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a listing_properties.
     */
    data: XOR<listing_propertiesCreateInput, listing_propertiesUncheckedCreateInput>
  }

  /**
   * listing_properties createMany
   */
  export type listing_propertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many listing_properties.
     */
    data: listing_propertiesCreateManyInput | listing_propertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * listing_properties createManyAndReturn
   */
  export type listing_propertiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many listing_properties.
     */
    data: listing_propertiesCreateManyInput | listing_propertiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * listing_properties update
   */
  export type listing_propertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a listing_properties.
     */
    data: XOR<listing_propertiesUpdateInput, listing_propertiesUncheckedUpdateInput>
    /**
     * Choose, which listing_properties to update.
     */
    where: listing_propertiesWhereUniqueInput
  }

  /**
   * listing_properties updateMany
   */
  export type listing_propertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update listing_properties.
     */
    data: XOR<listing_propertiesUpdateManyMutationInput, listing_propertiesUncheckedUpdateManyInput>
    /**
     * Filter which listing_properties to update
     */
    where?: listing_propertiesWhereInput
  }

  /**
   * listing_properties upsert
   */
  export type listing_propertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the listing_properties to update in case it exists.
     */
    where: listing_propertiesWhereUniqueInput
    /**
     * In case the listing_properties found by the `where` argument doesn't exist, create a new listing_properties with this data.
     */
    create: XOR<listing_propertiesCreateInput, listing_propertiesUncheckedCreateInput>
    /**
     * In case the listing_properties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listing_propertiesUpdateInput, listing_propertiesUncheckedUpdateInput>
  }

  /**
   * listing_properties delete
   */
  export type listing_propertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
    /**
     * Filter which listing_properties to delete.
     */
    where: listing_propertiesWhereUniqueInput
  }

  /**
   * listing_properties deleteMany
   */
  export type listing_propertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listing_properties to delete
     */
    where?: listing_propertiesWhereInput
  }

  /**
   * listing_properties without action
   */
  export type listing_propertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listing_properties
     */
    select?: listing_propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listing_propertiesInclude<ExtArgs> | null
  }


  /**
   * Model models
   */

  export type AggregateModels = {
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  export type ModelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ModelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ModelsCountAggregateOutputType = {
    id: number
    name: number
    brand_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ModelsMinAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ModelsMaxAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ModelsCountAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ModelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which models to aggregate.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned models
    **/
    _count?: true | ModelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelsMaxAggregateInputType
  }

  export type GetModelsAggregateType<T extends ModelsAggregateArgs> = {
        [P in keyof T & keyof AggregateModels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModels[P]>
      : GetScalarType<T[P], AggregateModels[P]>
  }




  export type modelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelsWhereInput
    orderBy?: modelsOrderByWithAggregationInput | modelsOrderByWithAggregationInput[]
    by: ModelsScalarFieldEnum[] | ModelsScalarFieldEnum
    having?: modelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelsCountAggregateInputType | true
    _min?: ModelsMinAggregateInputType
    _max?: ModelsMaxAggregateInputType
  }

  export type ModelsGroupByOutputType = {
    id: string
    name: string
    brand_id: string
    created_at: Date
    updated_at: Date
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  type GetModelsGroupByPayload<T extends modelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelsGroupByOutputType[P]>
            : GetScalarType<T[P], ModelsGroupByOutputType[P]>
        }
      >
    >


  export type modelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | models$listingsArgs<ExtArgs>
    brands?: boolean | brandsDefaultArgs<ExtArgs>
    variants?: boolean | models$variantsArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["models"]>

  export type modelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    brands?: boolean | brandsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["models"]>

  export type modelsSelectScalar = {
    id?: boolean
    name?: boolean
    brand_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type modelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | models$listingsArgs<ExtArgs>
    brands?: boolean | brandsDefaultArgs<ExtArgs>
    variants?: boolean | models$variantsArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type modelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | brandsDefaultArgs<ExtArgs>
  }

  export type $modelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "models"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
      brands: Prisma.$brandsPayload<ExtArgs>
      variants: Prisma.$variantsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["models"]>
    composites: {}
  }

  type modelsGetPayload<S extends boolean | null | undefined | modelsDefaultArgs> = $Result.GetResult<Prisma.$modelsPayload, S>

  type modelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<modelsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelsCountAggregateInputType | true
    }

  export interface modelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['models'], meta: { name: 'models' } }
    /**
     * Find zero or one Models that matches the filter.
     * @param {modelsFindUniqueArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modelsFindUniqueArgs>(args: SelectSubset<T, modelsFindUniqueArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Models that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {modelsFindUniqueOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modelsFindUniqueOrThrowArgs>(args: SelectSubset<T, modelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindFirstArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modelsFindFirstArgs>(args?: SelectSubset<T, modelsFindFirstArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Models that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindFirstOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modelsFindFirstOrThrowArgs>(args?: SelectSubset<T, modelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.models.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.models.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelsWithIdOnly = await prisma.models.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modelsFindManyArgs>(args?: SelectSubset<T, modelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Models.
     * @param {modelsCreateArgs} args - Arguments to create a Models.
     * @example
     * // Create one Models
     * const Models = await prisma.models.create({
     *   data: {
     *     // ... data to create a Models
     *   }
     * })
     * 
     */
    create<T extends modelsCreateArgs>(args: SelectSubset<T, modelsCreateArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Models.
     * @param {modelsCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const models = await prisma.models.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modelsCreateManyArgs>(args?: SelectSubset<T, modelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {modelsCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const models = await prisma.models.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelsWithIdOnly = await prisma.models.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends modelsCreateManyAndReturnArgs>(args?: SelectSubset<T, modelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Models.
     * @param {modelsDeleteArgs} args - Arguments to delete one Models.
     * @example
     * // Delete one Models
     * const Models = await prisma.models.delete({
     *   where: {
     *     // ... filter to delete one Models
     *   }
     * })
     * 
     */
    delete<T extends modelsDeleteArgs>(args: SelectSubset<T, modelsDeleteArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Models.
     * @param {modelsUpdateArgs} args - Arguments to update one Models.
     * @example
     * // Update one Models
     * const models = await prisma.models.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modelsUpdateArgs>(args: SelectSubset<T, modelsUpdateArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Models.
     * @param {modelsDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.models.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modelsDeleteManyArgs>(args?: SelectSubset<T, modelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const models = await prisma.models.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modelsUpdateManyArgs>(args: SelectSubset<T, modelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Models.
     * @param {modelsUpsertArgs} args - Arguments to update or create a Models.
     * @example
     * // Update or create a Models
     * const models = await prisma.models.upsert({
     *   create: {
     *     // ... data to create a Models
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Models we want to update
     *   }
     * })
     */
    upsert<T extends modelsUpsertArgs>(args: SelectSubset<T, modelsUpsertArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.models.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends modelsCountArgs>(
      args?: Subset<T, modelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelsAggregateArgs>(args: Subset<T, ModelsAggregateArgs>): Prisma.PrismaPromise<GetModelsAggregateType<T>>

    /**
     * Group by Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modelsGroupByArgs['orderBy'] }
        : { orderBy?: modelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the models model
   */
  readonly fields: modelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for models.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends models$listingsArgs<ExtArgs> = {}>(args?: Subset<T, models$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    brands<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    variants<T extends models$variantsArgs<ExtArgs> = {}>(args?: Subset<T, models$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the models model
   */ 
  interface modelsFieldRefs {
    readonly id: FieldRef<"models", 'String'>
    readonly name: FieldRef<"models", 'String'>
    readonly brand_id: FieldRef<"models", 'String'>
    readonly created_at: FieldRef<"models", 'DateTime'>
    readonly updated_at: FieldRef<"models", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * models findUnique
   */
  export type modelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models findUniqueOrThrow
   */
  export type modelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models findFirst
   */
  export type modelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models findFirstOrThrow
   */
  export type modelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models findMany
   */
  export type modelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models create
   */
  export type modelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The data needed to create a models.
     */
    data: XOR<modelsCreateInput, modelsUncheckedCreateInput>
  }

  /**
   * models createMany
   */
  export type modelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many models.
     */
    data: modelsCreateManyInput | modelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * models createManyAndReturn
   */
  export type modelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many models.
     */
    data: modelsCreateManyInput | modelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * models update
   */
  export type modelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The data needed to update a models.
     */
    data: XOR<modelsUpdateInput, modelsUncheckedUpdateInput>
    /**
     * Choose, which models to update.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models updateMany
   */
  export type modelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update models.
     */
    data: XOR<modelsUpdateManyMutationInput, modelsUncheckedUpdateManyInput>
    /**
     * Filter which models to update
     */
    where?: modelsWhereInput
  }

  /**
   * models upsert
   */
  export type modelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The filter to search for the models to update in case it exists.
     */
    where: modelsWhereUniqueInput
    /**
     * In case the models found by the `where` argument doesn't exist, create a new models with this data.
     */
    create: XOR<modelsCreateInput, modelsUncheckedCreateInput>
    /**
     * In case the models was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modelsUpdateInput, modelsUncheckedUpdateInput>
  }

  /**
   * models delete
   */
  export type modelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter which models to delete.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models deleteMany
   */
  export type modelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which models to delete
     */
    where?: modelsWhereInput
  }

  /**
   * models.listings
   */
  export type models$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * models.variants
   */
  export type models$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    where?: variantsWhereInput
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    cursor?: variantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * models without action
   */
  export type modelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
  }


  /**
   * Model variants
   */

  export type AggregateVariants = {
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  export type VariantsMinAggregateOutputType = {
    id: string | null
    name: string | null
    model_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VariantsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    model_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VariantsCountAggregateOutputType = {
    id: number
    name: number
    model_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VariantsMinAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VariantsMaxAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VariantsCountAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VariantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variants to aggregate.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned variants
    **/
    _count?: true | VariantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantsMaxAggregateInputType
  }

  export type GetVariantsAggregateType<T extends VariantsAggregateArgs> = {
        [P in keyof T & keyof AggregateVariants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariants[P]>
      : GetScalarType<T[P], AggregateVariants[P]>
  }




  export type variantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variantsWhereInput
    orderBy?: variantsOrderByWithAggregationInput | variantsOrderByWithAggregationInput[]
    by: VariantsScalarFieldEnum[] | VariantsScalarFieldEnum
    having?: variantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantsCountAggregateInputType | true
    _min?: VariantsMinAggregateInputType
    _max?: VariantsMaxAggregateInputType
  }

  export type VariantsGroupByOutputType = {
    id: string
    name: string
    model_id: string
    created_at: Date
    updated_at: Date
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  type GetVariantsGroupByPayload<T extends variantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantsGroupByOutputType[P]>
            : GetScalarType<T[P], VariantsGroupByOutputType[P]>
        }
      >
    >


  export type variantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    listings?: boolean | variants$listingsArgs<ExtArgs>
    models?: boolean | modelsDefaultArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>

  export type variantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    models?: boolean | modelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>

  export type variantsSelectScalar = {
    id?: boolean
    name?: boolean
    model_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type variantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | variants$listingsArgs<ExtArgs>
    models?: boolean | modelsDefaultArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type variantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | modelsDefaultArgs<ExtArgs>
  }

  export type $variantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "variants"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
      models: Prisma.$modelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      model_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["variants"]>
    composites: {}
  }

  type variantsGetPayload<S extends boolean | null | undefined | variantsDefaultArgs> = $Result.GetResult<Prisma.$variantsPayload, S>

  type variantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<variantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VariantsCountAggregateInputType | true
    }

  export interface variantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['variants'], meta: { name: 'variants' } }
    /**
     * Find zero or one Variants that matches the filter.
     * @param {variantsFindUniqueArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends variantsFindUniqueArgs>(args: SelectSubset<T, variantsFindUniqueArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Variants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {variantsFindUniqueOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends variantsFindUniqueOrThrowArgs>(args: SelectSubset<T, variantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindFirstArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends variantsFindFirstArgs>(args?: SelectSubset<T, variantsFindFirstArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Variants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindFirstOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends variantsFindFirstOrThrowArgs>(args?: SelectSubset<T, variantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variants.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantsWithIdOnly = await prisma.variants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends variantsFindManyArgs>(args?: SelectSubset<T, variantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Variants.
     * @param {variantsCreateArgs} args - Arguments to create a Variants.
     * @example
     * // Create one Variants
     * const Variants = await prisma.variants.create({
     *   data: {
     *     // ... data to create a Variants
     *   }
     * })
     * 
     */
    create<T extends variantsCreateArgs>(args: SelectSubset<T, variantsCreateArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Variants.
     * @param {variantsCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variants = await prisma.variants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends variantsCreateManyArgs>(args?: SelectSubset<T, variantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variants and returns the data saved in the database.
     * @param {variantsCreateManyAndReturnArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variants = await prisma.variants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variants and only return the `id`
     * const variantsWithIdOnly = await prisma.variants.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends variantsCreateManyAndReturnArgs>(args?: SelectSubset<T, variantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Variants.
     * @param {variantsDeleteArgs} args - Arguments to delete one Variants.
     * @example
     * // Delete one Variants
     * const Variants = await prisma.variants.delete({
     *   where: {
     *     // ... filter to delete one Variants
     *   }
     * })
     * 
     */
    delete<T extends variantsDeleteArgs>(args: SelectSubset<T, variantsDeleteArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Variants.
     * @param {variantsUpdateArgs} args - Arguments to update one Variants.
     * @example
     * // Update one Variants
     * const variants = await prisma.variants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends variantsUpdateArgs>(args: SelectSubset<T, variantsUpdateArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Variants.
     * @param {variantsDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends variantsDeleteManyArgs>(args?: SelectSubset<T, variantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variants = await prisma.variants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends variantsUpdateManyArgs>(args: SelectSubset<T, variantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Variants.
     * @param {variantsUpsertArgs} args - Arguments to update or create a Variants.
     * @example
     * // Update or create a Variants
     * const variants = await prisma.variants.upsert({
     *   create: {
     *     // ... data to create a Variants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variants we want to update
     *   }
     * })
     */
    upsert<T extends variantsUpsertArgs>(args: SelectSubset<T, variantsUpsertArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variants.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends variantsCountArgs>(
      args?: Subset<T, variantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantsAggregateArgs>(args: Subset<T, VariantsAggregateArgs>): Prisma.PrismaPromise<GetVariantsAggregateType<T>>

    /**
     * Group by Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends variantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: variantsGroupByArgs['orderBy'] }
        : { orderBy?: variantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, variantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the variants model
   */
  readonly fields: variantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for variants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__variantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends variants$listingsArgs<ExtArgs> = {}>(args?: Subset<T, variants$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    models<T extends modelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, modelsDefaultArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the variants model
   */ 
  interface variantsFieldRefs {
    readonly id: FieldRef<"variants", 'String'>
    readonly name: FieldRef<"variants", 'String'>
    readonly model_id: FieldRef<"variants", 'String'>
    readonly created_at: FieldRef<"variants", 'DateTime'>
    readonly updated_at: FieldRef<"variants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * variants findUnique
   */
  export type variantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants findUniqueOrThrow
   */
  export type variantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants findFirst
   */
  export type variantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants findFirstOrThrow
   */
  export type variantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants findMany
   */
  export type variantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants create
   */
  export type variantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The data needed to create a variants.
     */
    data: XOR<variantsCreateInput, variantsUncheckedCreateInput>
  }

  /**
   * variants createMany
   */
  export type variantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many variants.
     */
    data: variantsCreateManyInput | variantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * variants createManyAndReturn
   */
  export type variantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many variants.
     */
    data: variantsCreateManyInput | variantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * variants update
   */
  export type variantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The data needed to update a variants.
     */
    data: XOR<variantsUpdateInput, variantsUncheckedUpdateInput>
    /**
     * Choose, which variants to update.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants updateMany
   */
  export type variantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update variants.
     */
    data: XOR<variantsUpdateManyMutationInput, variantsUncheckedUpdateManyInput>
    /**
     * Filter which variants to update
     */
    where?: variantsWhereInput
  }

  /**
   * variants upsert
   */
  export type variantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The filter to search for the variants to update in case it exists.
     */
    where: variantsWhereUniqueInput
    /**
     * In case the variants found by the `where` argument doesn't exist, create a new variants with this data.
     */
    create: XOR<variantsCreateInput, variantsUncheckedCreateInput>
    /**
     * In case the variants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<variantsUpdateInput, variantsUncheckedUpdateInput>
  }

  /**
   * variants delete
   */
  export type variantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter which variants to delete.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants deleteMany
   */
  export type variantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variants to delete
     */
    where?: variantsWhereInput
  }

  /**
   * variants.listings
   */
  export type variants$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * variants without action
   */
  export type variantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_types
   */

  export type AggregateVehicle_types = {
    _count: Vehicle_typesCountAggregateOutputType | null
    _min: Vehicle_typesMinAggregateOutputType | null
    _max: Vehicle_typesMaxAggregateOutputType | null
  }

  export type Vehicle_typesMinAggregateOutputType = {
    id: string | null
    name: string | null
    category_id: string | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type Vehicle_typesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category_id: string | null
    created_at: Date | null
    updated_at: Date | null
    image_url: string | null
  }

  export type Vehicle_typesCountAggregateOutputType = {
    id: number
    name: number
    category_id: number
    created_at: number
    updated_at: number
    image_url: number
    _all: number
  }


  export type Vehicle_typesMinAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type Vehicle_typesMaxAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
  }

  export type Vehicle_typesCountAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    image_url?: true
    _all?: true
  }

  export type Vehicle_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_types to aggregate.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typesOrderByWithRelationInput | vehicle_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_types
    **/
    _count?: true | Vehicle_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_typesMaxAggregateInputType
  }

  export type GetVehicle_typesAggregateType<T extends Vehicle_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_types[P]>
      : GetScalarType<T[P], AggregateVehicle_types[P]>
  }




  export type vehicle_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_typesWhereInput
    orderBy?: vehicle_typesOrderByWithAggregationInput | vehicle_typesOrderByWithAggregationInput[]
    by: Vehicle_typesScalarFieldEnum[] | Vehicle_typesScalarFieldEnum
    having?: vehicle_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_typesCountAggregateInputType | true
    _min?: Vehicle_typesMinAggregateInputType
    _max?: Vehicle_typesMaxAggregateInputType
  }

  export type Vehicle_typesGroupByOutputType = {
    id: string
    name: string
    category_id: string
    created_at: Date
    updated_at: Date
    image_url: string | null
    _count: Vehicle_typesCountAggregateOutputType | null
    _min: Vehicle_typesMinAggregateOutputType | null
    _max: Vehicle_typesMaxAggregateOutputType | null
  }

  type GetVehicle_typesGroupByPayload<T extends vehicle_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_typesGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
    brands?: boolean | vehicle_types$brandsArgs<ExtArgs>
    category_attributes?: boolean | vehicle_types$category_attributesArgs<ExtArgs>
    feature_groups?: boolean | vehicle_types$feature_groupsArgs<ExtArgs>
    listings?: boolean | vehicle_types$listingsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | Vehicle_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_types"]>

  export type vehicle_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_types"]>

  export type vehicle_typesSelectScalar = {
    id?: boolean
    name?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    image_url?: boolean
  }

  export type vehicle_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | vehicle_types$brandsArgs<ExtArgs>
    category_attributes?: boolean | vehicle_types$category_attributesArgs<ExtArgs>
    feature_groups?: boolean | vehicle_types$feature_groupsArgs<ExtArgs>
    listings?: boolean | vehicle_types$listingsArgs<ExtArgs>
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | Vehicle_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehicle_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $vehicle_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_types"
    objects: {
      brands: Prisma.$brandsPayload<ExtArgs>[]
      category_attributes: Prisma.$category_attributesPayload<ExtArgs>[]
      feature_groups: Prisma.$feature_groupsPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category_id: string
      created_at: Date
      updated_at: Date
      image_url: string | null
    }, ExtArgs["result"]["vehicle_types"]>
    composites: {}
  }

  type vehicle_typesGetPayload<S extends boolean | null | undefined | vehicle_typesDefaultArgs> = $Result.GetResult<Prisma.$vehicle_typesPayload, S>

  type vehicle_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<vehicle_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Vehicle_typesCountAggregateInputType | true
    }

  export interface vehicle_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_types'], meta: { name: 'vehicle_types' } }
    /**
     * Find zero or one Vehicle_types that matches the filter.
     * @param {vehicle_typesFindUniqueArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_typesFindUniqueArgs>(args: SelectSubset<T, vehicle_typesFindUniqueArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle_types that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {vehicle_typesFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindFirstArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_typesFindFirstArgs>(args?: SelectSubset<T, vehicle_typesFindFirstArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindFirstOrThrowArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicle_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findMany()
     * 
     * // Get first 10 Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_typesWithIdOnly = await prisma.vehicle_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_typesFindManyArgs>(args?: SelectSubset<T, vehicle_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle_types.
     * @param {vehicle_typesCreateArgs} args - Arguments to create a Vehicle_types.
     * @example
     * // Create one Vehicle_types
     * const Vehicle_types = await prisma.vehicle_types.create({
     *   data: {
     *     // ... data to create a Vehicle_types
     *   }
     * })
     * 
     */
    create<T extends vehicle_typesCreateArgs>(args: SelectSubset<T, vehicle_typesCreateArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicle_types.
     * @param {vehicle_typesCreateManyArgs} args - Arguments to create many Vehicle_types.
     * @example
     * // Create many Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_typesCreateManyArgs>(args?: SelectSubset<T, vehicle_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicle_types and returns the data saved in the database.
     * @param {vehicle_typesCreateManyAndReturnArgs} args - Arguments to create many Vehicle_types.
     * @example
     * // Create many Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicle_types and only return the `id`
     * const vehicle_typesWithIdOnly = await prisma.vehicle_types.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehicle_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, vehicle_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle_types.
     * @param {vehicle_typesDeleteArgs} args - Arguments to delete one Vehicle_types.
     * @example
     * // Delete one Vehicle_types
     * const Vehicle_types = await prisma.vehicle_types.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_types
     *   }
     * })
     * 
     */
    delete<T extends vehicle_typesDeleteArgs>(args: SelectSubset<T, vehicle_typesDeleteArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle_types.
     * @param {vehicle_typesUpdateArgs} args - Arguments to update one Vehicle_types.
     * @example
     * // Update one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_typesUpdateArgs>(args: SelectSubset<T, vehicle_typesUpdateArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicle_types.
     * @param {vehicle_typesDeleteManyArgs} args - Arguments to filter Vehicle_types to delete.
     * @example
     * // Delete a few Vehicle_types
     * const { count } = await prisma.vehicle_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_typesDeleteManyArgs>(args?: SelectSubset<T, vehicle_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_typesUpdateManyArgs>(args: SelectSubset<T, vehicle_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_types.
     * @param {vehicle_typesUpsertArgs} args - Arguments to update or create a Vehicle_types.
     * @example
     * // Update or create a Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.upsert({
     *   create: {
     *     // ... data to create a Vehicle_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_types we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_typesUpsertArgs>(args: SelectSubset<T, vehicle_typesUpsertArgs<ExtArgs>>): Prisma__vehicle_typesClient<$Result.GetResult<Prisma.$vehicle_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesCountArgs} args - Arguments to filter Vehicle_types to count.
     * @example
     * // Count the number of Vehicle_types
     * const count = await prisma.vehicle_types.count({
     *   where: {
     *     // ... the filter for the Vehicle_types we want to count
     *   }
     * })
    **/
    count<T extends vehicle_typesCountArgs>(
      args?: Subset<T, vehicle_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_typesAggregateArgs>(args: Subset<T, Vehicle_typesAggregateArgs>): Prisma.PrismaPromise<GetVehicle_typesAggregateType<T>>

    /**
     * Group by Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_typesGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_types model
   */
  readonly fields: vehicle_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends vehicle_types$brandsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_types$brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany"> | Null>
    category_attributes<T extends vehicle_types$category_attributesArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_types$category_attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_attributesPayload<ExtArgs>, T, "findMany"> | Null>
    feature_groups<T extends vehicle_types$feature_groupsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_types$feature_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_groupsPayload<ExtArgs>, T, "findMany"> | Null>
    listings<T extends vehicle_types$listingsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_types$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_types model
   */ 
  interface vehicle_typesFieldRefs {
    readonly id: FieldRef<"vehicle_types", 'String'>
    readonly name: FieldRef<"vehicle_types", 'String'>
    readonly category_id: FieldRef<"vehicle_types", 'String'>
    readonly created_at: FieldRef<"vehicle_types", 'DateTime'>
    readonly updated_at: FieldRef<"vehicle_types", 'DateTime'>
    readonly image_url: FieldRef<"vehicle_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_types findUnique
   */
  export type vehicle_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where: vehicle_typesWhereUniqueInput
  }

  /**
   * vehicle_types findUniqueOrThrow
   */
  export type vehicle_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where: vehicle_typesWhereUniqueInput
  }

  /**
   * vehicle_types findFirst
   */
  export type vehicle_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typesOrderByWithRelationInput | vehicle_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Vehicle_typesScalarFieldEnum | Vehicle_typesScalarFieldEnum[]
  }

  /**
   * vehicle_types findFirstOrThrow
   */
  export type vehicle_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typesOrderByWithRelationInput | vehicle_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Vehicle_typesScalarFieldEnum | Vehicle_typesScalarFieldEnum[]
  }

  /**
   * vehicle_types findMany
   */
  export type vehicle_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typesOrderByWithRelationInput | vehicle_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    distinct?: Vehicle_typesScalarFieldEnum | Vehicle_typesScalarFieldEnum[]
  }

  /**
   * vehicle_types create
   */
  export type vehicle_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_types.
     */
    data: XOR<vehicle_typesCreateInput, vehicle_typesUncheckedCreateInput>
  }

  /**
   * vehicle_types createMany
   */
  export type vehicle_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_types.
     */
    data: vehicle_typesCreateManyInput | vehicle_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_types createManyAndReturn
   */
  export type vehicle_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many vehicle_types.
     */
    data: vehicle_typesCreateManyInput | vehicle_typesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicle_types update
   */
  export type vehicle_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_types.
     */
    data: XOR<vehicle_typesUpdateInput, vehicle_typesUncheckedUpdateInput>
    /**
     * Choose, which vehicle_types to update.
     */
    where: vehicle_typesWhereUniqueInput
  }

  /**
   * vehicle_types updateMany
   */
  export type vehicle_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_types.
     */
    data: XOR<vehicle_typesUpdateManyMutationInput, vehicle_typesUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_types to update
     */
    where?: vehicle_typesWhereInput
  }

  /**
   * vehicle_types upsert
   */
  export type vehicle_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_types to update in case it exists.
     */
    where: vehicle_typesWhereUniqueInput
    /**
     * In case the vehicle_types found by the `where` argument doesn't exist, create a new vehicle_types with this data.
     */
    create: XOR<vehicle_typesCreateInput, vehicle_typesUncheckedCreateInput>
    /**
     * In case the vehicle_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_typesUpdateInput, vehicle_typesUncheckedUpdateInput>
  }

  /**
   * vehicle_types delete
   */
  export type vehicle_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
    /**
     * Filter which vehicle_types to delete.
     */
    where: vehicle_typesWhereUniqueInput
  }

  /**
   * vehicle_types deleteMany
   */
  export type vehicle_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_types to delete
     */
    where?: vehicle_typesWhereInput
  }

  /**
   * vehicle_types.brands
   */
  export type vehicle_types$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    cursor?: brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * vehicle_types.category_attributes
   */
  export type vehicle_types$category_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_attributes
     */
    select?: category_attributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_attributesInclude<ExtArgs> | null
    where?: category_attributesWhereInput
    orderBy?: category_attributesOrderByWithRelationInput | category_attributesOrderByWithRelationInput[]
    cursor?: category_attributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Category_attributesScalarFieldEnum | Category_attributesScalarFieldEnum[]
  }

  /**
   * vehicle_types.feature_groups
   */
  export type vehicle_types$feature_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_groups
     */
    select?: feature_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feature_groupsInclude<ExtArgs> | null
    where?: feature_groupsWhereInput
    orderBy?: feature_groupsOrderByWithRelationInput | feature_groupsOrderByWithRelationInput[]
    cursor?: feature_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Feature_groupsScalarFieldEnum | Feature_groupsScalarFieldEnum[]
  }

  /**
   * vehicle_types.listings
   */
  export type vehicle_types$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * vehicle_types without action
   */
  export type vehicle_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    username: 'username',
    phone: 'phone',
    city: 'city',
    district: 'district',
    role: 'role',
    is_active: 'is_active',
    is_email_verified: 'is_email_verified',
    reset_password_token: 'reset_password_token',
    reset_password_expires: 'reset_password_expires',
    last_login: 'last_login',
    login_attempts: 'login_attempts',
    lock_until: 'lock_until',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email_verification_expires: 'email_verification_expires',
    email_verification_token: 'email_verification_token',
    google_id: 'google_id',
    provider: 'provider',
    refresh_token: 'refresh_token',
    refresh_token_expires: 'refresh_token_expires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ListingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    year: 'year',
    category_id: 'category_id',
    vehicle_type_id: 'vehicle_type_id',
    brand_id: 'brand_id',
    model_id: 'model_id',
    variant_id: 'variant_id',
    status: 'status',
    is_active: 'is_active',
    is_approved: 'is_approved',
    is_pending: 'is_pending',
    view_count: 'view_count',
    is_promoted: 'is_promoted',
    approved_by: 'approved_by',
    approved_at: 'approved_at',
    rejected_at: 'rejected_at',
    reject_reason: 'reject_reason',
    seller_name: 'seller_name',
    seller_phone: 'seller_phone',
    seller_email: 'seller_email',
    city_id: 'city_id',
    district_id: 'district_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    color: 'color',
    engine_power: 'engine_power',
    engine_volume: 'engine_volume',
    fuel_type: 'fuel_type',
    is_exchangeable: 'is_exchangeable',
    km: 'km',
    license_plate: 'license_plate',
    neighborhood_id: 'neighborhood_id',
    transmission: 'transmission',
    vehicle_condition: 'vehicle_condition'
  };

  export type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    sender_id: 'sender_id',
    content: 'content',
    is_read: 'is_read',
    is_edited: 'is_edited',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    listing_id: 'listing_id',
    created_at: 'created_at'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    is_read: 'is_read',
    created_at: 'created_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vehicle_type_id: 'vehicle_type_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    image_url: 'image_url'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const Category_attributesScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    vehicle_type_id: 'vehicle_type_id',
    key: 'key',
    label: 'label',
    type: 'type',
    is_required: 'is_required',
    is_filterable: 'is_filterable',
    sort_order: 'sort_order',
    options: 'options'
  };

  export type Category_attributesScalarFieldEnum = (typeof Category_attributesScalarFieldEnum)[keyof typeof Category_attributesScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plate_code: 'plate_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const ComplaintsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    target_type: 'target_type',
    target_user_id: 'target_user_id',
    target_listing_id: 'target_listing_id',
    category: 'category',
    description: 'description',
    status: 'status',
    admin_response: 'admin_response',
    admin_id: 'admin_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComplaintsScalarFieldEnum = (typeof ComplaintsScalarFieldEnum)[keyof typeof ComplaintsScalarFieldEnum]


  export const ConversationsScalarFieldEnum: {
    id: 'id',
    participant1_id: 'participant1_id',
    participant2_id: 'participant2_id',
    listing_id: 'listing_id',
    last_message_at: 'last_message_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ConversationsScalarFieldEnum = (typeof ConversationsScalarFieldEnum)[keyof typeof ConversationsScalarFieldEnum]


  export const DistrictsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city_id: 'city_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DistrictsScalarFieldEnum = (typeof DistrictsScalarFieldEnum)[keyof typeof DistrictsScalarFieldEnum]


  export const Feature_definitionsScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    key: 'key',
    label: 'label',
    sort_order: 'sort_order'
  };

  export type Feature_definitionsScalarFieldEnum = (typeof Feature_definitionsScalarFieldEnum)[keyof typeof Feature_definitionsScalarFieldEnum]


  export const Feature_groupsScalarFieldEnum: {
    id: 'id',
    vehicle_type_id: 'vehicle_type_id',
    name: 'name',
    label: 'label',
    sort_order: 'sort_order'
  };

  export type Feature_groupsScalarFieldEnum = (typeof Feature_groupsScalarFieldEnum)[keyof typeof Feature_groupsScalarFieldEnum]


  export const Listing_imagesScalarFieldEnum: {
    id: 'id',
    listing_id: 'listing_id',
    url: 'url',
    alt: 'alt',
    sort_order: 'sort_order'
  };

  export type Listing_imagesScalarFieldEnum = (typeof Listing_imagesScalarFieldEnum)[keyof typeof Listing_imagesScalarFieldEnum]


  export const Listing_propertiesScalarFieldEnum: {
    id: 'id',
    listing_id: 'listing_id',
    key: 'key',
    value: 'value',
    type: 'type'
  };

  export type Listing_propertiesScalarFieldEnum = (typeof Listing_propertiesScalarFieldEnum)[keyof typeof Listing_propertiesScalarFieldEnum]


  export const ModelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand_id: 'brand_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ModelsScalarFieldEnum = (typeof ModelsScalarFieldEnum)[keyof typeof ModelsScalarFieldEnum]


  export const VariantsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    model_id: 'model_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VariantsScalarFieldEnum = (typeof VariantsScalarFieldEnum)[keyof typeof VariantsScalarFieldEnum]


  export const Vehicle_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category_id: 'category_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    image_url: 'image_url'
  };

  export type Vehicle_typesScalarFieldEnum = (typeof Vehicle_typesScalarFieldEnum)[keyof typeof Vehicle_typesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'ComplaintTarget'
   */
  export type EnumComplaintTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintTarget'>
    


  /**
   * Reference to a field of type 'ComplaintTarget[]'
   */
  export type ListEnumComplaintTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintTarget[]'>
    


  /**
   * Reference to a field of type 'ComplaintCategory'
   */
  export type EnumComplaintCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintCategory'>
    


  /**
   * Reference to a field of type 'ComplaintCategory[]'
   */
  export type ListEnumComplaintCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintCategory[]'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'ComplaintStatus[]'
   */
  export type ListEnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    district?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_active?: BoolFilter<"User"> | boolean
    is_email_verified?: BoolFilter<"User"> | boolean
    reset_password_token?: StringNullableFilter<"User"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    login_attempts?: IntFilter<"User"> | number
    lock_until?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    email_verification_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    email_verification_token?: StringNullableFilter<"User"> | string | null
    google_id?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    refresh_token?: StringNullableFilter<"User"> | string | null
    refresh_token_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    complaints_complaints_target_user_idTousers?: ComplaintsListRelationFilter
    complaints_complaints_user_idTousers?: ComplaintsListRelationFilter
    conversations_conversations_participant1_idTousers?: ConversationsListRelationFilter
    conversations_conversations_participant2_idTousers?: ConversationsListRelationFilter
    favorites?: FavoriteListRelationFilter
    listings?: ListingListRelationFilter
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrder
    is_email_verified?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    lock_until?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verification_expires?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    google_id?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    refresh_token_expires?: SortOrderInput | SortOrder
    complaints_complaints_target_user_idTousers?: complaintsOrderByRelationAggregateInput
    complaints_complaints_user_idTousers?: complaintsOrderByRelationAggregateInput
    conversations_conversations_participant1_idTousers?: conversationsOrderByRelationAggregateInput
    conversations_conversations_participant2_idTousers?: conversationsOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    google_id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    district?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_active?: BoolFilter<"User"> | boolean
    is_email_verified?: BoolFilter<"User"> | boolean
    reset_password_token?: StringNullableFilter<"User"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    login_attempts?: IntFilter<"User"> | number
    lock_until?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    email_verification_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    email_verification_token?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    refresh_token?: StringNullableFilter<"User"> | string | null
    refresh_token_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    complaints_complaints_target_user_idTousers?: ComplaintsListRelationFilter
    complaints_complaints_user_idTousers?: ComplaintsListRelationFilter
    conversations_conversations_participant1_idTousers?: ConversationsListRelationFilter
    conversations_conversations_participant2_idTousers?: ConversationsListRelationFilter
    favorites?: FavoriteListRelationFilter
    listings?: ListingListRelationFilter
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email" | "username" | "google_id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrder
    is_email_verified?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    lock_until?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verification_expires?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    google_id?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    refresh_token_expires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    district?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    is_email_verified?: BoolWithAggregatesFilter<"User"> | boolean
    reset_password_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_password_expires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    login_attempts?: IntWithAggregatesFilter<"User"> | number
    lock_until?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email_verification_expires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    email_verification_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    google_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    provider?: StringNullableWithAggregatesFilter<"User"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    refresh_token_expires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    category_attributes?: Category_attributesListRelationFilter
    listings?: ListingListRelationFilter
    vehicle_types?: Vehicle_typesListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_attributes?: category_attributesOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
    vehicle_types?: vehicle_typesOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    category_attributes?: Category_attributesListRelationFilter
    listings?: ListingListRelationFilter
    vehicle_types?: Vehicle_typesListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ListingWhereInput = {
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    id?: StringFilter<"Listing"> | string
    title?: StringFilter<"Listing"> | string
    description?: StringNullableFilter<"Listing"> | string | null
    price?: DecimalFilter<"Listing"> | Decimal | DecimalJsLike | number | string
    year?: IntFilter<"Listing"> | number
    category_id?: StringFilter<"Listing"> | string
    vehicle_type_id?: StringFilter<"Listing"> | string
    brand_id?: StringNullableFilter<"Listing"> | string | null
    model_id?: StringNullableFilter<"Listing"> | string | null
    variant_id?: StringNullableFilter<"Listing"> | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    is_active?: BoolFilter<"Listing"> | boolean
    is_approved?: BoolFilter<"Listing"> | boolean
    is_pending?: BoolFilter<"Listing"> | boolean
    view_count?: IntFilter<"Listing"> | number
    is_promoted?: BoolFilter<"Listing"> | boolean
    approved_by?: StringNullableFilter<"Listing"> | string | null
    approved_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    rejected_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    reject_reason?: StringNullableFilter<"Listing"> | string | null
    seller_name?: StringFilter<"Listing"> | string
    seller_phone?: StringFilter<"Listing"> | string
    seller_email?: StringFilter<"Listing"> | string
    city_id?: StringNullableFilter<"Listing"> | string | null
    district_id?: StringNullableFilter<"Listing"> | string | null
    created_at?: DateTimeFilter<"Listing"> | Date | string
    updated_at?: DateTimeFilter<"Listing"> | Date | string
    user_id?: StringFilter<"Listing"> | string
    color?: StringNullableFilter<"Listing"> | string | null
    engine_power?: StringNullableFilter<"Listing"> | string | null
    engine_volume?: StringNullableFilter<"Listing"> | string | null
    fuel_type?: StringNullableFilter<"Listing"> | string | null
    is_exchangeable?: BoolFilter<"Listing"> | boolean
    km?: IntNullableFilter<"Listing"> | number | null
    license_plate?: StringNullableFilter<"Listing"> | string | null
    neighborhood_id?: StringNullableFilter<"Listing"> | string | null
    transmission?: StringNullableFilter<"Listing"> | string | null
    vehicle_condition?: StringNullableFilter<"Listing"> | string | null
    complaints?: ComplaintsListRelationFilter
    conversations?: ConversationsListRelationFilter
    favorites?: FavoriteListRelationFilter
    listing_images?: Listing_imagesListRelationFilter
    listing_properties?: Listing_propertiesListRelationFilter
    brands?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
    cities?: XOR<CitiesNullableRelationFilter, citiesWhereInput> | null
    districts?: XOR<DistrictsNullableRelationFilter, districtsWhereInput> | null
    models?: XOR<ModelsNullableRelationFilter, modelsWhereInput> | null
    users?: XOR<UserRelationFilter, UserWhereInput>
    variants?: XOR<VariantsNullableRelationFilter, variantsWhereInput> | null
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
  }

  export type ListingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    year?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    model_id?: SortOrderInput | SortOrder
    variant_id?: SortOrderInput | SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_approved?: SortOrder
    is_pending?: SortOrder
    view_count?: SortOrder
    is_promoted?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    rejected_at?: SortOrderInput | SortOrder
    reject_reason?: SortOrderInput | SortOrder
    seller_name?: SortOrder
    seller_phone?: SortOrder
    seller_email?: SortOrder
    city_id?: SortOrderInput | SortOrder
    district_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    color?: SortOrderInput | SortOrder
    engine_power?: SortOrderInput | SortOrder
    engine_volume?: SortOrderInput | SortOrder
    fuel_type?: SortOrderInput | SortOrder
    is_exchangeable?: SortOrder
    km?: SortOrderInput | SortOrder
    license_plate?: SortOrderInput | SortOrder
    neighborhood_id?: SortOrderInput | SortOrder
    transmission?: SortOrderInput | SortOrder
    vehicle_condition?: SortOrderInput | SortOrder
    complaints?: complaintsOrderByRelationAggregateInput
    conversations?: conversationsOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    listing_images?: listing_imagesOrderByRelationAggregateInput
    listing_properties?: listing_propertiesOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    categories?: CategoryOrderByWithRelationInput
    cities?: citiesOrderByWithRelationInput
    districts?: districtsOrderByWithRelationInput
    models?: modelsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    variants?: variantsOrderByWithRelationInput
    vehicle_types?: vehicle_typesOrderByWithRelationInput
  }

  export type ListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    title?: StringFilter<"Listing"> | string
    description?: StringNullableFilter<"Listing"> | string | null
    price?: DecimalFilter<"Listing"> | Decimal | DecimalJsLike | number | string
    year?: IntFilter<"Listing"> | number
    category_id?: StringFilter<"Listing"> | string
    vehicle_type_id?: StringFilter<"Listing"> | string
    brand_id?: StringNullableFilter<"Listing"> | string | null
    model_id?: StringNullableFilter<"Listing"> | string | null
    variant_id?: StringNullableFilter<"Listing"> | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    is_active?: BoolFilter<"Listing"> | boolean
    is_approved?: BoolFilter<"Listing"> | boolean
    is_pending?: BoolFilter<"Listing"> | boolean
    view_count?: IntFilter<"Listing"> | number
    is_promoted?: BoolFilter<"Listing"> | boolean
    approved_by?: StringNullableFilter<"Listing"> | string | null
    approved_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    rejected_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    reject_reason?: StringNullableFilter<"Listing"> | string | null
    seller_name?: StringFilter<"Listing"> | string
    seller_phone?: StringFilter<"Listing"> | string
    seller_email?: StringFilter<"Listing"> | string
    city_id?: StringNullableFilter<"Listing"> | string | null
    district_id?: StringNullableFilter<"Listing"> | string | null
    created_at?: DateTimeFilter<"Listing"> | Date | string
    updated_at?: DateTimeFilter<"Listing"> | Date | string
    user_id?: StringFilter<"Listing"> | string
    color?: StringNullableFilter<"Listing"> | string | null
    engine_power?: StringNullableFilter<"Listing"> | string | null
    engine_volume?: StringNullableFilter<"Listing"> | string | null
    fuel_type?: StringNullableFilter<"Listing"> | string | null
    is_exchangeable?: BoolFilter<"Listing"> | boolean
    km?: IntNullableFilter<"Listing"> | number | null
    license_plate?: StringNullableFilter<"Listing"> | string | null
    neighborhood_id?: StringNullableFilter<"Listing"> | string | null
    transmission?: StringNullableFilter<"Listing"> | string | null
    vehicle_condition?: StringNullableFilter<"Listing"> | string | null
    complaints?: ComplaintsListRelationFilter
    conversations?: ConversationsListRelationFilter
    favorites?: FavoriteListRelationFilter
    listing_images?: Listing_imagesListRelationFilter
    listing_properties?: Listing_propertiesListRelationFilter
    brands?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
    cities?: XOR<CitiesNullableRelationFilter, citiesWhereInput> | null
    districts?: XOR<DistrictsNullableRelationFilter, districtsWhereInput> | null
    models?: XOR<ModelsNullableRelationFilter, modelsWhereInput> | null
    users?: XOR<UserRelationFilter, UserWhereInput>
    variants?: XOR<VariantsNullableRelationFilter, variantsWhereInput> | null
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
  }, "id">

  export type ListingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    year?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    model_id?: SortOrderInput | SortOrder
    variant_id?: SortOrderInput | SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_approved?: SortOrder
    is_pending?: SortOrder
    view_count?: SortOrder
    is_promoted?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    rejected_at?: SortOrderInput | SortOrder
    reject_reason?: SortOrderInput | SortOrder
    seller_name?: SortOrder
    seller_phone?: SortOrder
    seller_email?: SortOrder
    city_id?: SortOrderInput | SortOrder
    district_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    color?: SortOrderInput | SortOrder
    engine_power?: SortOrderInput | SortOrder
    engine_volume?: SortOrderInput | SortOrder
    fuel_type?: SortOrderInput | SortOrder
    is_exchangeable?: SortOrder
    km?: SortOrderInput | SortOrder
    license_plate?: SortOrderInput | SortOrder
    neighborhood_id?: SortOrderInput | SortOrder
    transmission?: SortOrderInput | SortOrder
    vehicle_condition?: SortOrderInput | SortOrder
    _count?: ListingCountOrderByAggregateInput
    _avg?: ListingAvgOrderByAggregateInput
    _max?: ListingMaxOrderByAggregateInput
    _min?: ListingMinOrderByAggregateInput
    _sum?: ListingSumOrderByAggregateInput
  }

  export type ListingScalarWhereWithAggregatesInput = {
    AND?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    OR?: ListingScalarWhereWithAggregatesInput[]
    NOT?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Listing"> | string
    title?: StringWithAggregatesFilter<"Listing"> | string
    description?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    price?: DecimalWithAggregatesFilter<"Listing"> | Decimal | DecimalJsLike | number | string
    year?: IntWithAggregatesFilter<"Listing"> | number
    category_id?: StringWithAggregatesFilter<"Listing"> | string
    vehicle_type_id?: StringWithAggregatesFilter<"Listing"> | string
    brand_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    model_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    variant_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    status?: EnumListingStatusWithAggregatesFilter<"Listing"> | $Enums.ListingStatus
    is_active?: BoolWithAggregatesFilter<"Listing"> | boolean
    is_approved?: BoolWithAggregatesFilter<"Listing"> | boolean
    is_pending?: BoolWithAggregatesFilter<"Listing"> | boolean
    view_count?: IntWithAggregatesFilter<"Listing"> | number
    is_promoted?: BoolWithAggregatesFilter<"Listing"> | boolean
    approved_by?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    approved_at?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    rejected_at?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    reject_reason?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    seller_name?: StringWithAggregatesFilter<"Listing"> | string
    seller_phone?: StringWithAggregatesFilter<"Listing"> | string
    seller_email?: StringWithAggregatesFilter<"Listing"> | string
    city_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    district_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Listing"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Listing"> | Date | string
    user_id?: StringWithAggregatesFilter<"Listing"> | string
    color?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    engine_power?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    engine_volume?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    fuel_type?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    is_exchangeable?: BoolWithAggregatesFilter<"Listing"> | boolean
    km?: IntNullableWithAggregatesFilter<"Listing"> | number | null
    license_plate?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    neighborhood_id?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    transmission?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    vehicle_condition?: StringNullableWithAggregatesFilter<"Listing"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    is_edited?: BoolFilter<"Message"> | boolean
    created_at?: DateTimeFilter<"Message"> | Date | string
    updated_at?: DateTimeFilter<"Message"> | Date | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    is_edited?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    conversations?: conversationsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    is_edited?: BoolFilter<"Message"> | boolean
    created_at?: DateTimeFilter<"Message"> | Date | string
    updated_at?: DateTimeFilter<"Message"> | Date | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    is_edited?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversation_id?: StringWithAggregatesFilter<"Message"> | string
    sender_id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    is_read?: BoolWithAggregatesFilter<"Message"> | boolean
    is_edited?: BoolWithAggregatesFilter<"Message"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    user_id?: StringFilter<"Favorite"> | string
    listing_id?: StringFilter<"Favorite"> | string
    created_at?: DateTimeFilter<"Favorite"> | Date | string
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    listing_id?: SortOrder
    created_at?: SortOrder
    listings?: ListingOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_listing_id?: FavoriteUser_idListing_idCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    user_id?: StringFilter<"Favorite"> | string
    listing_id?: StringFilter<"Favorite"> | string
    created_at?: DateTimeFilter<"Favorite"> | Date | string
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "user_id_listing_id">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    listing_id?: SortOrder
    created_at?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    user_id?: StringWithAggregatesFilter<"Favorite"> | string
    listing_id?: StringWithAggregatesFilter<"Favorite"> | string
    created_at?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    user_id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    user_id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    users?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    user_id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: StringFilter<"brands"> | string
    name?: StringFilter<"brands"> | string
    vehicle_type_id?: StringFilter<"brands"> | string
    created_at?: DateTimeFilter<"brands"> | Date | string
    updated_at?: DateTimeFilter<"brands"> | Date | string
    image_url?: StringNullableFilter<"brands"> | string | null
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
    listings?: ListingListRelationFilter
    models?: ModelsListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vehicle_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrderInput | SortOrder
    vehicle_types?: vehicle_typesOrderByWithRelationInput
    listings?: ListingOrderByRelationAggregateInput
    models?: modelsOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    name?: StringFilter<"brands"> | string
    vehicle_type_id?: StringFilter<"brands"> | string
    created_at?: DateTimeFilter<"brands"> | Date | string
    updated_at?: DateTimeFilter<"brands"> | Date | string
    image_url?: StringNullableFilter<"brands"> | string | null
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
    listings?: ListingListRelationFilter
    models?: ModelsListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vehicle_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrderInput | SortOrder
    _count?: brandsCountOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"brands"> | string
    name?: StringWithAggregatesFilter<"brands"> | string
    vehicle_type_id?: StringWithAggregatesFilter<"brands"> | string
    created_at?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    image_url?: StringNullableWithAggregatesFilter<"brands"> | string | null
  }

  export type category_attributesWhereInput = {
    AND?: category_attributesWhereInput | category_attributesWhereInput[]
    OR?: category_attributesWhereInput[]
    NOT?: category_attributesWhereInput | category_attributesWhereInput[]
    id?: StringFilter<"category_attributes"> | string
    category_id?: StringFilter<"category_attributes"> | string
    vehicle_type_id?: StringNullableFilter<"category_attributes"> | string | null
    key?: StringFilter<"category_attributes"> | string
    label?: StringFilter<"category_attributes"> | string
    type?: EnumPropertyTypeFilter<"category_attributes"> | $Enums.PropertyType
    is_required?: BoolFilter<"category_attributes"> | boolean
    is_filterable?: BoolFilter<"category_attributes"> | boolean
    sort_order?: IntFilter<"category_attributes"> | number
    options?: JsonNullableFilter<"category_attributes">
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
    vehicle_types?: XOR<Vehicle_typesNullableRelationFilter, vehicle_typesWhereInput> | null
  }

  export type category_attributesOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrderInput | SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    is_required?: SortOrder
    is_filterable?: SortOrder
    sort_order?: SortOrder
    options?: SortOrderInput | SortOrder
    categories?: CategoryOrderByWithRelationInput
    vehicle_types?: vehicle_typesOrderByWithRelationInput
  }

  export type category_attributesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category_id_vehicle_type_id_key?: category_attributesCategory_idVehicle_type_idKeyCompoundUniqueInput
    AND?: category_attributesWhereInput | category_attributesWhereInput[]
    OR?: category_attributesWhereInput[]
    NOT?: category_attributesWhereInput | category_attributesWhereInput[]
    category_id?: StringFilter<"category_attributes"> | string
    vehicle_type_id?: StringNullableFilter<"category_attributes"> | string | null
    key?: StringFilter<"category_attributes"> | string
    label?: StringFilter<"category_attributes"> | string
    type?: EnumPropertyTypeFilter<"category_attributes"> | $Enums.PropertyType
    is_required?: BoolFilter<"category_attributes"> | boolean
    is_filterable?: BoolFilter<"category_attributes"> | boolean
    sort_order?: IntFilter<"category_attributes"> | number
    options?: JsonNullableFilter<"category_attributes">
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
    vehicle_types?: XOR<Vehicle_typesNullableRelationFilter, vehicle_typesWhereInput> | null
  }, "id" | "category_id_vehicle_type_id_key">

  export type category_attributesOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrderInput | SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    is_required?: SortOrder
    is_filterable?: SortOrder
    sort_order?: SortOrder
    options?: SortOrderInput | SortOrder
    _count?: category_attributesCountOrderByAggregateInput
    _avg?: category_attributesAvgOrderByAggregateInput
    _max?: category_attributesMaxOrderByAggregateInput
    _min?: category_attributesMinOrderByAggregateInput
    _sum?: category_attributesSumOrderByAggregateInput
  }

  export type category_attributesScalarWhereWithAggregatesInput = {
    AND?: category_attributesScalarWhereWithAggregatesInput | category_attributesScalarWhereWithAggregatesInput[]
    OR?: category_attributesScalarWhereWithAggregatesInput[]
    NOT?: category_attributesScalarWhereWithAggregatesInput | category_attributesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"category_attributes"> | string
    category_id?: StringWithAggregatesFilter<"category_attributes"> | string
    vehicle_type_id?: StringNullableWithAggregatesFilter<"category_attributes"> | string | null
    key?: StringWithAggregatesFilter<"category_attributes"> | string
    label?: StringWithAggregatesFilter<"category_attributes"> | string
    type?: EnumPropertyTypeWithAggregatesFilter<"category_attributes"> | $Enums.PropertyType
    is_required?: BoolWithAggregatesFilter<"category_attributes"> | boolean
    is_filterable?: BoolWithAggregatesFilter<"category_attributes"> | boolean
    sort_order?: IntWithAggregatesFilter<"category_attributes"> | number
    options?: JsonNullableWithAggregatesFilter<"category_attributes">
  }

  export type citiesWhereInput = {
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    id?: StringFilter<"cities"> | string
    name?: StringFilter<"cities"> | string
    plate_code?: StringNullableFilter<"cities"> | string | null
    created_at?: DateTimeFilter<"cities"> | Date | string
    updated_at?: DateTimeFilter<"cities"> | Date | string
    districts?: DistrictsListRelationFilter
    listings?: ListingListRelationFilter
  }

  export type citiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    districts?: districtsOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
  }

  export type citiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    name?: StringFilter<"cities"> | string
    plate_code?: StringNullableFilter<"cities"> | string | null
    created_at?: DateTimeFilter<"cities"> | Date | string
    updated_at?: DateTimeFilter<"cities"> | Date | string
    districts?: DistrictsListRelationFilter
    listings?: ListingListRelationFilter
  }, "id">

  export type citiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: citiesCountOrderByAggregateInput
    _max?: citiesMaxOrderByAggregateInput
    _min?: citiesMinOrderByAggregateInput
  }

  export type citiesScalarWhereWithAggregatesInput = {
    AND?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    OR?: citiesScalarWhereWithAggregatesInput[]
    NOT?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cities"> | string
    name?: StringWithAggregatesFilter<"cities"> | string
    plate_code?: StringNullableWithAggregatesFilter<"cities"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"cities"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"cities"> | Date | string
  }

  export type complaintsWhereInput = {
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    id?: StringFilter<"complaints"> | string
    user_id?: StringFilter<"complaints"> | string
    target_type?: EnumComplaintTargetFilter<"complaints"> | $Enums.ComplaintTarget
    target_user_id?: StringNullableFilter<"complaints"> | string | null
    target_listing_id?: StringNullableFilter<"complaints"> | string | null
    category?: EnumComplaintCategoryFilter<"complaints"> | $Enums.ComplaintCategory
    description?: StringNullableFilter<"complaints"> | string | null
    status?: EnumComplaintStatusFilter<"complaints"> | $Enums.ComplaintStatus
    admin_response?: StringNullableFilter<"complaints"> | string | null
    admin_id?: StringNullableFilter<"complaints"> | string | null
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    listings?: XOR<ListingNullableRelationFilter, ListingWhereInput> | null
    users_complaints_target_user_idTousers?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    users_complaints_user_idTousers?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type complaintsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_type?: SortOrder
    target_user_id?: SortOrderInput | SortOrder
    target_listing_id?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    admin_response?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    listings?: ListingOrderByWithRelationInput
    users_complaints_target_user_idTousers?: UserOrderByWithRelationInput
    users_complaints_user_idTousers?: UserOrderByWithRelationInput
  }

  export type complaintsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: complaintsWhereInput | complaintsWhereInput[]
    OR?: complaintsWhereInput[]
    NOT?: complaintsWhereInput | complaintsWhereInput[]
    user_id?: StringFilter<"complaints"> | string
    target_type?: EnumComplaintTargetFilter<"complaints"> | $Enums.ComplaintTarget
    target_user_id?: StringNullableFilter<"complaints"> | string | null
    target_listing_id?: StringNullableFilter<"complaints"> | string | null
    category?: EnumComplaintCategoryFilter<"complaints"> | $Enums.ComplaintCategory
    description?: StringNullableFilter<"complaints"> | string | null
    status?: EnumComplaintStatusFilter<"complaints"> | $Enums.ComplaintStatus
    admin_response?: StringNullableFilter<"complaints"> | string | null
    admin_id?: StringNullableFilter<"complaints"> | string | null
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
    listings?: XOR<ListingNullableRelationFilter, ListingWhereInput> | null
    users_complaints_target_user_idTousers?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    users_complaints_user_idTousers?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type complaintsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_type?: SortOrder
    target_user_id?: SortOrderInput | SortOrder
    target_listing_id?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    admin_response?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: complaintsCountOrderByAggregateInput
    _max?: complaintsMaxOrderByAggregateInput
    _min?: complaintsMinOrderByAggregateInput
  }

  export type complaintsScalarWhereWithAggregatesInput = {
    AND?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    OR?: complaintsScalarWhereWithAggregatesInput[]
    NOT?: complaintsScalarWhereWithAggregatesInput | complaintsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"complaints"> | string
    user_id?: StringWithAggregatesFilter<"complaints"> | string
    target_type?: EnumComplaintTargetWithAggregatesFilter<"complaints"> | $Enums.ComplaintTarget
    target_user_id?: StringNullableWithAggregatesFilter<"complaints"> | string | null
    target_listing_id?: StringNullableWithAggregatesFilter<"complaints"> | string | null
    category?: EnumComplaintCategoryWithAggregatesFilter<"complaints"> | $Enums.ComplaintCategory
    description?: StringNullableWithAggregatesFilter<"complaints"> | string | null
    status?: EnumComplaintStatusWithAggregatesFilter<"complaints"> | $Enums.ComplaintStatus
    admin_response?: StringNullableWithAggregatesFilter<"complaints"> | string | null
    admin_id?: StringNullableWithAggregatesFilter<"complaints"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"complaints"> | Date | string
  }

  export type conversationsWhereInput = {
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    id?: StringFilter<"conversations"> | string
    participant1_id?: StringFilter<"conversations"> | string
    participant2_id?: StringFilter<"conversations"> | string
    listing_id?: StringNullableFilter<"conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
    created_at?: DateTimeFilter<"conversations"> | Date | string
    updated_at?: DateTimeFilter<"conversations"> | Date | string
    listings?: XOR<ListingNullableRelationFilter, ListingWhereInput> | null
    users_conversations_participant1_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    users_conversations_participant2_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type conversationsOrderByWithRelationInput = {
    id?: SortOrder
    participant1_id?: SortOrder
    participant2_id?: SortOrder
    listing_id?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    listings?: ListingOrderByWithRelationInput
    users_conversations_participant1_idTousers?: UserOrderByWithRelationInput
    users_conversations_participant2_idTousers?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    participant1_id_participant2_id_listing_id?: conversationsParticipant1_idParticipant2_idListing_idCompoundUniqueInput
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    participant1_id?: StringFilter<"conversations"> | string
    participant2_id?: StringFilter<"conversations"> | string
    listing_id?: StringNullableFilter<"conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
    created_at?: DateTimeFilter<"conversations"> | Date | string
    updated_at?: DateTimeFilter<"conversations"> | Date | string
    listings?: XOR<ListingNullableRelationFilter, ListingWhereInput> | null
    users_conversations_participant1_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    users_conversations_participant2_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "participant1_id_participant2_id_listing_id">

  export type conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    participant1_id?: SortOrder
    participant2_id?: SortOrder
    listing_id?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: conversationsCountOrderByAggregateInput
    _max?: conversationsMaxOrderByAggregateInput
    _min?: conversationsMinOrderByAggregateInput
  }

  export type conversationsScalarWhereWithAggregatesInput = {
    AND?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    OR?: conversationsScalarWhereWithAggregatesInput[]
    NOT?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"conversations"> | string
    participant1_id?: StringWithAggregatesFilter<"conversations"> | string
    participant2_id?: StringWithAggregatesFilter<"conversations"> | string
    listing_id?: StringNullableWithAggregatesFilter<"conversations"> | string | null
    last_message_at?: DateTimeNullableWithAggregatesFilter<"conversations"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"conversations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"conversations"> | Date | string
  }

  export type districtsWhereInput = {
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    id?: StringFilter<"districts"> | string
    name?: StringFilter<"districts"> | string
    city_id?: StringFilter<"districts"> | string
    created_at?: DateTimeFilter<"districts"> | Date | string
    updated_at?: DateTimeFilter<"districts"> | Date | string
    cities?: XOR<CitiesRelationFilter, citiesWhereInput>
    listings?: ListingListRelationFilter
  }

  export type districtsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cities?: citiesOrderByWithRelationInput
    listings?: ListingOrderByRelationAggregateInput
  }

  export type districtsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    name?: StringFilter<"districts"> | string
    city_id?: StringFilter<"districts"> | string
    created_at?: DateTimeFilter<"districts"> | Date | string
    updated_at?: DateTimeFilter<"districts"> | Date | string
    cities?: XOR<CitiesRelationFilter, citiesWhereInput>
    listings?: ListingListRelationFilter
  }, "id">

  export type districtsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: districtsCountOrderByAggregateInput
    _max?: districtsMaxOrderByAggregateInput
    _min?: districtsMinOrderByAggregateInput
  }

  export type districtsScalarWhereWithAggregatesInput = {
    AND?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    OR?: districtsScalarWhereWithAggregatesInput[]
    NOT?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"districts"> | string
    name?: StringWithAggregatesFilter<"districts"> | string
    city_id?: StringWithAggregatesFilter<"districts"> | string
    created_at?: DateTimeWithAggregatesFilter<"districts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"districts"> | Date | string
  }

  export type feature_definitionsWhereInput = {
    AND?: feature_definitionsWhereInput | feature_definitionsWhereInput[]
    OR?: feature_definitionsWhereInput[]
    NOT?: feature_definitionsWhereInput | feature_definitionsWhereInput[]
    id?: StringFilter<"feature_definitions"> | string
    group_id?: StringFilter<"feature_definitions"> | string
    key?: StringFilter<"feature_definitions"> | string
    label?: StringFilter<"feature_definitions"> | string
    sort_order?: IntFilter<"feature_definitions"> | number
    feature_groups?: XOR<Feature_groupsRelationFilter, feature_groupsWhereInput>
  }

  export type feature_definitionsOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
    feature_groups?: feature_groupsOrderByWithRelationInput
  }

  export type feature_definitionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    group_id_key?: feature_definitionsGroup_idKeyCompoundUniqueInput
    AND?: feature_definitionsWhereInput | feature_definitionsWhereInput[]
    OR?: feature_definitionsWhereInput[]
    NOT?: feature_definitionsWhereInput | feature_definitionsWhereInput[]
    group_id?: StringFilter<"feature_definitions"> | string
    key?: StringFilter<"feature_definitions"> | string
    label?: StringFilter<"feature_definitions"> | string
    sort_order?: IntFilter<"feature_definitions"> | number
    feature_groups?: XOR<Feature_groupsRelationFilter, feature_groupsWhereInput>
  }, "id" | "group_id_key">

  export type feature_definitionsOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
    _count?: feature_definitionsCountOrderByAggregateInput
    _avg?: feature_definitionsAvgOrderByAggregateInput
    _max?: feature_definitionsMaxOrderByAggregateInput
    _min?: feature_definitionsMinOrderByAggregateInput
    _sum?: feature_definitionsSumOrderByAggregateInput
  }

  export type feature_definitionsScalarWhereWithAggregatesInput = {
    AND?: feature_definitionsScalarWhereWithAggregatesInput | feature_definitionsScalarWhereWithAggregatesInput[]
    OR?: feature_definitionsScalarWhereWithAggregatesInput[]
    NOT?: feature_definitionsScalarWhereWithAggregatesInput | feature_definitionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"feature_definitions"> | string
    group_id?: StringWithAggregatesFilter<"feature_definitions"> | string
    key?: StringWithAggregatesFilter<"feature_definitions"> | string
    label?: StringWithAggregatesFilter<"feature_definitions"> | string
    sort_order?: IntWithAggregatesFilter<"feature_definitions"> | number
  }

  export type feature_groupsWhereInput = {
    AND?: feature_groupsWhereInput | feature_groupsWhereInput[]
    OR?: feature_groupsWhereInput[]
    NOT?: feature_groupsWhereInput | feature_groupsWhereInput[]
    id?: StringFilter<"feature_groups"> | string
    vehicle_type_id?: StringFilter<"feature_groups"> | string
    name?: StringFilter<"feature_groups"> | string
    label?: StringFilter<"feature_groups"> | string
    sort_order?: IntFilter<"feature_groups"> | number
    feature_definitions?: Feature_definitionsListRelationFilter
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
  }

  export type feature_groupsOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_type_id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
    feature_definitions?: feature_definitionsOrderByRelationAggregateInput
    vehicle_types?: vehicle_typesOrderByWithRelationInput
  }

  export type feature_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vehicle_type_id_name?: feature_groupsVehicle_type_idNameCompoundUniqueInput
    AND?: feature_groupsWhereInput | feature_groupsWhereInput[]
    OR?: feature_groupsWhereInput[]
    NOT?: feature_groupsWhereInput | feature_groupsWhereInput[]
    vehicle_type_id?: StringFilter<"feature_groups"> | string
    name?: StringFilter<"feature_groups"> | string
    label?: StringFilter<"feature_groups"> | string
    sort_order?: IntFilter<"feature_groups"> | number
    feature_definitions?: Feature_definitionsListRelationFilter
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
  }, "id" | "vehicle_type_id_name">

  export type feature_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_type_id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
    _count?: feature_groupsCountOrderByAggregateInput
    _avg?: feature_groupsAvgOrderByAggregateInput
    _max?: feature_groupsMaxOrderByAggregateInput
    _min?: feature_groupsMinOrderByAggregateInput
    _sum?: feature_groupsSumOrderByAggregateInput
  }

  export type feature_groupsScalarWhereWithAggregatesInput = {
    AND?: feature_groupsScalarWhereWithAggregatesInput | feature_groupsScalarWhereWithAggregatesInput[]
    OR?: feature_groupsScalarWhereWithAggregatesInput[]
    NOT?: feature_groupsScalarWhereWithAggregatesInput | feature_groupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"feature_groups"> | string
    vehicle_type_id?: StringWithAggregatesFilter<"feature_groups"> | string
    name?: StringWithAggregatesFilter<"feature_groups"> | string
    label?: StringWithAggregatesFilter<"feature_groups"> | string
    sort_order?: IntWithAggregatesFilter<"feature_groups"> | number
  }

  export type listing_imagesWhereInput = {
    AND?: listing_imagesWhereInput | listing_imagesWhereInput[]
    OR?: listing_imagesWhereInput[]
    NOT?: listing_imagesWhereInput | listing_imagesWhereInput[]
    id?: StringFilter<"listing_images"> | string
    listing_id?: StringFilter<"listing_images"> | string
    url?: StringFilter<"listing_images"> | string
    alt?: StringNullableFilter<"listing_images"> | string | null
    sort_order?: IntFilter<"listing_images"> | number
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
  }

  export type listing_imagesOrderByWithRelationInput = {
    id?: SortOrder
    listing_id?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sort_order?: SortOrder
    listings?: ListingOrderByWithRelationInput
  }

  export type listing_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: listing_imagesWhereInput | listing_imagesWhereInput[]
    OR?: listing_imagesWhereInput[]
    NOT?: listing_imagesWhereInput | listing_imagesWhereInput[]
    listing_id?: StringFilter<"listing_images"> | string
    url?: StringFilter<"listing_images"> | string
    alt?: StringNullableFilter<"listing_images"> | string | null
    sort_order?: IntFilter<"listing_images"> | number
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
  }, "id">

  export type listing_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    listing_id?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sort_order?: SortOrder
    _count?: listing_imagesCountOrderByAggregateInput
    _avg?: listing_imagesAvgOrderByAggregateInput
    _max?: listing_imagesMaxOrderByAggregateInput
    _min?: listing_imagesMinOrderByAggregateInput
    _sum?: listing_imagesSumOrderByAggregateInput
  }

  export type listing_imagesScalarWhereWithAggregatesInput = {
    AND?: listing_imagesScalarWhereWithAggregatesInput | listing_imagesScalarWhereWithAggregatesInput[]
    OR?: listing_imagesScalarWhereWithAggregatesInput[]
    NOT?: listing_imagesScalarWhereWithAggregatesInput | listing_imagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"listing_images"> | string
    listing_id?: StringWithAggregatesFilter<"listing_images"> | string
    url?: StringWithAggregatesFilter<"listing_images"> | string
    alt?: StringNullableWithAggregatesFilter<"listing_images"> | string | null
    sort_order?: IntWithAggregatesFilter<"listing_images"> | number
  }

  export type listing_propertiesWhereInput = {
    AND?: listing_propertiesWhereInput | listing_propertiesWhereInput[]
    OR?: listing_propertiesWhereInput[]
    NOT?: listing_propertiesWhereInput | listing_propertiesWhereInput[]
    id?: StringFilter<"listing_properties"> | string
    listing_id?: StringFilter<"listing_properties"> | string
    key?: StringFilter<"listing_properties"> | string
    value?: StringFilter<"listing_properties"> | string
    type?: EnumPropertyTypeFilter<"listing_properties"> | $Enums.PropertyType
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
  }

  export type listing_propertiesOrderByWithRelationInput = {
    id?: SortOrder
    listing_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    listings?: ListingOrderByWithRelationInput
  }

  export type listing_propertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listing_id_key?: listing_propertiesListing_idKeyCompoundUniqueInput
    AND?: listing_propertiesWhereInput | listing_propertiesWhereInput[]
    OR?: listing_propertiesWhereInput[]
    NOT?: listing_propertiesWhereInput | listing_propertiesWhereInput[]
    listing_id?: StringFilter<"listing_properties"> | string
    key?: StringFilter<"listing_properties"> | string
    value?: StringFilter<"listing_properties"> | string
    type?: EnumPropertyTypeFilter<"listing_properties"> | $Enums.PropertyType
    listings?: XOR<ListingRelationFilter, ListingWhereInput>
  }, "id" | "listing_id_key">

  export type listing_propertiesOrderByWithAggregationInput = {
    id?: SortOrder
    listing_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    _count?: listing_propertiesCountOrderByAggregateInput
    _max?: listing_propertiesMaxOrderByAggregateInput
    _min?: listing_propertiesMinOrderByAggregateInput
  }

  export type listing_propertiesScalarWhereWithAggregatesInput = {
    AND?: listing_propertiesScalarWhereWithAggregatesInput | listing_propertiesScalarWhereWithAggregatesInput[]
    OR?: listing_propertiesScalarWhereWithAggregatesInput[]
    NOT?: listing_propertiesScalarWhereWithAggregatesInput | listing_propertiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"listing_properties"> | string
    listing_id?: StringWithAggregatesFilter<"listing_properties"> | string
    key?: StringWithAggregatesFilter<"listing_properties"> | string
    value?: StringWithAggregatesFilter<"listing_properties"> | string
    type?: EnumPropertyTypeWithAggregatesFilter<"listing_properties"> | $Enums.PropertyType
  }

  export type modelsWhereInput = {
    AND?: modelsWhereInput | modelsWhereInput[]
    OR?: modelsWhereInput[]
    NOT?: modelsWhereInput | modelsWhereInput[]
    id?: StringFilter<"models"> | string
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    created_at?: DateTimeFilter<"models"> | Date | string
    updated_at?: DateTimeFilter<"models"> | Date | string
    listings?: ListingListRelationFilter
    brands?: XOR<BrandsRelationFilter, brandsWhereInput>
    variants?: VariantsListRelationFilter
  }

  export type modelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
    brands?: brandsOrderByWithRelationInput
    variants?: variantsOrderByRelationAggregateInput
  }

  export type modelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: modelsWhereInput | modelsWhereInput[]
    OR?: modelsWhereInput[]
    NOT?: modelsWhereInput | modelsWhereInput[]
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    created_at?: DateTimeFilter<"models"> | Date | string
    updated_at?: DateTimeFilter<"models"> | Date | string
    listings?: ListingListRelationFilter
    brands?: XOR<BrandsRelationFilter, brandsWhereInput>
    variants?: VariantsListRelationFilter
  }, "id">

  export type modelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: modelsCountOrderByAggregateInput
    _max?: modelsMaxOrderByAggregateInput
    _min?: modelsMinOrderByAggregateInput
  }

  export type modelsScalarWhereWithAggregatesInput = {
    AND?: modelsScalarWhereWithAggregatesInput | modelsScalarWhereWithAggregatesInput[]
    OR?: modelsScalarWhereWithAggregatesInput[]
    NOT?: modelsScalarWhereWithAggregatesInput | modelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"models"> | string
    name?: StringWithAggregatesFilter<"models"> | string
    brand_id?: StringWithAggregatesFilter<"models"> | string
    created_at?: DateTimeWithAggregatesFilter<"models"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"models"> | Date | string
  }

  export type variantsWhereInput = {
    AND?: variantsWhereInput | variantsWhereInput[]
    OR?: variantsWhereInput[]
    NOT?: variantsWhereInput | variantsWhereInput[]
    id?: StringFilter<"variants"> | string
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    created_at?: DateTimeFilter<"variants"> | Date | string
    updated_at?: DateTimeFilter<"variants"> | Date | string
    listings?: ListingListRelationFilter
    models?: XOR<ModelsRelationFilter, modelsWhereInput>
  }

  export type variantsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
    models?: modelsOrderByWithRelationInput
  }

  export type variantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: variantsWhereInput | variantsWhereInput[]
    OR?: variantsWhereInput[]
    NOT?: variantsWhereInput | variantsWhereInput[]
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    created_at?: DateTimeFilter<"variants"> | Date | string
    updated_at?: DateTimeFilter<"variants"> | Date | string
    listings?: ListingListRelationFilter
    models?: XOR<ModelsRelationFilter, modelsWhereInput>
  }, "id">

  export type variantsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: variantsCountOrderByAggregateInput
    _max?: variantsMaxOrderByAggregateInput
    _min?: variantsMinOrderByAggregateInput
  }

  export type variantsScalarWhereWithAggregatesInput = {
    AND?: variantsScalarWhereWithAggregatesInput | variantsScalarWhereWithAggregatesInput[]
    OR?: variantsScalarWhereWithAggregatesInput[]
    NOT?: variantsScalarWhereWithAggregatesInput | variantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"variants"> | string
    name?: StringWithAggregatesFilter<"variants"> | string
    model_id?: StringWithAggregatesFilter<"variants"> | string
    created_at?: DateTimeWithAggregatesFilter<"variants"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"variants"> | Date | string
  }

  export type vehicle_typesWhereInput = {
    AND?: vehicle_typesWhereInput | vehicle_typesWhereInput[]
    OR?: vehicle_typesWhereInput[]
    NOT?: vehicle_typesWhereInput | vehicle_typesWhereInput[]
    id?: StringFilter<"vehicle_types"> | string
    name?: StringFilter<"vehicle_types"> | string
    category_id?: StringFilter<"vehicle_types"> | string
    created_at?: DateTimeFilter<"vehicle_types"> | Date | string
    updated_at?: DateTimeFilter<"vehicle_types"> | Date | string
    image_url?: StringNullableFilter<"vehicle_types"> | string | null
    brands?: BrandsListRelationFilter
    category_attributes?: Category_attributesListRelationFilter
    feature_groups?: Feature_groupsListRelationFilter
    listings?: ListingListRelationFilter
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type vehicle_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrderInput | SortOrder
    brands?: brandsOrderByRelationAggregateInput
    category_attributes?: category_attributesOrderByRelationAggregateInput
    feature_groups?: feature_groupsOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
    categories?: CategoryOrderByWithRelationInput
  }

  export type vehicle_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_typesWhereInput | vehicle_typesWhereInput[]
    OR?: vehicle_typesWhereInput[]
    NOT?: vehicle_typesWhereInput | vehicle_typesWhereInput[]
    name?: StringFilter<"vehicle_types"> | string
    category_id?: StringFilter<"vehicle_types"> | string
    created_at?: DateTimeFilter<"vehicle_types"> | Date | string
    updated_at?: DateTimeFilter<"vehicle_types"> | Date | string
    image_url?: StringNullableFilter<"vehicle_types"> | string | null
    brands?: BrandsListRelationFilter
    category_attributes?: Category_attributesListRelationFilter
    feature_groups?: Feature_groupsListRelationFilter
    listings?: ListingListRelationFilter
    categories?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "id">

  export type vehicle_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrderInput | SortOrder
    _count?: vehicle_typesCountOrderByAggregateInput
    _max?: vehicle_typesMaxOrderByAggregateInput
    _min?: vehicle_typesMinOrderByAggregateInput
  }

  export type vehicle_typesScalarWhereWithAggregatesInput = {
    AND?: vehicle_typesScalarWhereWithAggregatesInput | vehicle_typesScalarWhereWithAggregatesInput[]
    OR?: vehicle_typesScalarWhereWithAggregatesInput[]
    NOT?: vehicle_typesScalarWhereWithAggregatesInput | vehicle_typesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_types"> | string
    name?: StringWithAggregatesFilter<"vehicle_types"> | string
    category_id?: StringWithAggregatesFilter<"vehicle_types"> | string
    created_at?: DateTimeWithAggregatesFilter<"vehicle_types"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"vehicle_types"> | Date | string
    image_url?: StringNullableWithAggregatesFilter<"vehicle_types"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesCreateNestedManyWithoutCategoriesInput
    listings?: ListingCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutCategoriesInput
    listings?: ListingUncheckedCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUpdateManyWithoutCategoriesNestedInput
    listings?: ListingUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUncheckedUpdateManyWithoutCategoriesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type ListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
    conversations: conversationsCreateNestedOneWithoutMessagesInput
    users: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversation_id: string
    sender_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: conversationsUpdateOneRequiredWithoutMessagesNestedInput
    users?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversation_id: string
    sender_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    created_at?: Date | string
    listings: ListingCreateNestedOneWithoutFavoritesInput
    users: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    user_id: string
    listing_id: string
    created_at?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneRequiredWithoutFavoritesNestedInput
    users?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    user_id: string
    listing_id: string
    created_at?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
    users: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    user_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    user_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    vehicle_types: vehicle_typesCreateNestedOneWithoutBrandsInput
    listings?: ListingCreateNestedManyWithoutBrandsInput
    models?: modelsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateInput = {
    id: string
    name: string
    vehicle_type_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    listings?: ListingUncheckedCreateNestedManyWithoutBrandsInput
    models?: modelsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutBrandsNestedInput
    listings?: ListingUpdateManyWithoutBrandsNestedInput
    models?: modelsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    listings?: ListingUncheckedUpdateManyWithoutBrandsNestedInput
    models?: modelsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type brandsCreateManyInput = {
    id: string
    name: string
    vehicle_type_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type brandsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type brandsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type category_attributesCreateInput = {
    id: string
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    categories: CategoryCreateNestedOneWithoutCategory_attributesInput
    vehicle_types?: vehicle_typesCreateNestedOneWithoutCategory_attributesInput
  }

  export type category_attributesUncheckedCreateInput = {
    id: string
    category_id: string
    vehicle_type_id?: string | null
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUpdateOneRequiredWithoutCategory_attributesNestedInput
    vehicle_types?: vehicle_typesUpdateOneWithoutCategory_attributesNestedInput
  }

  export type category_attributesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesCreateManyInput = {
    id: string
    category_id: string
    vehicle_type_id?: string | null
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type citiesCreateInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    districts?: districtsCreateNestedManyWithoutCitiesInput
    listings?: ListingCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    districts?: districtsUncheckedCreateNestedManyWithoutCitiesInput
    listings?: ListingUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUpdateManyWithoutCitiesNestedInput
    listings?: ListingUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUncheckedUpdateManyWithoutCitiesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type citiesCreateManyInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type citiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type citiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsCreateInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutComplaintsInput
    users_complaints_target_user_idTousers?: UserCreateNestedOneWithoutComplaints_complaints_target_user_idTousersInput
    users_complaints_user_idTousers: UserCreateNestedOneWithoutComplaints_complaints_user_idTousersInput
  }

  export type complaintsUncheckedCreateInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutComplaintsNestedInput
    users_complaints_target_user_idTousers?: UserUpdateOneWithoutComplaints_complaints_target_user_idTousersNestedInput
    users_complaints_user_idTousers?: UserUpdateOneRequiredWithoutComplaints_complaints_user_idTousersNestedInput
  }

  export type complaintsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsCreateManyInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsCreateInput = {
    id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutConversationsInput
    users_conversations_participant1_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant1_idTousersInput
    users_conversations_participant2_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant2_idTousersInput
    messages?: MessageCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateInput = {
    id: string
    participant1_id: string
    participant2_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutConversationsNestedInput
    users_conversations_participant1_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant1_idTousersNestedInput
    users_conversations_participant2_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant2_idTousersNestedInput
    messages?: MessageUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsCreateManyInput = {
    id: string
    participant1_id: string
    participant2_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type conversationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtsCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    cities: citiesCreateNestedOneWithoutDistrictsInput
    listings?: ListingCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUncheckedCreateInput = {
    id: string
    name: string
    city_id: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUpdateOneRequiredWithoutDistrictsNestedInput
    listings?: ListingUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsCreateManyInput = {
    id: string
    name: string
    city_id: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type districtsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feature_definitionsCreateInput = {
    id: string
    key: string
    label: string
    sort_order?: number
    feature_groups: feature_groupsCreateNestedOneWithoutFeature_definitionsInput
  }

  export type feature_definitionsUncheckedCreateInput = {
    id: string
    group_id: string
    key: string
    label: string
    sort_order?: number
  }

  export type feature_definitionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    feature_groups?: feature_groupsUpdateOneRequiredWithoutFeature_definitionsNestedInput
  }

  export type feature_definitionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_definitionsCreateManyInput = {
    id: string
    group_id: string
    key: string
    label: string
    sort_order?: number
  }

  export type feature_definitionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_definitionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_groupsCreateInput = {
    id: string
    name: string
    label: string
    sort_order?: number
    feature_definitions?: feature_definitionsCreateNestedManyWithoutFeature_groupsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutFeature_groupsInput
  }

  export type feature_groupsUncheckedCreateInput = {
    id: string
    vehicle_type_id: string
    name: string
    label: string
    sort_order?: number
    feature_definitions?: feature_definitionsUncheckedCreateNestedManyWithoutFeature_groupsInput
  }

  export type feature_groupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    feature_definitions?: feature_definitionsUpdateManyWithoutFeature_groupsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutFeature_groupsNestedInput
  }

  export type feature_groupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    feature_definitions?: feature_definitionsUncheckedUpdateManyWithoutFeature_groupsNestedInput
  }

  export type feature_groupsCreateManyInput = {
    id: string
    vehicle_type_id: string
    name: string
    label: string
    sort_order?: number
  }

  export type feature_groupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_groupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_imagesCreateInput = {
    id: string
    url: string
    alt?: string | null
    sort_order?: number
    listings: ListingCreateNestedOneWithoutListing_imagesInput
  }

  export type listing_imagesUncheckedCreateInput = {
    id: string
    listing_id: string
    url: string
    alt?: string | null
    sort_order?: number
  }

  export type listing_imagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    listings?: ListingUpdateOneRequiredWithoutListing_imagesNestedInput
  }

  export type listing_imagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_imagesCreateManyInput = {
    id: string
    listing_id: string
    url: string
    alt?: string | null
    sort_order?: number
  }

  export type listing_imagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_imagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_propertiesCreateInput = {
    id: string
    key: string
    value: string
    type: $Enums.PropertyType
    listings: ListingCreateNestedOneWithoutListing_propertiesInput
  }

  export type listing_propertiesUncheckedCreateInput = {
    id: string
    listing_id: string
    key: string
    value: string
    type: $Enums.PropertyType
  }

  export type listing_propertiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    listings?: ListingUpdateOneRequiredWithoutListing_propertiesNestedInput
  }

  export type listing_propertiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type listing_propertiesCreateManyInput = {
    id: string
    listing_id: string
    key: string
    value: string
    type: $Enums.PropertyType
  }

  export type listing_propertiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type listing_propertiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type modelsCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutModelsInput
    brands: brandsCreateNestedOneWithoutModelsInput
    variants?: variantsCreateNestedManyWithoutModelsInput
  }

  export type modelsUncheckedCreateInput = {
    id: string
    name: string
    brand_id: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutModelsInput
    variants?: variantsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type modelsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutModelsNestedInput
    brands?: brandsUpdateOneRequiredWithoutModelsNestedInput
    variants?: variantsUpdateManyWithoutModelsNestedInput
  }

  export type modelsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutModelsNestedInput
    variants?: variantsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type modelsCreateManyInput = {
    id: string
    name: string
    brand_id: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type modelsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modelsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutVariantsInput
    models: modelsCreateNestedOneWithoutVariantsInput
  }

  export type variantsUncheckedCreateInput = {
    id: string
    name: string
    model_id: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutVariantsInput
  }

  export type variantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutVariantsNestedInput
    models?: modelsUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type variantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutVariantsNestedInput
  }

  export type variantsCreateManyInput = {
    id: string
    name: string
    model_id: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type variantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_typesCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingCreateNestedManyWithoutVehicle_typesInput
    categories: CategoryCreateNestedOneWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsUncheckedCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUpdateManyWithoutVehicle_typesNestedInput
    categories?: CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesCreateManyInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type vehicle_typesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicle_typesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ComplaintsListRelationFilter = {
    every?: complaintsWhereInput
    some?: complaintsWhereInput
    none?: complaintsWhereInput
  }

  export type ConversationsListRelationFilter = {
    every?: conversationsWhereInput
    some?: conversationsWhereInput
    none?: conversationsWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type ListingListRelationFilter = {
    every?: ListingWhereInput
    some?: ListingWhereInput
    none?: ListingWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type complaintsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    city?: SortOrder
    district?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    is_email_verified?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    lock_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    google_id?: SortOrder
    provider?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    login_attempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    city?: SortOrder
    district?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    is_email_verified?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    lock_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    google_id?: SortOrder
    provider?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    city?: SortOrder
    district?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    is_email_verified?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    lock_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    google_id?: SortOrder
    provider?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    login_attempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Category_attributesListRelationFilter = {
    every?: category_attributesWhereInput
    some?: category_attributesWhereInput
    none?: category_attributesWhereInput
  }

  export type Vehicle_typesListRelationFilter = {
    every?: vehicle_typesWhereInput
    some?: vehicle_typesWhereInput
    none?: vehicle_typesWhereInput
  }

  export type category_attributesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_typesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Listing_imagesListRelationFilter = {
    every?: listing_imagesWhereInput
    some?: listing_imagesWhereInput
    none?: listing_imagesWhereInput
  }

  export type Listing_propertiesListRelationFilter = {
    every?: listing_propertiesWhereInput
    some?: listing_propertiesWhereInput
    none?: listing_propertiesWhereInput
  }

  export type BrandsNullableRelationFilter = {
    is?: brandsWhereInput | null
    isNot?: brandsWhereInput | null
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CitiesNullableRelationFilter = {
    is?: citiesWhereInput | null
    isNot?: citiesWhereInput | null
  }

  export type DistrictsNullableRelationFilter = {
    is?: districtsWhereInput | null
    isNot?: districtsWhereInput | null
  }

  export type ModelsNullableRelationFilter = {
    is?: modelsWhereInput | null
    isNot?: modelsWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VariantsNullableRelationFilter = {
    is?: variantsWhereInput | null
    isNot?: variantsWhereInput | null
  }

  export type Vehicle_typesRelationFilter = {
    is?: vehicle_typesWhereInput
    isNot?: vehicle_typesWhereInput
  }

  export type listing_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type listing_propertiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    year?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_approved?: SortOrder
    is_pending?: SortOrder
    view_count?: SortOrder
    is_promoted?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    rejected_at?: SortOrder
    reject_reason?: SortOrder
    seller_name?: SortOrder
    seller_phone?: SortOrder
    seller_email?: SortOrder
    city_id?: SortOrder
    district_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    color?: SortOrder
    engine_power?: SortOrder
    engine_volume?: SortOrder
    fuel_type?: SortOrder
    is_exchangeable?: SortOrder
    km?: SortOrder
    license_plate?: SortOrder
    neighborhood_id?: SortOrder
    transmission?: SortOrder
    vehicle_condition?: SortOrder
  }

  export type ListingAvgOrderByAggregateInput = {
    price?: SortOrder
    year?: SortOrder
    view_count?: SortOrder
    km?: SortOrder
  }

  export type ListingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    year?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_approved?: SortOrder
    is_pending?: SortOrder
    view_count?: SortOrder
    is_promoted?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    rejected_at?: SortOrder
    reject_reason?: SortOrder
    seller_name?: SortOrder
    seller_phone?: SortOrder
    seller_email?: SortOrder
    city_id?: SortOrder
    district_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    color?: SortOrder
    engine_power?: SortOrder
    engine_volume?: SortOrder
    fuel_type?: SortOrder
    is_exchangeable?: SortOrder
    km?: SortOrder
    license_plate?: SortOrder
    neighborhood_id?: SortOrder
    transmission?: SortOrder
    vehicle_condition?: SortOrder
  }

  export type ListingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    year?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_approved?: SortOrder
    is_pending?: SortOrder
    view_count?: SortOrder
    is_promoted?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    rejected_at?: SortOrder
    reject_reason?: SortOrder
    seller_name?: SortOrder
    seller_phone?: SortOrder
    seller_email?: SortOrder
    city_id?: SortOrder
    district_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    color?: SortOrder
    engine_power?: SortOrder
    engine_volume?: SortOrder
    fuel_type?: SortOrder
    is_exchangeable?: SortOrder
    km?: SortOrder
    license_plate?: SortOrder
    neighborhood_id?: SortOrder
    transmission?: SortOrder
    vehicle_condition?: SortOrder
  }

  export type ListingSumOrderByAggregateInput = {
    price?: SortOrder
    year?: SortOrder
    view_count?: SortOrder
    km?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ConversationsRelationFilter = {
    is?: conversationsWhereInput
    isNot?: conversationsWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    is_edited?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    is_edited?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    is_edited?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ListingRelationFilter = {
    is?: ListingWhereInput
    isNot?: ListingWhereInput
  }

  export type FavoriteUser_idListing_idCompoundUniqueInput = {
    user_id: string
    listing_id: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    listing_id?: SortOrder
    created_at?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    listing_id?: SortOrder
    created_at?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    listing_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ModelsListRelationFilter = {
    every?: modelsWhereInput
    some?: modelsWhereInput
    none?: modelsWhereInput
  }

  export type modelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vehicle_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vehicle_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vehicle_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type Vehicle_typesNullableRelationFilter = {
    is?: vehicle_typesWhereInput | null
    isNot?: vehicle_typesWhereInput | null
  }

  export type category_attributesCategory_idVehicle_type_idKeyCompoundUniqueInput = {
    category_id: string
    vehicle_type_id: string
    key: string
  }

  export type category_attributesCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    is_required?: SortOrder
    is_filterable?: SortOrder
    sort_order?: SortOrder
    options?: SortOrder
  }

  export type category_attributesAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type category_attributesMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    is_required?: SortOrder
    is_filterable?: SortOrder
    sort_order?: SortOrder
  }

  export type category_attributesMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    vehicle_type_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    is_required?: SortOrder
    is_filterable?: SortOrder
    sort_order?: SortOrder
  }

  export type category_attributesSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type DistrictsListRelationFilter = {
    every?: districtsWhereInput
    some?: districtsWhereInput
    none?: districtsWhereInput
  }

  export type districtsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type citiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type citiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumComplaintTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintTarget | EnumComplaintTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintTargetFilter<$PrismaModel> | $Enums.ComplaintTarget
  }

  export type EnumComplaintCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintCategory | EnumComplaintCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintCategoryFilter<$PrismaModel> | $Enums.ComplaintCategory
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type ListingNullableRelationFilter = {
    is?: ListingWhereInput | null
    isNot?: ListingWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type complaintsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_type?: SortOrder
    target_user_id?: SortOrder
    target_listing_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    admin_response?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type complaintsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_type?: SortOrder
    target_user_id?: SortOrder
    target_listing_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    admin_response?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type complaintsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_type?: SortOrder
    target_user_id?: SortOrder
    target_listing_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    admin_response?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumComplaintTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintTarget | EnumComplaintTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintTargetWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintTargetFilter<$PrismaModel>
    _max?: NestedEnumComplaintTargetFilter<$PrismaModel>
  }

  export type EnumComplaintCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintCategory | EnumComplaintCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintCategoryFilter<$PrismaModel>
    _max?: NestedEnumComplaintCategoryFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type conversationsParticipant1_idParticipant2_idListing_idCompoundUniqueInput = {
    participant1_id: string
    participant2_id: string
    listing_id: string
  }

  export type conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    participant1_id?: SortOrder
    participant2_id?: SortOrder
    listing_id?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    participant1_id?: SortOrder
    participant2_id?: SortOrder
    listing_id?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    participant1_id?: SortOrder
    participant2_id?: SortOrder
    listing_id?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CitiesRelationFilter = {
    is?: citiesWhereInput
    isNot?: citiesWhereInput
  }

  export type districtsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type districtsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type districtsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Feature_groupsRelationFilter = {
    is?: feature_groupsWhereInput
    isNot?: feature_groupsWhereInput
  }

  export type feature_definitionsGroup_idKeyCompoundUniqueInput = {
    group_id: string
    key: string
  }

  export type feature_definitionsCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_definitionsAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type feature_definitionsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_definitionsMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_definitionsSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type Feature_definitionsListRelationFilter = {
    every?: feature_definitionsWhereInput
    some?: feature_definitionsWhereInput
    none?: feature_definitionsWhereInput
  }

  export type feature_definitionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type feature_groupsVehicle_type_idNameCompoundUniqueInput = {
    vehicle_type_id: string
    name: string
  }

  export type feature_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_type_id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_groupsAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type feature_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_type_id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_type_id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sort_order?: SortOrder
  }

  export type feature_groupsSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type listing_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sort_order?: SortOrder
  }

  export type listing_imagesAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type listing_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sort_order?: SortOrder
  }

  export type listing_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sort_order?: SortOrder
  }

  export type listing_imagesSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type listing_propertiesListing_idKeyCompoundUniqueInput = {
    listing_id: string
    key: string
  }

  export type listing_propertiesCountOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type listing_propertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type listing_propertiesMinOrderByAggregateInput = {
    id?: SortOrder
    listing_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type BrandsRelationFilter = {
    is?: brandsWhereInput
    isNot?: brandsWhereInput
  }

  export type VariantsListRelationFilter = {
    every?: variantsWhereInput
    some?: variantsWhereInput
    none?: variantsWhereInput
  }

  export type variantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type modelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type modelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type modelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ModelsRelationFilter = {
    is?: modelsWhereInput
    isNot?: modelsWhereInput
  }

  export type variantsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type variantsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type variantsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BrandsListRelationFilter = {
    every?: brandsWhereInput
    some?: brandsWhereInput
    none?: brandsWhereInput
  }

  export type Feature_groupsListRelationFilter = {
    every?: feature_groupsWhereInput
    some?: feature_groupsWhereInput
    none?: feature_groupsWhereInput
  }

  export type brandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type feature_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type vehicle_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type vehicle_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image_url?: SortOrder
  }

  export type complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_target_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_target_user_idTousersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_user_idTousersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant1_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant1_idTousersInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant2_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant2_idTousersInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUsersInput = {
    create?: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput> | FavoriteCreateWithoutUsersInput[] | FavoriteUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUsersInput | FavoriteCreateOrConnectWithoutUsersInput[]
    createMany?: FavoriteCreateManyUsersInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutUsersInput = {
    create?: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput> | ListingCreateWithoutUsersInput[] | ListingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUsersInput | ListingCreateOrConnectWithoutUsersInput[]
    createMany?: ListingCreateManyUsersInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUsersInput = {
    create?: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput> | MessageCreateWithoutUsersInput[] | MessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUsersInput | MessageCreateOrConnectWithoutUsersInput[]
    createMany?: MessageCreateManyUsersInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_target_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_target_user_idTousersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_user_idTousersInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant1_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant1_idTousersInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant2_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant2_idTousersInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput> | FavoriteCreateWithoutUsersInput[] | FavoriteUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUsersInput | FavoriteCreateOrConnectWithoutUsersInput[]
    createMany?: FavoriteCreateManyUsersInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput> | ListingCreateWithoutUsersInput[] | ListingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUsersInput | ListingCreateOrConnectWithoutUsersInput[]
    createMany?: ListingCreateManyUsersInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput> | MessageCreateWithoutUsersInput[] | MessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUsersInput | MessageCreateOrConnectWithoutUsersInput[]
    createMany?: MessageCreateManyUsersInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_target_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput | complaintsUpsertWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_target_user_idTousersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput | complaintsUpdateWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsers_complaints_target_user_idTousersInput | complaintsUpdateManyWithWhereWithoutUsers_complaints_target_user_idTousersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsers_complaints_user_idTousersInput | complaintsUpsertWithWhereUniqueWithoutUsers_complaints_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_user_idTousersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsers_complaints_user_idTousersInput | complaintsUpdateWithWhereUniqueWithoutUsers_complaints_user_idTousersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsers_complaints_user_idTousersInput | complaintsUpdateManyWithWhereWithoutUsers_complaints_user_idTousersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant1_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput | conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant1_idTousersInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput | conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutUsers_conversations_participant1_idTousersInput | conversationsUpdateManyWithWhereWithoutUsers_conversations_participant1_idTousersInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant2_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput | conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant2_idTousersInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput | conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutUsers_conversations_participant2_idTousersInput | conversationsUpdateManyWithWhereWithoutUsers_conversations_participant2_idTousersInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput> | FavoriteCreateWithoutUsersInput[] | FavoriteUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUsersInput | FavoriteCreateOrConnectWithoutUsersInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUsersInput | FavoriteUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FavoriteCreateManyUsersInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUsersInput | FavoriteUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUsersInput | FavoriteUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput> | ListingCreateWithoutUsersInput[] | ListingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUsersInput | ListingCreateOrConnectWithoutUsersInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutUsersInput | ListingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ListingCreateManyUsersInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutUsersInput | ListingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutUsersInput | ListingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput> | MessageCreateWithoutUsersInput[] | MessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUsersInput | MessageCreateOrConnectWithoutUsersInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUsersInput | MessageUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MessageCreateManyUsersInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUsersInput | MessageUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUsersInput | MessageUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUsersInput | NotificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUsersInput | NotificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUsersInput | NotificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_target_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput | complaintsUpsertWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_target_user_idTousersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput | complaintsUpdateWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsers_complaints_target_user_idTousersInput | complaintsUpdateManyWithWhereWithoutUsers_complaints_target_user_idTousersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput = {
    create?: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput> | complaintsCreateWithoutUsers_complaints_user_idTousersInput[] | complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput | complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutUsers_complaints_user_idTousersInput | complaintsUpsertWithWhereUniqueWithoutUsers_complaints_user_idTousersInput[]
    createMany?: complaintsCreateManyUsers_complaints_user_idTousersInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutUsers_complaints_user_idTousersInput | complaintsUpdateWithWhereUniqueWithoutUsers_complaints_user_idTousersInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutUsers_complaints_user_idTousersInput | complaintsUpdateManyWithWhereWithoutUsers_complaints_user_idTousersInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant1_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput | conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant1_idTousersInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput | conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutUsers_conversations_participant1_idTousersInput | conversationsUpdateManyWithWhereWithoutUsers_conversations_participant1_idTousersInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput = {
    create?: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput> | conversationsCreateWithoutUsers_conversations_participant2_idTousersInput[] | conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput | conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput | conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput[]
    createMany?: conversationsCreateManyUsers_conversations_participant2_idTousersInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput | conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutUsers_conversations_participant2_idTousersInput | conversationsUpdateManyWithWhereWithoutUsers_conversations_participant2_idTousersInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput> | FavoriteCreateWithoutUsersInput[] | FavoriteUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUsersInput | FavoriteCreateOrConnectWithoutUsersInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUsersInput | FavoriteUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FavoriteCreateManyUsersInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUsersInput | FavoriteUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUsersInput | FavoriteUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput> | ListingCreateWithoutUsersInput[] | ListingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUsersInput | ListingCreateOrConnectWithoutUsersInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutUsersInput | ListingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ListingCreateManyUsersInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutUsersInput | ListingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutUsersInput | ListingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput> | MessageCreateWithoutUsersInput[] | MessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUsersInput | MessageCreateOrConnectWithoutUsersInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUsersInput | MessageUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MessageCreateManyUsersInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUsersInput | MessageUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUsersInput | MessageUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUsersInput | NotificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUsersInput | NotificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUsersInput | NotificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type category_attributesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput> | category_attributesCreateWithoutCategoriesInput[] | category_attributesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutCategoriesInput | category_attributesCreateOrConnectWithoutCategoriesInput[]
    createMany?: category_attributesCreateManyCategoriesInputEnvelope
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput> | ListingCreateWithoutCategoriesInput[] | ListingUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoriesInput | ListingCreateOrConnectWithoutCategoriesInput[]
    createMany?: ListingCreateManyCategoriesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type vehicle_typesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput> | vehicle_typesCreateWithoutCategoriesInput[] | vehicle_typesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategoriesInput | vehicle_typesCreateOrConnectWithoutCategoriesInput[]
    createMany?: vehicle_typesCreateManyCategoriesInputEnvelope
    connect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
  }

  export type category_attributesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput> | category_attributesCreateWithoutCategoriesInput[] | category_attributesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutCategoriesInput | category_attributesCreateOrConnectWithoutCategoriesInput[]
    createMany?: category_attributesCreateManyCategoriesInputEnvelope
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput> | ListingCreateWithoutCategoriesInput[] | ListingUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoriesInput | ListingCreateOrConnectWithoutCategoriesInput[]
    createMany?: ListingCreateManyCategoriesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type vehicle_typesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput> | vehicle_typesCreateWithoutCategoriesInput[] | vehicle_typesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategoriesInput | vehicle_typesCreateOrConnectWithoutCategoriesInput[]
    createMany?: vehicle_typesCreateManyCategoriesInputEnvelope
    connect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
  }

  export type category_attributesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput> | category_attributesCreateWithoutCategoriesInput[] | category_attributesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutCategoriesInput | category_attributesCreateOrConnectWithoutCategoriesInput[]
    upsert?: category_attributesUpsertWithWhereUniqueWithoutCategoriesInput | category_attributesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: category_attributesCreateManyCategoriesInputEnvelope
    set?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    disconnect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    delete?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    update?: category_attributesUpdateWithWhereUniqueWithoutCategoriesInput | category_attributesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: category_attributesUpdateManyWithWhereWithoutCategoriesInput | category_attributesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput> | ListingCreateWithoutCategoriesInput[] | ListingUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoriesInput | ListingCreateOrConnectWithoutCategoriesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoriesInput | ListingUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ListingCreateManyCategoriesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoriesInput | ListingUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoriesInput | ListingUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type vehicle_typesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput> | vehicle_typesCreateWithoutCategoriesInput[] | vehicle_typesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategoriesInput | vehicle_typesCreateOrConnectWithoutCategoriesInput[]
    upsert?: vehicle_typesUpsertWithWhereUniqueWithoutCategoriesInput | vehicle_typesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: vehicle_typesCreateManyCategoriesInputEnvelope
    set?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    disconnect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    delete?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    connect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    update?: vehicle_typesUpdateWithWhereUniqueWithoutCategoriesInput | vehicle_typesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: vehicle_typesUpdateManyWithWhereWithoutCategoriesInput | vehicle_typesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: vehicle_typesScalarWhereInput | vehicle_typesScalarWhereInput[]
  }

  export type category_attributesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput> | category_attributesCreateWithoutCategoriesInput[] | category_attributesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutCategoriesInput | category_attributesCreateOrConnectWithoutCategoriesInput[]
    upsert?: category_attributesUpsertWithWhereUniqueWithoutCategoriesInput | category_attributesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: category_attributesCreateManyCategoriesInputEnvelope
    set?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    disconnect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    delete?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    update?: category_attributesUpdateWithWhereUniqueWithoutCategoriesInput | category_attributesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: category_attributesUpdateManyWithWhereWithoutCategoriesInput | category_attributesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput> | ListingCreateWithoutCategoriesInput[] | ListingUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoriesInput | ListingCreateOrConnectWithoutCategoriesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoriesInput | ListingUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ListingCreateManyCategoriesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoriesInput | ListingUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoriesInput | ListingUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type vehicle_typesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput> | vehicle_typesCreateWithoutCategoriesInput[] | vehicle_typesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategoriesInput | vehicle_typesCreateOrConnectWithoutCategoriesInput[]
    upsert?: vehicle_typesUpsertWithWhereUniqueWithoutCategoriesInput | vehicle_typesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: vehicle_typesCreateManyCategoriesInputEnvelope
    set?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    disconnect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    delete?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    connect?: vehicle_typesWhereUniqueInput | vehicle_typesWhereUniqueInput[]
    update?: vehicle_typesUpdateWithWhereUniqueWithoutCategoriesInput | vehicle_typesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: vehicle_typesUpdateManyWithWhereWithoutCategoriesInput | vehicle_typesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: vehicle_typesScalarWhereInput | vehicle_typesScalarWhereInput[]
  }

  export type complaintsCreateNestedManyWithoutListingsInput = {
    create?: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput> | complaintsCreateWithoutListingsInput[] | complaintsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutListingsInput | complaintsCreateOrConnectWithoutListingsInput[]
    createMany?: complaintsCreateManyListingsInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type conversationsCreateNestedManyWithoutListingsInput = {
    create?: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput> | conversationsCreateWithoutListingsInput[] | conversationsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutListingsInput | conversationsCreateOrConnectWithoutListingsInput[]
    createMany?: conversationsCreateManyListingsInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutListingsInput = {
    create?: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput> | FavoriteCreateWithoutListingsInput[] | FavoriteUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutListingsInput | FavoriteCreateOrConnectWithoutListingsInput[]
    createMany?: FavoriteCreateManyListingsInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type listing_imagesCreateNestedManyWithoutListingsInput = {
    create?: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput> | listing_imagesCreateWithoutListingsInput[] | listing_imagesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_imagesCreateOrConnectWithoutListingsInput | listing_imagesCreateOrConnectWithoutListingsInput[]
    createMany?: listing_imagesCreateManyListingsInputEnvelope
    connect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
  }

  export type listing_propertiesCreateNestedManyWithoutListingsInput = {
    create?: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput> | listing_propertiesCreateWithoutListingsInput[] | listing_propertiesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_propertiesCreateOrConnectWithoutListingsInput | listing_propertiesCreateOrConnectWithoutListingsInput[]
    createMany?: listing_propertiesCreateManyListingsInputEnvelope
    connect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutListingsInput = {
    create?: XOR<brandsCreateWithoutListingsInput, brandsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutListingsInput
    connect?: brandsWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutListingsInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    connect?: CategoryWhereUniqueInput
  }

  export type citiesCreateNestedOneWithoutListingsInput = {
    create?: XOR<citiesCreateWithoutListingsInput, citiesUncheckedCreateWithoutListingsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutListingsInput
    connect?: citiesWhereUniqueInput
  }

  export type districtsCreateNestedOneWithoutListingsInput = {
    create?: XOR<districtsCreateWithoutListingsInput, districtsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: districtsCreateOrConnectWithoutListingsInput
    connect?: districtsWhereUniqueInput
  }

  export type modelsCreateNestedOneWithoutListingsInput = {
    create?: XOR<modelsCreateWithoutListingsInput, modelsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutListingsInput
    connect?: modelsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutListingsInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    connect?: UserWhereUniqueInput
  }

  export type variantsCreateNestedOneWithoutListingsInput = {
    create?: XOR<variantsCreateWithoutListingsInput, variantsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: variantsCreateOrConnectWithoutListingsInput
    connect?: variantsWhereUniqueInput
  }

  export type vehicle_typesCreateNestedOneWithoutListingsInput = {
    create?: XOR<vehicle_typesCreateWithoutListingsInput, vehicle_typesUncheckedCreateWithoutListingsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutListingsInput
    connect?: vehicle_typesWhereUniqueInput
  }

  export type complaintsUncheckedCreateNestedManyWithoutListingsInput = {
    create?: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput> | complaintsCreateWithoutListingsInput[] | complaintsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutListingsInput | complaintsCreateOrConnectWithoutListingsInput[]
    createMany?: complaintsCreateManyListingsInputEnvelope
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
  }

  export type conversationsUncheckedCreateNestedManyWithoutListingsInput = {
    create?: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput> | conversationsCreateWithoutListingsInput[] | conversationsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutListingsInput | conversationsCreateOrConnectWithoutListingsInput[]
    createMany?: conversationsCreateManyListingsInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutListingsInput = {
    create?: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput> | FavoriteCreateWithoutListingsInput[] | FavoriteUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutListingsInput | FavoriteCreateOrConnectWithoutListingsInput[]
    createMany?: FavoriteCreateManyListingsInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type listing_imagesUncheckedCreateNestedManyWithoutListingsInput = {
    create?: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput> | listing_imagesCreateWithoutListingsInput[] | listing_imagesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_imagesCreateOrConnectWithoutListingsInput | listing_imagesCreateOrConnectWithoutListingsInput[]
    createMany?: listing_imagesCreateManyListingsInputEnvelope
    connect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
  }

  export type listing_propertiesUncheckedCreateNestedManyWithoutListingsInput = {
    create?: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput> | listing_propertiesCreateWithoutListingsInput[] | listing_propertiesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_propertiesCreateOrConnectWithoutListingsInput | listing_propertiesCreateOrConnectWithoutListingsInput[]
    createMany?: listing_propertiesCreateManyListingsInputEnvelope
    connect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type complaintsUpdateManyWithoutListingsNestedInput = {
    create?: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput> | complaintsCreateWithoutListingsInput[] | complaintsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutListingsInput | complaintsCreateOrConnectWithoutListingsInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutListingsInput | complaintsUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: complaintsCreateManyListingsInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutListingsInput | complaintsUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutListingsInput | complaintsUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type conversationsUpdateManyWithoutListingsNestedInput = {
    create?: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput> | conversationsCreateWithoutListingsInput[] | conversationsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutListingsInput | conversationsCreateOrConnectWithoutListingsInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutListingsInput | conversationsUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: conversationsCreateManyListingsInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutListingsInput | conversationsUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutListingsInput | conversationsUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutListingsNestedInput = {
    create?: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput> | FavoriteCreateWithoutListingsInput[] | FavoriteUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutListingsInput | FavoriteCreateOrConnectWithoutListingsInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutListingsInput | FavoriteUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: FavoriteCreateManyListingsInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutListingsInput | FavoriteUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutListingsInput | FavoriteUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type listing_imagesUpdateManyWithoutListingsNestedInput = {
    create?: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput> | listing_imagesCreateWithoutListingsInput[] | listing_imagesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_imagesCreateOrConnectWithoutListingsInput | listing_imagesCreateOrConnectWithoutListingsInput[]
    upsert?: listing_imagesUpsertWithWhereUniqueWithoutListingsInput | listing_imagesUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: listing_imagesCreateManyListingsInputEnvelope
    set?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    disconnect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    delete?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    connect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    update?: listing_imagesUpdateWithWhereUniqueWithoutListingsInput | listing_imagesUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: listing_imagesUpdateManyWithWhereWithoutListingsInput | listing_imagesUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: listing_imagesScalarWhereInput | listing_imagesScalarWhereInput[]
  }

  export type listing_propertiesUpdateManyWithoutListingsNestedInput = {
    create?: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput> | listing_propertiesCreateWithoutListingsInput[] | listing_propertiesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_propertiesCreateOrConnectWithoutListingsInput | listing_propertiesCreateOrConnectWithoutListingsInput[]
    upsert?: listing_propertiesUpsertWithWhereUniqueWithoutListingsInput | listing_propertiesUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: listing_propertiesCreateManyListingsInputEnvelope
    set?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    disconnect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    delete?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    connect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    update?: listing_propertiesUpdateWithWhereUniqueWithoutListingsInput | listing_propertiesUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: listing_propertiesUpdateManyWithWhereWithoutListingsInput | listing_propertiesUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: listing_propertiesScalarWhereInput | listing_propertiesScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutListingsNestedInput = {
    create?: XOR<brandsCreateWithoutListingsInput, brandsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutListingsInput
    upsert?: brandsUpsertWithoutListingsInput
    disconnect?: brandsWhereInput | boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutListingsInput, brandsUpdateWithoutListingsInput>, brandsUncheckedUpdateWithoutListingsInput>
  }

  export type CategoryUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    upsert?: CategoryUpsertWithoutListingsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutListingsInput, CategoryUpdateWithoutListingsInput>, CategoryUncheckedUpdateWithoutListingsInput>
  }

  export type citiesUpdateOneWithoutListingsNestedInput = {
    create?: XOR<citiesCreateWithoutListingsInput, citiesUncheckedCreateWithoutListingsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutListingsInput
    upsert?: citiesUpsertWithoutListingsInput
    disconnect?: citiesWhereInput | boolean
    delete?: citiesWhereInput | boolean
    connect?: citiesWhereUniqueInput
    update?: XOR<XOR<citiesUpdateToOneWithWhereWithoutListingsInput, citiesUpdateWithoutListingsInput>, citiesUncheckedUpdateWithoutListingsInput>
  }

  export type districtsUpdateOneWithoutListingsNestedInput = {
    create?: XOR<districtsCreateWithoutListingsInput, districtsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: districtsCreateOrConnectWithoutListingsInput
    upsert?: districtsUpsertWithoutListingsInput
    disconnect?: districtsWhereInput | boolean
    delete?: districtsWhereInput | boolean
    connect?: districtsWhereUniqueInput
    update?: XOR<XOR<districtsUpdateToOneWithWhereWithoutListingsInput, districtsUpdateWithoutListingsInput>, districtsUncheckedUpdateWithoutListingsInput>
  }

  export type modelsUpdateOneWithoutListingsNestedInput = {
    create?: XOR<modelsCreateWithoutListingsInput, modelsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutListingsInput
    upsert?: modelsUpsertWithoutListingsInput
    disconnect?: modelsWhereInput | boolean
    delete?: modelsWhereInput | boolean
    connect?: modelsWhereUniqueInput
    update?: XOR<XOR<modelsUpdateToOneWithWhereWithoutListingsInput, modelsUpdateWithoutListingsInput>, modelsUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    upsert?: UserUpsertWithoutListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListingsInput, UserUpdateWithoutListingsInput>, UserUncheckedUpdateWithoutListingsInput>
  }

  export type variantsUpdateOneWithoutListingsNestedInput = {
    create?: XOR<variantsCreateWithoutListingsInput, variantsUncheckedCreateWithoutListingsInput>
    connectOrCreate?: variantsCreateOrConnectWithoutListingsInput
    upsert?: variantsUpsertWithoutListingsInput
    disconnect?: variantsWhereInput | boolean
    delete?: variantsWhereInput | boolean
    connect?: variantsWhereUniqueInput
    update?: XOR<XOR<variantsUpdateToOneWithWhereWithoutListingsInput, variantsUpdateWithoutListingsInput>, variantsUncheckedUpdateWithoutListingsInput>
  }

  export type vehicle_typesUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutListingsInput, vehicle_typesUncheckedCreateWithoutListingsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutListingsInput
    upsert?: vehicle_typesUpsertWithoutListingsInput
    connect?: vehicle_typesWhereUniqueInput
    update?: XOR<XOR<vehicle_typesUpdateToOneWithWhereWithoutListingsInput, vehicle_typesUpdateWithoutListingsInput>, vehicle_typesUncheckedUpdateWithoutListingsInput>
  }

  export type complaintsUncheckedUpdateManyWithoutListingsNestedInput = {
    create?: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput> | complaintsCreateWithoutListingsInput[] | complaintsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: complaintsCreateOrConnectWithoutListingsInput | complaintsCreateOrConnectWithoutListingsInput[]
    upsert?: complaintsUpsertWithWhereUniqueWithoutListingsInput | complaintsUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: complaintsCreateManyListingsInputEnvelope
    set?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    disconnect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    delete?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    connect?: complaintsWhereUniqueInput | complaintsWhereUniqueInput[]
    update?: complaintsUpdateWithWhereUniqueWithoutListingsInput | complaintsUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: complaintsUpdateManyWithWhereWithoutListingsInput | complaintsUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
  }

  export type conversationsUncheckedUpdateManyWithoutListingsNestedInput = {
    create?: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput> | conversationsCreateWithoutListingsInput[] | conversationsUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutListingsInput | conversationsCreateOrConnectWithoutListingsInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutListingsInput | conversationsUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: conversationsCreateManyListingsInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutListingsInput | conversationsUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutListingsInput | conversationsUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutListingsNestedInput = {
    create?: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput> | FavoriteCreateWithoutListingsInput[] | FavoriteUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutListingsInput | FavoriteCreateOrConnectWithoutListingsInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutListingsInput | FavoriteUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: FavoriteCreateManyListingsInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutListingsInput | FavoriteUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutListingsInput | FavoriteUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type listing_imagesUncheckedUpdateManyWithoutListingsNestedInput = {
    create?: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput> | listing_imagesCreateWithoutListingsInput[] | listing_imagesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_imagesCreateOrConnectWithoutListingsInput | listing_imagesCreateOrConnectWithoutListingsInput[]
    upsert?: listing_imagesUpsertWithWhereUniqueWithoutListingsInput | listing_imagesUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: listing_imagesCreateManyListingsInputEnvelope
    set?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    disconnect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    delete?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    connect?: listing_imagesWhereUniqueInput | listing_imagesWhereUniqueInput[]
    update?: listing_imagesUpdateWithWhereUniqueWithoutListingsInput | listing_imagesUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: listing_imagesUpdateManyWithWhereWithoutListingsInput | listing_imagesUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: listing_imagesScalarWhereInput | listing_imagesScalarWhereInput[]
  }

  export type listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput = {
    create?: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput> | listing_propertiesCreateWithoutListingsInput[] | listing_propertiesUncheckedCreateWithoutListingsInput[]
    connectOrCreate?: listing_propertiesCreateOrConnectWithoutListingsInput | listing_propertiesCreateOrConnectWithoutListingsInput[]
    upsert?: listing_propertiesUpsertWithWhereUniqueWithoutListingsInput | listing_propertiesUpsertWithWhereUniqueWithoutListingsInput[]
    createMany?: listing_propertiesCreateManyListingsInputEnvelope
    set?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    disconnect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    delete?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    connect?: listing_propertiesWhereUniqueInput | listing_propertiesWhereUniqueInput[]
    update?: listing_propertiesUpdateWithWhereUniqueWithoutListingsInput | listing_propertiesUpdateWithWhereUniqueWithoutListingsInput[]
    updateMany?: listing_propertiesUpdateManyWithWhereWithoutListingsInput | listing_propertiesUpdateManyWithWhereWithoutListingsInput[]
    deleteMany?: listing_propertiesScalarWhereInput | listing_propertiesScalarWhereInput[]
  }

  export type conversationsCreateNestedOneWithoutMessagesInput = {
    create?: XOR<conversationsCreateWithoutMessagesInput, conversationsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutMessagesInput
    connect?: conversationsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type conversationsUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<conversationsCreateWithoutMessagesInput, conversationsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutMessagesInput
    upsert?: conversationsUpsertWithoutMessagesInput
    connect?: conversationsWhereUniqueInput
    update?: XOR<XOR<conversationsUpdateToOneWithWhereWithoutMessagesInput, conversationsUpdateWithoutMessagesInput>, conversationsUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ListingCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutFavoritesInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutFavoritesInput
    upsert?: ListingUpsertWithoutFavoritesInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutFavoritesInput, ListingUpdateWithoutFavoritesInput>, ListingUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type vehicle_typesCreateNestedOneWithoutBrandsInput = {
    create?: XOR<vehicle_typesCreateWithoutBrandsInput, vehicle_typesUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutBrandsInput
    connect?: vehicle_typesWhereUniqueInput
  }

  export type ListingCreateNestedManyWithoutBrandsInput = {
    create?: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput> | ListingCreateWithoutBrandsInput[] | ListingUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutBrandsInput | ListingCreateOrConnectWithoutBrandsInput[]
    createMany?: ListingCreateManyBrandsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type modelsCreateNestedManyWithoutBrandsInput = {
    create?: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput> | modelsCreateWithoutBrandsInput[] | modelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandsInput | modelsCreateOrConnectWithoutBrandsInput[]
    createMany?: modelsCreateManyBrandsInputEnvelope
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput> | ListingCreateWithoutBrandsInput[] | ListingUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutBrandsInput | ListingCreateOrConnectWithoutBrandsInput[]
    createMany?: ListingCreateManyBrandsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type modelsUncheckedCreateNestedManyWithoutBrandsInput = {
    create?: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput> | modelsCreateWithoutBrandsInput[] | modelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandsInput | modelsCreateOrConnectWithoutBrandsInput[]
    createMany?: modelsCreateManyBrandsInputEnvelope
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
  }

  export type vehicle_typesUpdateOneRequiredWithoutBrandsNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutBrandsInput, vehicle_typesUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutBrandsInput
    upsert?: vehicle_typesUpsertWithoutBrandsInput
    connect?: vehicle_typesWhereUniqueInput
    update?: XOR<XOR<vehicle_typesUpdateToOneWithWhereWithoutBrandsInput, vehicle_typesUpdateWithoutBrandsInput>, vehicle_typesUncheckedUpdateWithoutBrandsInput>
  }

  export type ListingUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput> | ListingCreateWithoutBrandsInput[] | ListingUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutBrandsInput | ListingCreateOrConnectWithoutBrandsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutBrandsInput | ListingUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: ListingCreateManyBrandsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutBrandsInput | ListingUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutBrandsInput | ListingUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type modelsUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput> | modelsCreateWithoutBrandsInput[] | modelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandsInput | modelsCreateOrConnectWithoutBrandsInput[]
    upsert?: modelsUpsertWithWhereUniqueWithoutBrandsInput | modelsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: modelsCreateManyBrandsInputEnvelope
    set?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    disconnect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    delete?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    update?: modelsUpdateWithWhereUniqueWithoutBrandsInput | modelsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: modelsUpdateManyWithWhereWithoutBrandsInput | modelsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: modelsScalarWhereInput | modelsScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput> | ListingCreateWithoutBrandsInput[] | ListingUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutBrandsInput | ListingCreateOrConnectWithoutBrandsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutBrandsInput | ListingUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: ListingCreateManyBrandsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutBrandsInput | ListingUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutBrandsInput | ListingUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type modelsUncheckedUpdateManyWithoutBrandsNestedInput = {
    create?: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput> | modelsCreateWithoutBrandsInput[] | modelsUncheckedCreateWithoutBrandsInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandsInput | modelsCreateOrConnectWithoutBrandsInput[]
    upsert?: modelsUpsertWithWhereUniqueWithoutBrandsInput | modelsUpsertWithWhereUniqueWithoutBrandsInput[]
    createMany?: modelsCreateManyBrandsInputEnvelope
    set?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    disconnect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    delete?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    update?: modelsUpdateWithWhereUniqueWithoutBrandsInput | modelsUpdateWithWhereUniqueWithoutBrandsInput[]
    updateMany?: modelsUpdateManyWithWhereWithoutBrandsInput | modelsUpdateManyWithWhereWithoutBrandsInput[]
    deleteMany?: modelsScalarWhereInput | modelsScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutCategory_attributesInput = {
    create?: XOR<CategoryCreateWithoutCategory_attributesInput, CategoryUncheckedCreateWithoutCategory_attributesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCategory_attributesInput
    connect?: CategoryWhereUniqueInput
  }

  export type vehicle_typesCreateNestedOneWithoutCategory_attributesInput = {
    create?: XOR<vehicle_typesCreateWithoutCategory_attributesInput, vehicle_typesUncheckedCreateWithoutCategory_attributesInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategory_attributesInput
    connect?: vehicle_typesWhereUniqueInput
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type CategoryUpdateOneRequiredWithoutCategory_attributesNestedInput = {
    create?: XOR<CategoryCreateWithoutCategory_attributesInput, CategoryUncheckedCreateWithoutCategory_attributesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCategory_attributesInput
    upsert?: CategoryUpsertWithoutCategory_attributesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCategory_attributesInput, CategoryUpdateWithoutCategory_attributesInput>, CategoryUncheckedUpdateWithoutCategory_attributesInput>
  }

  export type vehicle_typesUpdateOneWithoutCategory_attributesNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutCategory_attributesInput, vehicle_typesUncheckedCreateWithoutCategory_attributesInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCategory_attributesInput
    upsert?: vehicle_typesUpsertWithoutCategory_attributesInput
    disconnect?: vehicle_typesWhereInput | boolean
    delete?: vehicle_typesWhereInput | boolean
    connect?: vehicle_typesWhereUniqueInput
    update?: XOR<XOR<vehicle_typesUpdateToOneWithWhereWithoutCategory_attributesInput, vehicle_typesUpdateWithoutCategory_attributesInput>, vehicle_typesUncheckedUpdateWithoutCategory_attributesInput>
  }

  export type districtsCreateNestedManyWithoutCitiesInput = {
    create?: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput> | districtsCreateWithoutCitiesInput[] | districtsUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutCitiesInput | districtsCreateOrConnectWithoutCitiesInput[]
    createMany?: districtsCreateManyCitiesInputEnvelope
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutCitiesInput = {
    create?: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput> | ListingCreateWithoutCitiesInput[] | ListingUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCitiesInput | ListingCreateOrConnectWithoutCitiesInput[]
    createMany?: ListingCreateManyCitiesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type districtsUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput> | districtsCreateWithoutCitiesInput[] | districtsUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutCitiesInput | districtsCreateOrConnectWithoutCitiesInput[]
    createMany?: districtsCreateManyCitiesInputEnvelope
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput> | ListingCreateWithoutCitiesInput[] | ListingUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCitiesInput | ListingCreateOrConnectWithoutCitiesInput[]
    createMany?: ListingCreateManyCitiesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type districtsUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput> | districtsCreateWithoutCitiesInput[] | districtsUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutCitiesInput | districtsCreateOrConnectWithoutCitiesInput[]
    upsert?: districtsUpsertWithWhereUniqueWithoutCitiesInput | districtsUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: districtsCreateManyCitiesInputEnvelope
    set?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    disconnect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    delete?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    update?: districtsUpdateWithWhereUniqueWithoutCitiesInput | districtsUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: districtsUpdateManyWithWhereWithoutCitiesInput | districtsUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: districtsScalarWhereInput | districtsScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput> | ListingCreateWithoutCitiesInput[] | ListingUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCitiesInput | ListingCreateOrConnectWithoutCitiesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCitiesInput | ListingUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: ListingCreateManyCitiesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCitiesInput | ListingUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCitiesInput | ListingUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type districtsUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput> | districtsCreateWithoutCitiesInput[] | districtsUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutCitiesInput | districtsCreateOrConnectWithoutCitiesInput[]
    upsert?: districtsUpsertWithWhereUniqueWithoutCitiesInput | districtsUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: districtsCreateManyCitiesInputEnvelope
    set?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    disconnect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    delete?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    update?: districtsUpdateWithWhereUniqueWithoutCitiesInput | districtsUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: districtsUpdateManyWithWhereWithoutCitiesInput | districtsUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: districtsScalarWhereInput | districtsScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput> | ListingCreateWithoutCitiesInput[] | ListingUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCitiesInput | ListingCreateOrConnectWithoutCitiesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCitiesInput | ListingUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: ListingCreateManyCitiesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCitiesInput | ListingUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCitiesInput | ListingUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<ListingCreateWithoutComplaintsInput, ListingUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutComplaintsInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComplaints_complaints_target_user_idTousersInput = {
    create?: XOR<UserCreateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_target_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaints_complaints_target_user_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComplaints_complaints_user_idTousersInput = {
    create?: XOR<UserCreateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaints_complaints_user_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumComplaintTargetFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintTarget
  }

  export type EnumComplaintCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintCategory
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type ListingUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<ListingCreateWithoutComplaintsInput, ListingUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutComplaintsInput
    upsert?: ListingUpsertWithoutComplaintsInput
    disconnect?: ListingWhereInput | boolean
    delete?: ListingWhereInput | boolean
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutComplaintsInput, ListingUpdateWithoutComplaintsInput>, ListingUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateOneWithoutComplaints_complaints_target_user_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_target_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaints_complaints_target_user_idTousersInput
    upsert?: UserUpsertWithoutComplaints_complaints_target_user_idTousersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplaints_complaints_target_user_idTousersInput, UserUpdateWithoutComplaints_complaints_target_user_idTousersInput>, UserUncheckedUpdateWithoutComplaints_complaints_target_user_idTousersInput>
  }

  export type UserUpdateOneRequiredWithoutComplaints_complaints_user_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaints_complaints_user_idTousersInput
    upsert?: UserUpsertWithoutComplaints_complaints_user_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplaints_complaints_user_idTousersInput, UserUpdateWithoutComplaints_complaints_user_idTousersInput>, UserUncheckedUpdateWithoutComplaints_complaints_user_idTousersInput>
  }

  export type ListingCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutConversationsInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversations_conversations_participant1_idTousersInput = {
    create?: XOR<UserCreateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant1_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversations_conversations_participant1_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversations_conversations_participant2_idTousersInput = {
    create?: XOR<UserCreateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant2_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversations_conversations_participant2_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationsInput = {
    create?: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput> | MessageCreateWithoutConversationsInput[] | MessageUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationsInput | MessageCreateOrConnectWithoutConversationsInput[]
    createMany?: MessageCreateManyConversationsInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationsInput = {
    create?: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput> | MessageCreateWithoutConversationsInput[] | MessageUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationsInput | MessageCreateOrConnectWithoutConversationsInput[]
    createMany?: MessageCreateManyConversationsInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ListingUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutConversationsInput
    upsert?: ListingUpsertWithoutConversationsInput
    disconnect?: ListingWhereInput | boolean
    delete?: ListingWhereInput | boolean
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutConversationsInput, ListingUpdateWithoutConversationsInput>, ListingUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutConversations_conversations_participant1_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant1_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversations_conversations_participant1_idTousersInput
    upsert?: UserUpsertWithoutConversations_conversations_participant1_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversations_conversations_participant1_idTousersInput, UserUpdateWithoutConversations_conversations_participant1_idTousersInput>, UserUncheckedUpdateWithoutConversations_conversations_participant1_idTousersInput>
  }

  export type UserUpdateOneRequiredWithoutConversations_conversations_participant2_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant2_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversations_conversations_participant2_idTousersInput
    upsert?: UserUpsertWithoutConversations_conversations_participant2_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversations_conversations_participant2_idTousersInput, UserUpdateWithoutConversations_conversations_participant2_idTousersInput>, UserUncheckedUpdateWithoutConversations_conversations_participant2_idTousersInput>
  }

  export type MessageUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput> | MessageCreateWithoutConversationsInput[] | MessageUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationsInput | MessageCreateOrConnectWithoutConversationsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationsInput | MessageUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: MessageCreateManyConversationsInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationsInput | MessageUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationsInput | MessageUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput> | MessageCreateWithoutConversationsInput[] | MessageUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationsInput | MessageCreateOrConnectWithoutConversationsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationsInput | MessageUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: MessageCreateManyConversationsInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationsInput | MessageUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationsInput | MessageUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type citiesCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<citiesCreateWithoutDistrictsInput, citiesUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutDistrictsInput
    connect?: citiesWhereUniqueInput
  }

  export type ListingCreateNestedManyWithoutDistrictsInput = {
    create?: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput> | ListingCreateWithoutDistrictsInput[] | ListingUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutDistrictsInput | ListingCreateOrConnectWithoutDistrictsInput[]
    createMany?: ListingCreateManyDistrictsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutDistrictsInput = {
    create?: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput> | ListingCreateWithoutDistrictsInput[] | ListingUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutDistrictsInput | ListingCreateOrConnectWithoutDistrictsInput[]
    createMany?: ListingCreateManyDistrictsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type citiesUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<citiesCreateWithoutDistrictsInput, citiesUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: citiesCreateOrConnectWithoutDistrictsInput
    upsert?: citiesUpsertWithoutDistrictsInput
    connect?: citiesWhereUniqueInput
    update?: XOR<XOR<citiesUpdateToOneWithWhereWithoutDistrictsInput, citiesUpdateWithoutDistrictsInput>, citiesUncheckedUpdateWithoutDistrictsInput>
  }

  export type ListingUpdateManyWithoutDistrictsNestedInput = {
    create?: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput> | ListingCreateWithoutDistrictsInput[] | ListingUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutDistrictsInput | ListingCreateOrConnectWithoutDistrictsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutDistrictsInput | ListingUpsertWithWhereUniqueWithoutDistrictsInput[]
    createMany?: ListingCreateManyDistrictsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutDistrictsInput | ListingUpdateWithWhereUniqueWithoutDistrictsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutDistrictsInput | ListingUpdateManyWithWhereWithoutDistrictsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutDistrictsNestedInput = {
    create?: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput> | ListingCreateWithoutDistrictsInput[] | ListingUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutDistrictsInput | ListingCreateOrConnectWithoutDistrictsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutDistrictsInput | ListingUpsertWithWhereUniqueWithoutDistrictsInput[]
    createMany?: ListingCreateManyDistrictsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutDistrictsInput | ListingUpdateWithWhereUniqueWithoutDistrictsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutDistrictsInput | ListingUpdateManyWithWhereWithoutDistrictsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type feature_groupsCreateNestedOneWithoutFeature_definitionsInput = {
    create?: XOR<feature_groupsCreateWithoutFeature_definitionsInput, feature_groupsUncheckedCreateWithoutFeature_definitionsInput>
    connectOrCreate?: feature_groupsCreateOrConnectWithoutFeature_definitionsInput
    connect?: feature_groupsWhereUniqueInput
  }

  export type feature_groupsUpdateOneRequiredWithoutFeature_definitionsNestedInput = {
    create?: XOR<feature_groupsCreateWithoutFeature_definitionsInput, feature_groupsUncheckedCreateWithoutFeature_definitionsInput>
    connectOrCreate?: feature_groupsCreateOrConnectWithoutFeature_definitionsInput
    upsert?: feature_groupsUpsertWithoutFeature_definitionsInput
    connect?: feature_groupsWhereUniqueInput
    update?: XOR<XOR<feature_groupsUpdateToOneWithWhereWithoutFeature_definitionsInput, feature_groupsUpdateWithoutFeature_definitionsInput>, feature_groupsUncheckedUpdateWithoutFeature_definitionsInput>
  }

  export type feature_definitionsCreateNestedManyWithoutFeature_groupsInput = {
    create?: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput> | feature_definitionsCreateWithoutFeature_groupsInput[] | feature_definitionsUncheckedCreateWithoutFeature_groupsInput[]
    connectOrCreate?: feature_definitionsCreateOrConnectWithoutFeature_groupsInput | feature_definitionsCreateOrConnectWithoutFeature_groupsInput[]
    createMany?: feature_definitionsCreateManyFeature_groupsInputEnvelope
    connect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
  }

  export type vehicle_typesCreateNestedOneWithoutFeature_groupsInput = {
    create?: XOR<vehicle_typesCreateWithoutFeature_groupsInput, vehicle_typesUncheckedCreateWithoutFeature_groupsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutFeature_groupsInput
    connect?: vehicle_typesWhereUniqueInput
  }

  export type feature_definitionsUncheckedCreateNestedManyWithoutFeature_groupsInput = {
    create?: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput> | feature_definitionsCreateWithoutFeature_groupsInput[] | feature_definitionsUncheckedCreateWithoutFeature_groupsInput[]
    connectOrCreate?: feature_definitionsCreateOrConnectWithoutFeature_groupsInput | feature_definitionsCreateOrConnectWithoutFeature_groupsInput[]
    createMany?: feature_definitionsCreateManyFeature_groupsInputEnvelope
    connect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
  }

  export type feature_definitionsUpdateManyWithoutFeature_groupsNestedInput = {
    create?: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput> | feature_definitionsCreateWithoutFeature_groupsInput[] | feature_definitionsUncheckedCreateWithoutFeature_groupsInput[]
    connectOrCreate?: feature_definitionsCreateOrConnectWithoutFeature_groupsInput | feature_definitionsCreateOrConnectWithoutFeature_groupsInput[]
    upsert?: feature_definitionsUpsertWithWhereUniqueWithoutFeature_groupsInput | feature_definitionsUpsertWithWhereUniqueWithoutFeature_groupsInput[]
    createMany?: feature_definitionsCreateManyFeature_groupsInputEnvelope
    set?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    disconnect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    delete?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    connect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    update?: feature_definitionsUpdateWithWhereUniqueWithoutFeature_groupsInput | feature_definitionsUpdateWithWhereUniqueWithoutFeature_groupsInput[]
    updateMany?: feature_definitionsUpdateManyWithWhereWithoutFeature_groupsInput | feature_definitionsUpdateManyWithWhereWithoutFeature_groupsInput[]
    deleteMany?: feature_definitionsScalarWhereInput | feature_definitionsScalarWhereInput[]
  }

  export type vehicle_typesUpdateOneRequiredWithoutFeature_groupsNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutFeature_groupsInput, vehicle_typesUncheckedCreateWithoutFeature_groupsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutFeature_groupsInput
    upsert?: vehicle_typesUpsertWithoutFeature_groupsInput
    connect?: vehicle_typesWhereUniqueInput
    update?: XOR<XOR<vehicle_typesUpdateToOneWithWhereWithoutFeature_groupsInput, vehicle_typesUpdateWithoutFeature_groupsInput>, vehicle_typesUncheckedUpdateWithoutFeature_groupsInput>
  }

  export type feature_definitionsUncheckedUpdateManyWithoutFeature_groupsNestedInput = {
    create?: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput> | feature_definitionsCreateWithoutFeature_groupsInput[] | feature_definitionsUncheckedCreateWithoutFeature_groupsInput[]
    connectOrCreate?: feature_definitionsCreateOrConnectWithoutFeature_groupsInput | feature_definitionsCreateOrConnectWithoutFeature_groupsInput[]
    upsert?: feature_definitionsUpsertWithWhereUniqueWithoutFeature_groupsInput | feature_definitionsUpsertWithWhereUniqueWithoutFeature_groupsInput[]
    createMany?: feature_definitionsCreateManyFeature_groupsInputEnvelope
    set?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    disconnect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    delete?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    connect?: feature_definitionsWhereUniqueInput | feature_definitionsWhereUniqueInput[]
    update?: feature_definitionsUpdateWithWhereUniqueWithoutFeature_groupsInput | feature_definitionsUpdateWithWhereUniqueWithoutFeature_groupsInput[]
    updateMany?: feature_definitionsUpdateManyWithWhereWithoutFeature_groupsInput | feature_definitionsUpdateManyWithWhereWithoutFeature_groupsInput[]
    deleteMany?: feature_definitionsScalarWhereInput | feature_definitionsScalarWhereInput[]
  }

  export type ListingCreateNestedOneWithoutListing_imagesInput = {
    create?: XOR<ListingCreateWithoutListing_imagesInput, ListingUncheckedCreateWithoutListing_imagesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutListing_imagesInput
    connect?: ListingWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutListing_imagesNestedInput = {
    create?: XOR<ListingCreateWithoutListing_imagesInput, ListingUncheckedCreateWithoutListing_imagesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutListing_imagesInput
    upsert?: ListingUpsertWithoutListing_imagesInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutListing_imagesInput, ListingUpdateWithoutListing_imagesInput>, ListingUncheckedUpdateWithoutListing_imagesInput>
  }

  export type ListingCreateNestedOneWithoutListing_propertiesInput = {
    create?: XOR<ListingCreateWithoutListing_propertiesInput, ListingUncheckedCreateWithoutListing_propertiesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutListing_propertiesInput
    connect?: ListingWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutListing_propertiesNestedInput = {
    create?: XOR<ListingCreateWithoutListing_propertiesInput, ListingUncheckedCreateWithoutListing_propertiesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutListing_propertiesInput
    upsert?: ListingUpsertWithoutListing_propertiesInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutListing_propertiesInput, ListingUpdateWithoutListing_propertiesInput>, ListingUncheckedUpdateWithoutListing_propertiesInput>
  }

  export type ListingCreateNestedManyWithoutModelsInput = {
    create?: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput> | ListingCreateWithoutModelsInput[] | ListingUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutModelsInput | ListingCreateOrConnectWithoutModelsInput[]
    createMany?: ListingCreateManyModelsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutModelsInput = {
    create?: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutModelsInput
    connect?: brandsWhereUniqueInput
  }

  export type variantsCreateNestedManyWithoutModelsInput = {
    create?: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput> | variantsCreateWithoutModelsInput[] | variantsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelsInput | variantsCreateOrConnectWithoutModelsInput[]
    createMany?: variantsCreateManyModelsInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutModelsInput = {
    create?: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput> | ListingCreateWithoutModelsInput[] | ListingUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutModelsInput | ListingCreateOrConnectWithoutModelsInput[]
    createMany?: ListingCreateManyModelsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type variantsUncheckedCreateNestedManyWithoutModelsInput = {
    create?: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput> | variantsCreateWithoutModelsInput[] | variantsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelsInput | variantsCreateOrConnectWithoutModelsInput[]
    createMany?: variantsCreateManyModelsInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type ListingUpdateManyWithoutModelsNestedInput = {
    create?: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput> | ListingCreateWithoutModelsInput[] | ListingUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutModelsInput | ListingCreateOrConnectWithoutModelsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutModelsInput | ListingUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: ListingCreateManyModelsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutModelsInput | ListingUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutModelsInput | ListingUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type brandsUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutModelsInput
    upsert?: brandsUpsertWithoutModelsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutModelsInput, brandsUpdateWithoutModelsInput>, brandsUncheckedUpdateWithoutModelsInput>
  }

  export type variantsUpdateManyWithoutModelsNestedInput = {
    create?: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput> | variantsCreateWithoutModelsInput[] | variantsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelsInput | variantsCreateOrConnectWithoutModelsInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutModelsInput | variantsUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: variantsCreateManyModelsInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutModelsInput | variantsUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutModelsInput | variantsUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutModelsNestedInput = {
    create?: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput> | ListingCreateWithoutModelsInput[] | ListingUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutModelsInput | ListingCreateOrConnectWithoutModelsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutModelsInput | ListingUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: ListingCreateManyModelsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutModelsInput | ListingUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutModelsInput | ListingUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type variantsUncheckedUpdateManyWithoutModelsNestedInput = {
    create?: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput> | variantsCreateWithoutModelsInput[] | variantsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelsInput | variantsCreateOrConnectWithoutModelsInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutModelsInput | variantsUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: variantsCreateManyModelsInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutModelsInput | variantsUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutModelsInput | variantsUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type ListingCreateNestedManyWithoutVariantsInput = {
    create?: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput> | ListingCreateWithoutVariantsInput[] | ListingUncheckedCreateWithoutVariantsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVariantsInput | ListingCreateOrConnectWithoutVariantsInput[]
    createMany?: ListingCreateManyVariantsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type modelsCreateNestedOneWithoutVariantsInput = {
    create?: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVariantsInput
    connect?: modelsWhereUniqueInput
  }

  export type ListingUncheckedCreateNestedManyWithoutVariantsInput = {
    create?: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput> | ListingCreateWithoutVariantsInput[] | ListingUncheckedCreateWithoutVariantsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVariantsInput | ListingCreateOrConnectWithoutVariantsInput[]
    createMany?: ListingCreateManyVariantsInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUpdateManyWithoutVariantsNestedInput = {
    create?: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput> | ListingCreateWithoutVariantsInput[] | ListingUncheckedCreateWithoutVariantsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVariantsInput | ListingCreateOrConnectWithoutVariantsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutVariantsInput | ListingUpsertWithWhereUniqueWithoutVariantsInput[]
    createMany?: ListingCreateManyVariantsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutVariantsInput | ListingUpdateWithWhereUniqueWithoutVariantsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutVariantsInput | ListingUpdateManyWithWhereWithoutVariantsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type modelsUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVariantsInput
    upsert?: modelsUpsertWithoutVariantsInput
    connect?: modelsWhereUniqueInput
    update?: XOR<XOR<modelsUpdateToOneWithWhereWithoutVariantsInput, modelsUpdateWithoutVariantsInput>, modelsUncheckedUpdateWithoutVariantsInput>
  }

  export type ListingUncheckedUpdateManyWithoutVariantsNestedInput = {
    create?: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput> | ListingCreateWithoutVariantsInput[] | ListingUncheckedCreateWithoutVariantsInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVariantsInput | ListingCreateOrConnectWithoutVariantsInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutVariantsInput | ListingUpsertWithWhereUniqueWithoutVariantsInput[]
    createMany?: ListingCreateManyVariantsInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutVariantsInput | ListingUpdateWithWhereUniqueWithoutVariantsInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutVariantsInput | ListingUpdateManyWithWhereWithoutVariantsInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type brandsCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput> | brandsCreateWithoutVehicle_typesInput[] | brandsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutVehicle_typesInput | brandsCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: brandsCreateManyVehicle_typesInputEnvelope
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type category_attributesCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput> | category_attributesCreateWithoutVehicle_typesInput[] | category_attributesUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutVehicle_typesInput | category_attributesCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: category_attributesCreateManyVehicle_typesInputEnvelope
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
  }

  export type feature_groupsCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput> | feature_groupsCreateWithoutVehicle_typesInput[] | feature_groupsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: feature_groupsCreateOrConnectWithoutVehicle_typesInput | feature_groupsCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: feature_groupsCreateManyVehicle_typesInputEnvelope
    connect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput> | ListingCreateWithoutVehicle_typesInput[] | ListingUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVehicle_typesInput | ListingCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: ListingCreateManyVehicle_typesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutVehicle_typesInput = {
    create?: XOR<CategoryCreateWithoutVehicle_typesInput, CategoryUncheckedCreateWithoutVehicle_typesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutVehicle_typesInput
    connect?: CategoryWhereUniqueInput
  }

  export type brandsUncheckedCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput> | brandsCreateWithoutVehicle_typesInput[] | brandsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutVehicle_typesInput | brandsCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: brandsCreateManyVehicle_typesInputEnvelope
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput> | category_attributesCreateWithoutVehicle_typesInput[] | category_attributesUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutVehicle_typesInput | category_attributesCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: category_attributesCreateManyVehicle_typesInputEnvelope
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
  }

  export type feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput> | feature_groupsCreateWithoutVehicle_typesInput[] | feature_groupsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: feature_groupsCreateOrConnectWithoutVehicle_typesInput | feature_groupsCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: feature_groupsCreateManyVehicle_typesInputEnvelope
    connect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput> | ListingCreateWithoutVehicle_typesInput[] | ListingUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVehicle_typesInput | ListingCreateOrConnectWithoutVehicle_typesInput[]
    createMany?: ListingCreateManyVehicle_typesInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type brandsUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput> | brandsCreateWithoutVehicle_typesInput[] | brandsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutVehicle_typesInput | brandsCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutVehicle_typesInput | brandsUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: brandsCreateManyVehicle_typesInputEnvelope
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutVehicle_typesInput | brandsUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutVehicle_typesInput | brandsUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type category_attributesUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput> | category_attributesCreateWithoutVehicle_typesInput[] | category_attributesUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutVehicle_typesInput | category_attributesCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: category_attributesUpsertWithWhereUniqueWithoutVehicle_typesInput | category_attributesUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: category_attributesCreateManyVehicle_typesInputEnvelope
    set?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    disconnect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    delete?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    update?: category_attributesUpdateWithWhereUniqueWithoutVehicle_typesInput | category_attributesUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: category_attributesUpdateManyWithWhereWithoutVehicle_typesInput | category_attributesUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
  }

  export type feature_groupsUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput> | feature_groupsCreateWithoutVehicle_typesInput[] | feature_groupsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: feature_groupsCreateOrConnectWithoutVehicle_typesInput | feature_groupsCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: feature_groupsUpsertWithWhereUniqueWithoutVehicle_typesInput | feature_groupsUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: feature_groupsCreateManyVehicle_typesInputEnvelope
    set?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    disconnect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    delete?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    connect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    update?: feature_groupsUpdateWithWhereUniqueWithoutVehicle_typesInput | feature_groupsUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: feature_groupsUpdateManyWithWhereWithoutVehicle_typesInput | feature_groupsUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: feature_groupsScalarWhereInput | feature_groupsScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput> | ListingCreateWithoutVehicle_typesInput[] | ListingUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVehicle_typesInput | ListingCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutVehicle_typesInput | ListingUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: ListingCreateManyVehicle_typesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutVehicle_typesInput | ListingUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutVehicle_typesInput | ListingUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput = {
    create?: XOR<CategoryCreateWithoutVehicle_typesInput, CategoryUncheckedCreateWithoutVehicle_typesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutVehicle_typesInput
    upsert?: CategoryUpsertWithoutVehicle_typesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutVehicle_typesInput, CategoryUpdateWithoutVehicle_typesInput>, CategoryUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput> | brandsCreateWithoutVehicle_typesInput[] | brandsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutVehicle_typesInput | brandsCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutVehicle_typesInput | brandsUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: brandsCreateManyVehicle_typesInputEnvelope
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutVehicle_typesInput | brandsUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutVehicle_typesInput | brandsUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput> | category_attributesCreateWithoutVehicle_typesInput[] | category_attributesUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: category_attributesCreateOrConnectWithoutVehicle_typesInput | category_attributesCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: category_attributesUpsertWithWhereUniqueWithoutVehicle_typesInput | category_attributesUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: category_attributesCreateManyVehicle_typesInputEnvelope
    set?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    disconnect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    delete?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    connect?: category_attributesWhereUniqueInput | category_attributesWhereUniqueInput[]
    update?: category_attributesUpdateWithWhereUniqueWithoutVehicle_typesInput | category_attributesUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: category_attributesUpdateManyWithWhereWithoutVehicle_typesInput | category_attributesUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
  }

  export type feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput> | feature_groupsCreateWithoutVehicle_typesInput[] | feature_groupsUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: feature_groupsCreateOrConnectWithoutVehicle_typesInput | feature_groupsCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: feature_groupsUpsertWithWhereUniqueWithoutVehicle_typesInput | feature_groupsUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: feature_groupsCreateManyVehicle_typesInputEnvelope
    set?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    disconnect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    delete?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    connect?: feature_groupsWhereUniqueInput | feature_groupsWhereUniqueInput[]
    update?: feature_groupsUpdateWithWhereUniqueWithoutVehicle_typesInput | feature_groupsUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: feature_groupsUpdateManyWithWhereWithoutVehicle_typesInput | feature_groupsUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: feature_groupsScalarWhereInput | feature_groupsScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput> | ListingCreateWithoutVehicle_typesInput[] | ListingUncheckedCreateWithoutVehicle_typesInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutVehicle_typesInput | ListingCreateOrConnectWithoutVehicle_typesInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutVehicle_typesInput | ListingUpsertWithWhereUniqueWithoutVehicle_typesInput[]
    createMany?: ListingCreateManyVehicle_typesInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutVehicle_typesInput | ListingUpdateWithWhereUniqueWithoutVehicle_typesInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutVehicle_typesInput | ListingUpdateManyWithWhereWithoutVehicle_typesInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumComplaintTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintTarget | EnumComplaintTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintTargetFilter<$PrismaModel> | $Enums.ComplaintTarget
  }

  export type NestedEnumComplaintCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintCategory | EnumComplaintCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintCategoryFilter<$PrismaModel> | $Enums.ComplaintCategory
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumComplaintTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintTarget | EnumComplaintTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintTarget[] | ListEnumComplaintTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintTargetWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintTargetFilter<$PrismaModel>
    _max?: NestedEnumComplaintTargetFilter<$PrismaModel>
  }

  export type NestedEnumComplaintCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintCategory | EnumComplaintCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintCategory[] | ListEnumComplaintCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintCategoryFilter<$PrismaModel>
    _max?: NestedEnumComplaintCategoryFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type complaintsCreateWithoutUsers_complaints_target_user_idTousersInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutComplaintsInput
    users_complaints_user_idTousers: UserCreateNestedOneWithoutComplaints_complaints_user_idTousersInput
  }

  export type complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsCreateOrConnectWithoutUsers_complaints_target_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput>
  }

  export type complaintsCreateManyUsers_complaints_target_user_idTousersInputEnvelope = {
    data: complaintsCreateManyUsers_complaints_target_user_idTousersInput | complaintsCreateManyUsers_complaints_target_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type complaintsCreateWithoutUsers_complaints_user_idTousersInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutComplaintsInput
    users_complaints_target_user_idTousers?: UserCreateNestedOneWithoutComplaints_complaints_target_user_idTousersInput
  }

  export type complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsCreateOrConnectWithoutUsers_complaints_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput>
  }

  export type complaintsCreateManyUsers_complaints_user_idTousersInputEnvelope = {
    data: complaintsCreateManyUsers_complaints_user_idTousersInput | complaintsCreateManyUsers_complaints_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type conversationsCreateWithoutUsers_conversations_participant1_idTousersInput = {
    id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutConversationsInput
    users_conversations_participant2_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant2_idTousersInput
    messages?: MessageCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput = {
    id: string
    participant2_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutUsers_conversations_participant1_idTousersInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput>
  }

  export type conversationsCreateManyUsers_conversations_participant1_idTousersInputEnvelope = {
    data: conversationsCreateManyUsers_conversations_participant1_idTousersInput | conversationsCreateManyUsers_conversations_participant1_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type conversationsCreateWithoutUsers_conversations_participant2_idTousersInput = {
    id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutConversationsInput
    users_conversations_participant1_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant1_idTousersInput
    messages?: MessageCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput = {
    id: string
    participant1_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutUsers_conversations_participant2_idTousersInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput>
  }

  export type conversationsCreateManyUsers_conversations_participant2_idTousersInputEnvelope = {
    data: conversationsCreateManyUsers_conversations_participant2_idTousersInput | conversationsCreateManyUsers_conversations_participant2_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    listings: ListingCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUsersInput = {
    id?: string
    listing_id: string
    created_at?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUsersInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput>
  }

  export type FavoriteCreateManyUsersInputEnvelope = {
    data: FavoriteCreateManyUsersInput | FavoriteCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutUsersInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutUsersInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutUsersInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput>
  }

  export type ListingCreateManyUsersInputEnvelope = {
    data: ListingCreateManyUsersInput | ListingCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUsersInput = {
    id?: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
    conversations: conversationsCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUsersInput = {
    id?: string
    conversation_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessageCreateOrConnectWithoutUsersInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput>
  }

  export type MessageCreateManyUsersInputEnvelope = {
    data: MessageCreateManyUsersInput | MessageCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUsersInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUsersInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput>
  }

  export type NotificationCreateManyUsersInputEnvelope = {
    data: NotificationCreateManyUsersInput | NotificationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type complaintsUpsertWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedUpdateWithoutUsers_complaints_target_user_idTousersInput>
    create: XOR<complaintsCreateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_target_user_idTousersInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutUsers_complaints_target_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutUsers_complaints_target_user_idTousersInput, complaintsUncheckedUpdateWithoutUsers_complaints_target_user_idTousersInput>
  }

  export type complaintsUpdateManyWithWhereWithoutUsers_complaints_target_user_idTousersInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersInput>
  }

  export type complaintsScalarWhereInput = {
    AND?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    OR?: complaintsScalarWhereInput[]
    NOT?: complaintsScalarWhereInput | complaintsScalarWhereInput[]
    id?: StringFilter<"complaints"> | string
    user_id?: StringFilter<"complaints"> | string
    target_type?: EnumComplaintTargetFilter<"complaints"> | $Enums.ComplaintTarget
    target_user_id?: StringNullableFilter<"complaints"> | string | null
    target_listing_id?: StringNullableFilter<"complaints"> | string | null
    category?: EnumComplaintCategoryFilter<"complaints"> | $Enums.ComplaintCategory
    description?: StringNullableFilter<"complaints"> | string | null
    status?: EnumComplaintStatusFilter<"complaints"> | $Enums.ComplaintStatus
    admin_response?: StringNullableFilter<"complaints"> | string | null
    admin_id?: StringNullableFilter<"complaints"> | string | null
    created_at?: DateTimeFilter<"complaints"> | Date | string
    updated_at?: DateTimeFilter<"complaints"> | Date | string
  }

  export type complaintsUpsertWithWhereUniqueWithoutUsers_complaints_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedUpdateWithoutUsers_complaints_user_idTousersInput>
    create: XOR<complaintsCreateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedCreateWithoutUsers_complaints_user_idTousersInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutUsers_complaints_user_idTousersInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutUsers_complaints_user_idTousersInput, complaintsUncheckedUpdateWithoutUsers_complaints_user_idTousersInput>
  }

  export type complaintsUpdateManyWithWhereWithoutUsers_complaints_user_idTousersInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersInput>
  }

  export type conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput = {
    where: conversationsWhereUniqueInput
    update: XOR<conversationsUpdateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedUpdateWithoutUsers_conversations_participant1_idTousersInput>
    create: XOR<conversationsCreateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant1_idTousersInput>
  }

  export type conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant1_idTousersInput = {
    where: conversationsWhereUniqueInput
    data: XOR<conversationsUpdateWithoutUsers_conversations_participant1_idTousersInput, conversationsUncheckedUpdateWithoutUsers_conversations_participant1_idTousersInput>
  }

  export type conversationsUpdateManyWithWhereWithoutUsers_conversations_participant1_idTousersInput = {
    where: conversationsScalarWhereInput
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersInput>
  }

  export type conversationsScalarWhereInput = {
    AND?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
    OR?: conversationsScalarWhereInput[]
    NOT?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
    id?: StringFilter<"conversations"> | string
    participant1_id?: StringFilter<"conversations"> | string
    participant2_id?: StringFilter<"conversations"> | string
    listing_id?: StringNullableFilter<"conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
    created_at?: DateTimeFilter<"conversations"> | Date | string
    updated_at?: DateTimeFilter<"conversations"> | Date | string
  }

  export type conversationsUpsertWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput = {
    where: conversationsWhereUniqueInput
    update: XOR<conversationsUpdateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedUpdateWithoutUsers_conversations_participant2_idTousersInput>
    create: XOR<conversationsCreateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedCreateWithoutUsers_conversations_participant2_idTousersInput>
  }

  export type conversationsUpdateWithWhereUniqueWithoutUsers_conversations_participant2_idTousersInput = {
    where: conversationsWhereUniqueInput
    data: XOR<conversationsUpdateWithoutUsers_conversations_participant2_idTousersInput, conversationsUncheckedUpdateWithoutUsers_conversations_participant2_idTousersInput>
  }

  export type conversationsUpdateManyWithWhereWithoutUsers_conversations_participant2_idTousersInput = {
    where: conversationsScalarWhereInput
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUsersInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUsersInput, FavoriteUncheckedUpdateWithoutUsersInput>
    create: XOR<FavoriteCreateWithoutUsersInput, FavoriteUncheckedCreateWithoutUsersInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUsersInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUsersInput, FavoriteUncheckedUpdateWithoutUsersInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUsersInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUsersInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    user_id?: StringFilter<"Favorite"> | string
    listing_id?: StringFilter<"Favorite"> | string
    created_at?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type ListingUpsertWithWhereUniqueWithoutUsersInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutUsersInput, ListingUncheckedUpdateWithoutUsersInput>
    create: XOR<ListingCreateWithoutUsersInput, ListingUncheckedCreateWithoutUsersInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutUsersInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutUsersInput, ListingUncheckedUpdateWithoutUsersInput>
  }

  export type ListingUpdateManyWithWhereWithoutUsersInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutUsersInput>
  }

  export type ListingScalarWhereInput = {
    AND?: ListingScalarWhereInput | ListingScalarWhereInput[]
    OR?: ListingScalarWhereInput[]
    NOT?: ListingScalarWhereInput | ListingScalarWhereInput[]
    id?: StringFilter<"Listing"> | string
    title?: StringFilter<"Listing"> | string
    description?: StringNullableFilter<"Listing"> | string | null
    price?: DecimalFilter<"Listing"> | Decimal | DecimalJsLike | number | string
    year?: IntFilter<"Listing"> | number
    category_id?: StringFilter<"Listing"> | string
    vehicle_type_id?: StringFilter<"Listing"> | string
    brand_id?: StringNullableFilter<"Listing"> | string | null
    model_id?: StringNullableFilter<"Listing"> | string | null
    variant_id?: StringNullableFilter<"Listing"> | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    is_active?: BoolFilter<"Listing"> | boolean
    is_approved?: BoolFilter<"Listing"> | boolean
    is_pending?: BoolFilter<"Listing"> | boolean
    view_count?: IntFilter<"Listing"> | number
    is_promoted?: BoolFilter<"Listing"> | boolean
    approved_by?: StringNullableFilter<"Listing"> | string | null
    approved_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    rejected_at?: DateTimeNullableFilter<"Listing"> | Date | string | null
    reject_reason?: StringNullableFilter<"Listing"> | string | null
    seller_name?: StringFilter<"Listing"> | string
    seller_phone?: StringFilter<"Listing"> | string
    seller_email?: StringFilter<"Listing"> | string
    city_id?: StringNullableFilter<"Listing"> | string | null
    district_id?: StringNullableFilter<"Listing"> | string | null
    created_at?: DateTimeFilter<"Listing"> | Date | string
    updated_at?: DateTimeFilter<"Listing"> | Date | string
    user_id?: StringFilter<"Listing"> | string
    color?: StringNullableFilter<"Listing"> | string | null
    engine_power?: StringNullableFilter<"Listing"> | string | null
    engine_volume?: StringNullableFilter<"Listing"> | string | null
    fuel_type?: StringNullableFilter<"Listing"> | string | null
    is_exchangeable?: BoolFilter<"Listing"> | boolean
    km?: IntNullableFilter<"Listing"> | number | null
    license_plate?: StringNullableFilter<"Listing"> | string | null
    neighborhood_id?: StringNullableFilter<"Listing"> | string | null
    transmission?: StringNullableFilter<"Listing"> | string | null
    vehicle_condition?: StringNullableFilter<"Listing"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUsersInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUsersInput, MessageUncheckedUpdateWithoutUsersInput>
    create: XOR<MessageCreateWithoutUsersInput, MessageUncheckedCreateWithoutUsersInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUsersInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUsersInput, MessageUncheckedUpdateWithoutUsersInput>
  }

  export type MessageUpdateManyWithWhereWithoutUsersInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUsersInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    is_read?: BoolFilter<"Message"> | boolean
    is_edited?: BoolFilter<"Message"> | boolean
    created_at?: DateTimeFilter<"Message"> | Date | string
    updated_at?: DateTimeFilter<"Message"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUsersInput, NotificationUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUsersInput, NotificationUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUsersInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    user_id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type category_attributesCreateWithoutCategoriesInput = {
    id: string
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    vehicle_types?: vehicle_typesCreateNestedOneWithoutCategory_attributesInput
  }

  export type category_attributesUncheckedCreateWithoutCategoriesInput = {
    id: string
    vehicle_type_id?: string | null
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesCreateOrConnectWithoutCategoriesInput = {
    where: category_attributesWhereUniqueInput
    create: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput>
  }

  export type category_attributesCreateManyCategoriesInputEnvelope = {
    data: category_attributesCreateManyCategoriesInput | category_attributesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutCategoriesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput>
  }

  export type ListingCreateManyCategoriesInputEnvelope = {
    data: ListingCreateManyCategoriesInput | ListingCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_typesCreateWithoutCategoriesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateWithoutCategoriesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsUncheckedCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesCreateOrConnectWithoutCategoriesInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput>
  }

  export type vehicle_typesCreateManyCategoriesInputEnvelope = {
    data: vehicle_typesCreateManyCategoriesInput | vehicle_typesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type category_attributesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: category_attributesWhereUniqueInput
    update: XOR<category_attributesUpdateWithoutCategoriesInput, category_attributesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<category_attributesCreateWithoutCategoriesInput, category_attributesUncheckedCreateWithoutCategoriesInput>
  }

  export type category_attributesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: category_attributesWhereUniqueInput
    data: XOR<category_attributesUpdateWithoutCategoriesInput, category_attributesUncheckedUpdateWithoutCategoriesInput>
  }

  export type category_attributesUpdateManyWithWhereWithoutCategoriesInput = {
    where: category_attributesScalarWhereInput
    data: XOR<category_attributesUpdateManyMutationInput, category_attributesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type category_attributesScalarWhereInput = {
    AND?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
    OR?: category_attributesScalarWhereInput[]
    NOT?: category_attributesScalarWhereInput | category_attributesScalarWhereInput[]
    id?: StringFilter<"category_attributes"> | string
    category_id?: StringFilter<"category_attributes"> | string
    vehicle_type_id?: StringNullableFilter<"category_attributes"> | string | null
    key?: StringFilter<"category_attributes"> | string
    label?: StringFilter<"category_attributes"> | string
    type?: EnumPropertyTypeFilter<"category_attributes"> | $Enums.PropertyType
    is_required?: BoolFilter<"category_attributes"> | boolean
    is_filterable?: BoolFilter<"category_attributes"> | boolean
    sort_order?: IntFilter<"category_attributes"> | number
    options?: JsonNullableFilter<"category_attributes">
  }

  export type ListingUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutCategoriesInput, ListingUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ListingCreateWithoutCategoriesInput, ListingUncheckedCreateWithoutCategoriesInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutCategoriesInput, ListingUncheckedUpdateWithoutCategoriesInput>
  }

  export type ListingUpdateManyWithWhereWithoutCategoriesInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type vehicle_typesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: vehicle_typesWhereUniqueInput
    update: XOR<vehicle_typesUpdateWithoutCategoriesInput, vehicle_typesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<vehicle_typesCreateWithoutCategoriesInput, vehicle_typesUncheckedCreateWithoutCategoriesInput>
  }

  export type vehicle_typesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: vehicle_typesWhereUniqueInput
    data: XOR<vehicle_typesUpdateWithoutCategoriesInput, vehicle_typesUncheckedUpdateWithoutCategoriesInput>
  }

  export type vehicle_typesUpdateManyWithWhereWithoutCategoriesInput = {
    where: vehicle_typesScalarWhereInput
    data: XOR<vehicle_typesUpdateManyMutationInput, vehicle_typesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type vehicle_typesScalarWhereInput = {
    AND?: vehicle_typesScalarWhereInput | vehicle_typesScalarWhereInput[]
    OR?: vehicle_typesScalarWhereInput[]
    NOT?: vehicle_typesScalarWhereInput | vehicle_typesScalarWhereInput[]
    id?: StringFilter<"vehicle_types"> | string
    name?: StringFilter<"vehicle_types"> | string
    category_id?: StringFilter<"vehicle_types"> | string
    created_at?: DateTimeFilter<"vehicle_types"> | Date | string
    updated_at?: DateTimeFilter<"vehicle_types"> | Date | string
    image_url?: StringNullableFilter<"vehicle_types"> | string | null
  }

  export type complaintsCreateWithoutListingsInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    users_complaints_target_user_idTousers?: UserCreateNestedOneWithoutComplaints_complaints_target_user_idTousersInput
    users_complaints_user_idTousers: UserCreateNestedOneWithoutComplaints_complaints_user_idTousersInput
  }

  export type complaintsUncheckedCreateWithoutListingsInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsCreateOrConnectWithoutListingsInput = {
    where: complaintsWhereUniqueInput
    create: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput>
  }

  export type complaintsCreateManyListingsInputEnvelope = {
    data: complaintsCreateManyListingsInput | complaintsCreateManyListingsInput[]
    skipDuplicates?: boolean
  }

  export type conversationsCreateWithoutListingsInput = {
    id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    users_conversations_participant1_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant1_idTousersInput
    users_conversations_participant2_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant2_idTousersInput
    messages?: MessageCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutListingsInput = {
    id: string
    participant1_id: string
    participant2_id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutListingsInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput>
  }

  export type conversationsCreateManyListingsInputEnvelope = {
    data: conversationsCreateManyListingsInput | conversationsCreateManyListingsInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutListingsInput = {
    id?: string
    created_at?: Date | string
    users: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutListingsInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutListingsInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput>
  }

  export type FavoriteCreateManyListingsInputEnvelope = {
    data: FavoriteCreateManyListingsInput | FavoriteCreateManyListingsInput[]
    skipDuplicates?: boolean
  }

  export type listing_imagesCreateWithoutListingsInput = {
    id: string
    url: string
    alt?: string | null
    sort_order?: number
  }

  export type listing_imagesUncheckedCreateWithoutListingsInput = {
    id: string
    url: string
    alt?: string | null
    sort_order?: number
  }

  export type listing_imagesCreateOrConnectWithoutListingsInput = {
    where: listing_imagesWhereUniqueInput
    create: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput>
  }

  export type listing_imagesCreateManyListingsInputEnvelope = {
    data: listing_imagesCreateManyListingsInput | listing_imagesCreateManyListingsInput[]
    skipDuplicates?: boolean
  }

  export type listing_propertiesCreateWithoutListingsInput = {
    id: string
    key: string
    value: string
    type: $Enums.PropertyType
  }

  export type listing_propertiesUncheckedCreateWithoutListingsInput = {
    id: string
    key: string
    value: string
    type: $Enums.PropertyType
  }

  export type listing_propertiesCreateOrConnectWithoutListingsInput = {
    where: listing_propertiesWhereUniqueInput
    create: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput>
  }

  export type listing_propertiesCreateManyListingsInputEnvelope = {
    data: listing_propertiesCreateManyListingsInput | listing_propertiesCreateManyListingsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutListingsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    vehicle_types: vehicle_typesCreateNestedOneWithoutBrandsInput
    models?: modelsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    vehicle_type_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    models?: modelsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutListingsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutListingsInput, brandsUncheckedCreateWithoutListingsInput>
  }

  export type CategoryCreateWithoutListingsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutListingsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
  }

  export type citiesCreateWithoutListingsInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    districts?: districtsCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    districts?: districtsUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutListingsInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutListingsInput, citiesUncheckedCreateWithoutListingsInput>
  }

  export type districtsCreateWithoutListingsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    cities: citiesCreateNestedOneWithoutDistrictsInput
  }

  export type districtsUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    city_id: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type districtsCreateOrConnectWithoutListingsInput = {
    where: districtsWhereUniqueInput
    create: XOR<districtsCreateWithoutListingsInput, districtsUncheckedCreateWithoutListingsInput>
  }

  export type modelsCreateWithoutListingsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    brands: brandsCreateNestedOneWithoutModelsInput
    variants?: variantsCreateNestedManyWithoutModelsInput
  }

  export type modelsUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    brand_id: string
    created_at?: Date | string
    updated_at: Date | string
    variants?: variantsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type modelsCreateOrConnectWithoutListingsInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutListingsInput, modelsUncheckedCreateWithoutListingsInput>
  }

  export type UserCreateWithoutListingsInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutListingsInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type variantsCreateWithoutListingsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    models: modelsCreateNestedOneWithoutVariantsInput
  }

  export type variantsUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    model_id: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type variantsCreateOrConnectWithoutListingsInput = {
    where: variantsWhereUniqueInput
    create: XOR<variantsCreateWithoutListingsInput, variantsUncheckedCreateWithoutListingsInput>
  }

  export type vehicle_typesCreateWithoutListingsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsCreateNestedManyWithoutVehicle_typesInput
    categories: CategoryCreateNestedOneWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateWithoutListingsInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsUncheckedCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesCreateOrConnectWithoutListingsInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutListingsInput, vehicle_typesUncheckedCreateWithoutListingsInput>
  }

  export type complaintsUpsertWithWhereUniqueWithoutListingsInput = {
    where: complaintsWhereUniqueInput
    update: XOR<complaintsUpdateWithoutListingsInput, complaintsUncheckedUpdateWithoutListingsInput>
    create: XOR<complaintsCreateWithoutListingsInput, complaintsUncheckedCreateWithoutListingsInput>
  }

  export type complaintsUpdateWithWhereUniqueWithoutListingsInput = {
    where: complaintsWhereUniqueInput
    data: XOR<complaintsUpdateWithoutListingsInput, complaintsUncheckedUpdateWithoutListingsInput>
  }

  export type complaintsUpdateManyWithWhereWithoutListingsInput = {
    where: complaintsScalarWhereInput
    data: XOR<complaintsUpdateManyMutationInput, complaintsUncheckedUpdateManyWithoutListingsInput>
  }

  export type conversationsUpsertWithWhereUniqueWithoutListingsInput = {
    where: conversationsWhereUniqueInput
    update: XOR<conversationsUpdateWithoutListingsInput, conversationsUncheckedUpdateWithoutListingsInput>
    create: XOR<conversationsCreateWithoutListingsInput, conversationsUncheckedCreateWithoutListingsInput>
  }

  export type conversationsUpdateWithWhereUniqueWithoutListingsInput = {
    where: conversationsWhereUniqueInput
    data: XOR<conversationsUpdateWithoutListingsInput, conversationsUncheckedUpdateWithoutListingsInput>
  }

  export type conversationsUpdateManyWithWhereWithoutListingsInput = {
    where: conversationsScalarWhereInput
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyWithoutListingsInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutListingsInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutListingsInput, FavoriteUncheckedUpdateWithoutListingsInput>
    create: XOR<FavoriteCreateWithoutListingsInput, FavoriteUncheckedCreateWithoutListingsInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutListingsInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutListingsInput, FavoriteUncheckedUpdateWithoutListingsInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutListingsInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutListingsInput>
  }

  export type listing_imagesUpsertWithWhereUniqueWithoutListingsInput = {
    where: listing_imagesWhereUniqueInput
    update: XOR<listing_imagesUpdateWithoutListingsInput, listing_imagesUncheckedUpdateWithoutListingsInput>
    create: XOR<listing_imagesCreateWithoutListingsInput, listing_imagesUncheckedCreateWithoutListingsInput>
  }

  export type listing_imagesUpdateWithWhereUniqueWithoutListingsInput = {
    where: listing_imagesWhereUniqueInput
    data: XOR<listing_imagesUpdateWithoutListingsInput, listing_imagesUncheckedUpdateWithoutListingsInput>
  }

  export type listing_imagesUpdateManyWithWhereWithoutListingsInput = {
    where: listing_imagesScalarWhereInput
    data: XOR<listing_imagesUpdateManyMutationInput, listing_imagesUncheckedUpdateManyWithoutListingsInput>
  }

  export type listing_imagesScalarWhereInput = {
    AND?: listing_imagesScalarWhereInput | listing_imagesScalarWhereInput[]
    OR?: listing_imagesScalarWhereInput[]
    NOT?: listing_imagesScalarWhereInput | listing_imagesScalarWhereInput[]
    id?: StringFilter<"listing_images"> | string
    listing_id?: StringFilter<"listing_images"> | string
    url?: StringFilter<"listing_images"> | string
    alt?: StringNullableFilter<"listing_images"> | string | null
    sort_order?: IntFilter<"listing_images"> | number
  }

  export type listing_propertiesUpsertWithWhereUniqueWithoutListingsInput = {
    where: listing_propertiesWhereUniqueInput
    update: XOR<listing_propertiesUpdateWithoutListingsInput, listing_propertiesUncheckedUpdateWithoutListingsInput>
    create: XOR<listing_propertiesCreateWithoutListingsInput, listing_propertiesUncheckedCreateWithoutListingsInput>
  }

  export type listing_propertiesUpdateWithWhereUniqueWithoutListingsInput = {
    where: listing_propertiesWhereUniqueInput
    data: XOR<listing_propertiesUpdateWithoutListingsInput, listing_propertiesUncheckedUpdateWithoutListingsInput>
  }

  export type listing_propertiesUpdateManyWithWhereWithoutListingsInput = {
    where: listing_propertiesScalarWhereInput
    data: XOR<listing_propertiesUpdateManyMutationInput, listing_propertiesUncheckedUpdateManyWithoutListingsInput>
  }

  export type listing_propertiesScalarWhereInput = {
    AND?: listing_propertiesScalarWhereInput | listing_propertiesScalarWhereInput[]
    OR?: listing_propertiesScalarWhereInput[]
    NOT?: listing_propertiesScalarWhereInput | listing_propertiesScalarWhereInput[]
    id?: StringFilter<"listing_properties"> | string
    listing_id?: StringFilter<"listing_properties"> | string
    key?: StringFilter<"listing_properties"> | string
    value?: StringFilter<"listing_properties"> | string
    type?: EnumPropertyTypeFilter<"listing_properties"> | $Enums.PropertyType
  }

  export type brandsUpsertWithoutListingsInput = {
    update: XOR<brandsUpdateWithoutListingsInput, brandsUncheckedUpdateWithoutListingsInput>
    create: XOR<brandsCreateWithoutListingsInput, brandsUncheckedCreateWithoutListingsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutListingsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutListingsInput, brandsUncheckedUpdateWithoutListingsInput>
  }

  export type brandsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutBrandsNestedInput
    models?: modelsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    models?: modelsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type CategoryUpsertWithoutListingsInput = {
    update: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutListingsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
  }

  export type CategoryUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUncheckedUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type citiesUpsertWithoutListingsInput = {
    update: XOR<citiesUpdateWithoutListingsInput, citiesUncheckedUpdateWithoutListingsInput>
    create: XOR<citiesCreateWithoutListingsInput, citiesUncheckedCreateWithoutListingsInput>
    where?: citiesWhereInput
  }

  export type citiesUpdateToOneWithWhereWithoutListingsInput = {
    where?: citiesWhereInput
    data: XOR<citiesUpdateWithoutListingsInput, citiesUncheckedUpdateWithoutListingsInput>
  }

  export type citiesUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type districtsUpsertWithoutListingsInput = {
    update: XOR<districtsUpdateWithoutListingsInput, districtsUncheckedUpdateWithoutListingsInput>
    create: XOR<districtsCreateWithoutListingsInput, districtsUncheckedCreateWithoutListingsInput>
    where?: districtsWhereInput
  }

  export type districtsUpdateToOneWithWhereWithoutListingsInput = {
    where?: districtsWhereInput
    data: XOR<districtsUpdateWithoutListingsInput, districtsUncheckedUpdateWithoutListingsInput>
  }

  export type districtsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUpdateOneRequiredWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modelsUpsertWithoutListingsInput = {
    update: XOR<modelsUpdateWithoutListingsInput, modelsUncheckedUpdateWithoutListingsInput>
    create: XOR<modelsCreateWithoutListingsInput, modelsUncheckedCreateWithoutListingsInput>
    where?: modelsWhereInput
  }

  export type modelsUpdateToOneWithWhereWithoutListingsInput = {
    where?: modelsWhereInput
    data: XOR<modelsUpdateWithoutListingsInput, modelsUncheckedUpdateWithoutListingsInput>
  }

  export type modelsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: brandsUpdateOneRequiredWithoutModelsNestedInput
    variants?: variantsUpdateManyWithoutModelsNestedInput
  }

  export type modelsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type UserUpsertWithoutListingsInput = {
    update: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type variantsUpsertWithoutListingsInput = {
    update: XOR<variantsUpdateWithoutListingsInput, variantsUncheckedUpdateWithoutListingsInput>
    create: XOR<variantsCreateWithoutListingsInput, variantsUncheckedCreateWithoutListingsInput>
    where?: variantsWhereInput
  }

  export type variantsUpdateToOneWithWhereWithoutListingsInput = {
    where?: variantsWhereInput
    data: XOR<variantsUpdateWithoutListingsInput, variantsUncheckedUpdateWithoutListingsInput>
  }

  export type variantsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type variantsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_typesUpsertWithoutListingsInput = {
    update: XOR<vehicle_typesUpdateWithoutListingsInput, vehicle_typesUncheckedUpdateWithoutListingsInput>
    create: XOR<vehicle_typesCreateWithoutListingsInput, vehicle_typesUncheckedCreateWithoutListingsInput>
    where?: vehicle_typesWhereInput
  }

  export type vehicle_typesUpdateToOneWithWhereWithoutListingsInput = {
    where?: vehicle_typesWhereInput
    data: XOR<vehicle_typesUpdateWithoutListingsInput, vehicle_typesUncheckedUpdateWithoutListingsInput>
  }

  export type vehicle_typesUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUpdateManyWithoutVehicle_typesNestedInput
    categories?: CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type conversationsCreateWithoutMessagesInput = {
    id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedOneWithoutConversationsInput
    users_conversations_participant1_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant1_idTousersInput
    users_conversations_participant2_idTousers: UserCreateNestedOneWithoutConversations_conversations_participant2_idTousersInput
  }

  export type conversationsUncheckedCreateWithoutMessagesInput = {
    id: string
    participant1_id: string
    participant2_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type conversationsCreateOrConnectWithoutMessagesInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutMessagesInput, conversationsUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type conversationsUpsertWithoutMessagesInput = {
    update: XOR<conversationsUpdateWithoutMessagesInput, conversationsUncheckedUpdateWithoutMessagesInput>
    create: XOR<conversationsCreateWithoutMessagesInput, conversationsUncheckedCreateWithoutMessagesInput>
    where?: conversationsWhereInput
  }

  export type conversationsUpdateToOneWithWhereWithoutMessagesInput = {
    where?: conversationsWhereInput
    data: XOR<conversationsUpdateWithoutMessagesInput, conversationsUncheckedUpdateWithoutMessagesInput>
  }

  export type conversationsUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutConversationsNestedInput
    users_conversations_participant1_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant1_idTousersNestedInput
    users_conversations_participant2_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant2_idTousersNestedInput
  }

  export type conversationsUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ListingCreateWithoutFavoritesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutFavoritesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutFavoritesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type ListingUpsertWithoutFavoritesInput = {
    update: XOR<ListingUpdateWithoutFavoritesInput, ListingUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutFavoritesInput, ListingUncheckedUpdateWithoutFavoritesInput>
  }

  export type ListingUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type vehicle_typesCreateWithoutBrandsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    category_attributes?: category_attributesCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingCreateNestedManyWithoutVehicle_typesInput
    categories: CategoryCreateNestedOneWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateWithoutBrandsInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesCreateOrConnectWithoutBrandsInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutBrandsInput, vehicle_typesUncheckedCreateWithoutBrandsInput>
  }

  export type ListingCreateWithoutBrandsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutBrandsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutBrandsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput>
  }

  export type ListingCreateManyBrandsInputEnvelope = {
    data: ListingCreateManyBrandsInput | ListingCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type modelsCreateWithoutBrandsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutModelsInput
    variants?: variantsCreateNestedManyWithoutModelsInput
  }

  export type modelsUncheckedCreateWithoutBrandsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutModelsInput
    variants?: variantsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type modelsCreateOrConnectWithoutBrandsInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput>
  }

  export type modelsCreateManyBrandsInputEnvelope = {
    data: modelsCreateManyBrandsInput | modelsCreateManyBrandsInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_typesUpsertWithoutBrandsInput = {
    update: XOR<vehicle_typesUpdateWithoutBrandsInput, vehicle_typesUncheckedUpdateWithoutBrandsInput>
    create: XOR<vehicle_typesCreateWithoutBrandsInput, vehicle_typesUncheckedCreateWithoutBrandsInput>
    where?: vehicle_typesWhereInput
  }

  export type vehicle_typesUpdateToOneWithWhereWithoutBrandsInput = {
    where?: vehicle_typesWhereInput
    data: XOR<vehicle_typesUpdateWithoutBrandsInput, vehicle_typesUncheckedUpdateWithoutBrandsInput>
  }

  export type vehicle_typesUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    category_attributes?: category_attributesUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUpdateManyWithoutVehicle_typesNestedInput
    categories?: CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    category_attributes?: category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type ListingUpsertWithWhereUniqueWithoutBrandsInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutBrandsInput, ListingUncheckedUpdateWithoutBrandsInput>
    create: XOR<ListingCreateWithoutBrandsInput, ListingUncheckedCreateWithoutBrandsInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutBrandsInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutBrandsInput, ListingUncheckedUpdateWithoutBrandsInput>
  }

  export type ListingUpdateManyWithWhereWithoutBrandsInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutBrandsInput>
  }

  export type modelsUpsertWithWhereUniqueWithoutBrandsInput = {
    where: modelsWhereUniqueInput
    update: XOR<modelsUpdateWithoutBrandsInput, modelsUncheckedUpdateWithoutBrandsInput>
    create: XOR<modelsCreateWithoutBrandsInput, modelsUncheckedCreateWithoutBrandsInput>
  }

  export type modelsUpdateWithWhereUniqueWithoutBrandsInput = {
    where: modelsWhereUniqueInput
    data: XOR<modelsUpdateWithoutBrandsInput, modelsUncheckedUpdateWithoutBrandsInput>
  }

  export type modelsUpdateManyWithWhereWithoutBrandsInput = {
    where: modelsScalarWhereInput
    data: XOR<modelsUpdateManyMutationInput, modelsUncheckedUpdateManyWithoutBrandsInput>
  }

  export type modelsScalarWhereInput = {
    AND?: modelsScalarWhereInput | modelsScalarWhereInput[]
    OR?: modelsScalarWhereInput[]
    NOT?: modelsScalarWhereInput | modelsScalarWhereInput[]
    id?: StringFilter<"models"> | string
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    created_at?: DateTimeFilter<"models"> | Date | string
    updated_at?: DateTimeFilter<"models"> | Date | string
  }

  export type CategoryCreateWithoutCategory_attributesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutCategory_attributesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutCategoriesInput
    vehicle_types?: vehicle_typesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutCategory_attributesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCategory_attributesInput, CategoryUncheckedCreateWithoutCategory_attributesInput>
  }

  export type vehicle_typesCreateWithoutCategory_attributesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingCreateNestedManyWithoutVehicle_typesInput
    categories: CategoryCreateNestedOneWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateWithoutCategory_attributesInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsUncheckedCreateNestedManyWithoutVehicle_typesInput
    feature_groups?: feature_groupsUncheckedCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesCreateOrConnectWithoutCategory_attributesInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutCategory_attributesInput, vehicle_typesUncheckedCreateWithoutCategory_attributesInput>
  }

  export type CategoryUpsertWithoutCategory_attributesInput = {
    update: XOR<CategoryUpdateWithoutCategory_attributesInput, CategoryUncheckedUpdateWithoutCategory_attributesInput>
    create: XOR<CategoryCreateWithoutCategory_attributesInput, CategoryUncheckedCreateWithoutCategory_attributesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCategory_attributesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCategory_attributesInput, CategoryUncheckedUpdateWithoutCategory_attributesInput>
  }

  export type CategoryUpdateWithoutCategory_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCategory_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutCategoriesNestedInput
    vehicle_types?: vehicle_typesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type vehicle_typesUpsertWithoutCategory_attributesInput = {
    update: XOR<vehicle_typesUpdateWithoutCategory_attributesInput, vehicle_typesUncheckedUpdateWithoutCategory_attributesInput>
    create: XOR<vehicle_typesCreateWithoutCategory_attributesInput, vehicle_typesUncheckedCreateWithoutCategory_attributesInput>
    where?: vehicle_typesWhereInput
  }

  export type vehicle_typesUpdateToOneWithWhereWithoutCategory_attributesInput = {
    where?: vehicle_typesWhereInput
    data: XOR<vehicle_typesUpdateWithoutCategory_attributesInput, vehicle_typesUncheckedUpdateWithoutCategory_attributesInput>
  }

  export type vehicle_typesUpdateWithoutCategory_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUpdateManyWithoutVehicle_typesNestedInput
    categories?: CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateWithoutCategory_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type districtsCreateWithoutCitiesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUncheckedCreateWithoutCitiesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutDistrictsInput
  }

  export type districtsCreateOrConnectWithoutCitiesInput = {
    where: districtsWhereUniqueInput
    create: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput>
  }

  export type districtsCreateManyCitiesInputEnvelope = {
    data: districtsCreateManyCitiesInput | districtsCreateManyCitiesInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutCitiesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutCitiesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutCitiesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput>
  }

  export type ListingCreateManyCitiesInputEnvelope = {
    data: ListingCreateManyCitiesInput | ListingCreateManyCitiesInput[]
    skipDuplicates?: boolean
  }

  export type districtsUpsertWithWhereUniqueWithoutCitiesInput = {
    where: districtsWhereUniqueInput
    update: XOR<districtsUpdateWithoutCitiesInput, districtsUncheckedUpdateWithoutCitiesInput>
    create: XOR<districtsCreateWithoutCitiesInput, districtsUncheckedCreateWithoutCitiesInput>
  }

  export type districtsUpdateWithWhereUniqueWithoutCitiesInput = {
    where: districtsWhereUniqueInput
    data: XOR<districtsUpdateWithoutCitiesInput, districtsUncheckedUpdateWithoutCitiesInput>
  }

  export type districtsUpdateManyWithWhereWithoutCitiesInput = {
    where: districtsScalarWhereInput
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyWithoutCitiesInput>
  }

  export type districtsScalarWhereInput = {
    AND?: districtsScalarWhereInput | districtsScalarWhereInput[]
    OR?: districtsScalarWhereInput[]
    NOT?: districtsScalarWhereInput | districtsScalarWhereInput[]
    id?: StringFilter<"districts"> | string
    name?: StringFilter<"districts"> | string
    city_id?: StringFilter<"districts"> | string
    created_at?: DateTimeFilter<"districts"> | Date | string
    updated_at?: DateTimeFilter<"districts"> | Date | string
  }

  export type ListingUpsertWithWhereUniqueWithoutCitiesInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutCitiesInput, ListingUncheckedUpdateWithoutCitiesInput>
    create: XOR<ListingCreateWithoutCitiesInput, ListingUncheckedCreateWithoutCitiesInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutCitiesInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutCitiesInput, ListingUncheckedUpdateWithoutCitiesInput>
  }

  export type ListingUpdateManyWithWhereWithoutCitiesInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutCitiesInput>
  }

  export type ListingCreateWithoutComplaintsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutComplaintsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutComplaintsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutComplaintsInput, ListingUncheckedCreateWithoutComplaintsInput>
  }

  export type UserCreateWithoutComplaints_complaints_target_user_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutComplaints_complaints_target_user_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutComplaints_complaints_target_user_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_target_user_idTousersInput>
  }

  export type UserCreateWithoutComplaints_complaints_user_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutComplaints_complaints_user_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutComplaints_complaints_user_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_user_idTousersInput>
  }

  export type ListingUpsertWithoutComplaintsInput = {
    update: XOR<ListingUpdateWithoutComplaintsInput, ListingUncheckedUpdateWithoutComplaintsInput>
    create: XOR<ListingCreateWithoutComplaintsInput, ListingUncheckedCreateWithoutComplaintsInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutComplaintsInput, ListingUncheckedUpdateWithoutComplaintsInput>
  }

  export type ListingUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type UserUpsertWithoutComplaints_complaints_target_user_idTousersInput = {
    update: XOR<UserUpdateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedUpdateWithoutComplaints_complaints_target_user_idTousersInput>
    create: XOR<UserCreateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_target_user_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplaints_complaints_target_user_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplaints_complaints_target_user_idTousersInput, UserUncheckedUpdateWithoutComplaints_complaints_target_user_idTousersInput>
  }

  export type UserUpdateWithoutComplaints_complaints_target_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutComplaints_complaints_target_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutComplaints_complaints_user_idTousersInput = {
    update: XOR<UserUpdateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedUpdateWithoutComplaints_complaints_user_idTousersInput>
    create: XOR<UserCreateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedCreateWithoutComplaints_complaints_user_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplaints_complaints_user_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplaints_complaints_user_idTousersInput, UserUncheckedUpdateWithoutComplaints_complaints_user_idTousersInput>
  }

  export type UserUpdateWithoutComplaints_complaints_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutComplaints_complaints_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ListingCreateWithoutConversationsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutConversationsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutConversationsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutConversations_conversations_participant1_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutConversations_conversations_participant1_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant2_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutConversations_conversations_participant1_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant1_idTousersInput>
  }

  export type UserCreateWithoutConversations_conversations_participant2_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    favorites?: FavoriteCreateNestedManyWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutConversations_conversations_participant2_idTousersInput = {
    id?: string
    email: string
    password?: string | null
    first_name: string
    last_name: string
    username?: string | null
    phone?: string | null
    city?: string | null
    district?: string | null
    role?: $Enums.UserRole
    is_active?: boolean
    is_email_verified?: boolean
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    last_login?: Date | string | null
    login_attempts?: number
    lock_until?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    google_id?: string | null
    provider?: string | null
    refresh_token?: string | null
    refresh_token_expires?: Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_target_user_idTousersInput
    complaints_complaints_user_idTousers?: complaintsUncheckedCreateNestedManyWithoutUsers_complaints_user_idTousersInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedCreateNestedManyWithoutUsers_conversations_participant1_idTousersInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUsersInput
    listings?: ListingUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutConversations_conversations_participant2_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant2_idTousersInput>
  }

  export type MessageCreateWithoutConversationsInput = {
    id?: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
    users: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationsInput = {
    id?: string
    sender_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateManyConversationsInputEnvelope = {
    data: MessageCreateManyConversationsInput | MessageCreateManyConversationsInput[]
    skipDuplicates?: boolean
  }

  export type ListingUpsertWithoutConversationsInput = {
    update: XOR<ListingUpdateWithoutConversationsInput, ListingUncheckedUpdateWithoutConversationsInput>
    create: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutConversationsInput, ListingUncheckedUpdateWithoutConversationsInput>
  }

  export type ListingUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type UserUpsertWithoutConversations_conversations_participant1_idTousersInput = {
    update: XOR<UserUpdateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedUpdateWithoutConversations_conversations_participant1_idTousersInput>
    create: XOR<UserCreateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant1_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversations_conversations_participant1_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversations_conversations_participant1_idTousersInput, UserUncheckedUpdateWithoutConversations_conversations_participant1_idTousersInput>
  }

  export type UserUpdateWithoutConversations_conversations_participant1_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutConversations_conversations_participant1_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant2_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutConversations_conversations_participant2_idTousersInput = {
    update: XOR<UserUpdateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedUpdateWithoutConversations_conversations_participant2_idTousersInput>
    create: XOR<UserCreateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedCreateWithoutConversations_conversations_participant2_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversations_conversations_participant2_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversations_conversations_participant2_idTousersInput, UserUncheckedUpdateWithoutConversations_conversations_participant2_idTousersInput>
  }

  export type UserUpdateWithoutConversations_conversations_participant2_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    favorites?: FavoriteUpdateManyWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutConversations_conversations_participant2_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    lock_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    complaints_complaints_target_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersNestedInput
    complaints_complaints_user_idTousers?: complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersNestedInput
    conversations_conversations_participant1_idTousers?: conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUsersNestedInput
    listings?: ListingUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationsInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationsInput, MessageUncheckedUpdateWithoutConversationsInput>
    create: XOR<MessageCreateWithoutConversationsInput, MessageUncheckedCreateWithoutConversationsInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationsInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationsInput, MessageUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationsInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationsInput>
  }

  export type citiesCreateWithoutDistrictsInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutDistrictsInput = {
    id: string
    name: string
    plate_code?: string | null
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutDistrictsInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutDistrictsInput, citiesUncheckedCreateWithoutDistrictsInput>
  }

  export type ListingCreateWithoutDistrictsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutDistrictsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutDistrictsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput>
  }

  export type ListingCreateManyDistrictsInputEnvelope = {
    data: ListingCreateManyDistrictsInput | ListingCreateManyDistrictsInput[]
    skipDuplicates?: boolean
  }

  export type citiesUpsertWithoutDistrictsInput = {
    update: XOR<citiesUpdateWithoutDistrictsInput, citiesUncheckedUpdateWithoutDistrictsInput>
    create: XOR<citiesCreateWithoutDistrictsInput, citiesUncheckedCreateWithoutDistrictsInput>
    where?: citiesWhereInput
  }

  export type citiesUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: citiesWhereInput
    data: XOR<citiesUpdateWithoutDistrictsInput, citiesUncheckedUpdateWithoutDistrictsInput>
  }

  export type citiesUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type ListingUpsertWithWhereUniqueWithoutDistrictsInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutDistrictsInput, ListingUncheckedUpdateWithoutDistrictsInput>
    create: XOR<ListingCreateWithoutDistrictsInput, ListingUncheckedCreateWithoutDistrictsInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutDistrictsInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutDistrictsInput, ListingUncheckedUpdateWithoutDistrictsInput>
  }

  export type ListingUpdateManyWithWhereWithoutDistrictsInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutDistrictsInput>
  }

  export type feature_groupsCreateWithoutFeature_definitionsInput = {
    id: string
    name: string
    label: string
    sort_order?: number
    vehicle_types: vehicle_typesCreateNestedOneWithoutFeature_groupsInput
  }

  export type feature_groupsUncheckedCreateWithoutFeature_definitionsInput = {
    id: string
    vehicle_type_id: string
    name: string
    label: string
    sort_order?: number
  }

  export type feature_groupsCreateOrConnectWithoutFeature_definitionsInput = {
    where: feature_groupsWhereUniqueInput
    create: XOR<feature_groupsCreateWithoutFeature_definitionsInput, feature_groupsUncheckedCreateWithoutFeature_definitionsInput>
  }

  export type feature_groupsUpsertWithoutFeature_definitionsInput = {
    update: XOR<feature_groupsUpdateWithoutFeature_definitionsInput, feature_groupsUncheckedUpdateWithoutFeature_definitionsInput>
    create: XOR<feature_groupsCreateWithoutFeature_definitionsInput, feature_groupsUncheckedCreateWithoutFeature_definitionsInput>
    where?: feature_groupsWhereInput
  }

  export type feature_groupsUpdateToOneWithWhereWithoutFeature_definitionsInput = {
    where?: feature_groupsWhereInput
    data: XOR<feature_groupsUpdateWithoutFeature_definitionsInput, feature_groupsUncheckedUpdateWithoutFeature_definitionsInput>
  }

  export type feature_groupsUpdateWithoutFeature_definitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutFeature_groupsNestedInput
  }

  export type feature_groupsUncheckedUpdateWithoutFeature_definitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_definitionsCreateWithoutFeature_groupsInput = {
    id: string
    key: string
    label: string
    sort_order?: number
  }

  export type feature_definitionsUncheckedCreateWithoutFeature_groupsInput = {
    id: string
    key: string
    label: string
    sort_order?: number
  }

  export type feature_definitionsCreateOrConnectWithoutFeature_groupsInput = {
    where: feature_definitionsWhereUniqueInput
    create: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput>
  }

  export type feature_definitionsCreateManyFeature_groupsInputEnvelope = {
    data: feature_definitionsCreateManyFeature_groupsInput | feature_definitionsCreateManyFeature_groupsInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_typesCreateWithoutFeature_groupsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingCreateNestedManyWithoutVehicle_typesInput
    categories: CategoryCreateNestedOneWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateWithoutFeature_groupsInput = {
    id: string
    name: string
    category_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    brands?: brandsUncheckedCreateNestedManyWithoutVehicle_typesInput
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutVehicle_typesInput
    listings?: ListingUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesCreateOrConnectWithoutFeature_groupsInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutFeature_groupsInput, vehicle_typesUncheckedCreateWithoutFeature_groupsInput>
  }

  export type feature_definitionsUpsertWithWhereUniqueWithoutFeature_groupsInput = {
    where: feature_definitionsWhereUniqueInput
    update: XOR<feature_definitionsUpdateWithoutFeature_groupsInput, feature_definitionsUncheckedUpdateWithoutFeature_groupsInput>
    create: XOR<feature_definitionsCreateWithoutFeature_groupsInput, feature_definitionsUncheckedCreateWithoutFeature_groupsInput>
  }

  export type feature_definitionsUpdateWithWhereUniqueWithoutFeature_groupsInput = {
    where: feature_definitionsWhereUniqueInput
    data: XOR<feature_definitionsUpdateWithoutFeature_groupsInput, feature_definitionsUncheckedUpdateWithoutFeature_groupsInput>
  }

  export type feature_definitionsUpdateManyWithWhereWithoutFeature_groupsInput = {
    where: feature_definitionsScalarWhereInput
    data: XOR<feature_definitionsUpdateManyMutationInput, feature_definitionsUncheckedUpdateManyWithoutFeature_groupsInput>
  }

  export type feature_definitionsScalarWhereInput = {
    AND?: feature_definitionsScalarWhereInput | feature_definitionsScalarWhereInput[]
    OR?: feature_definitionsScalarWhereInput[]
    NOT?: feature_definitionsScalarWhereInput | feature_definitionsScalarWhereInput[]
    id?: StringFilter<"feature_definitions"> | string
    group_id?: StringFilter<"feature_definitions"> | string
    key?: StringFilter<"feature_definitions"> | string
    label?: StringFilter<"feature_definitions"> | string
    sort_order?: IntFilter<"feature_definitions"> | number
  }

  export type vehicle_typesUpsertWithoutFeature_groupsInput = {
    update: XOR<vehicle_typesUpdateWithoutFeature_groupsInput, vehicle_typesUncheckedUpdateWithoutFeature_groupsInput>
    create: XOR<vehicle_typesCreateWithoutFeature_groupsInput, vehicle_typesUncheckedCreateWithoutFeature_groupsInput>
    where?: vehicle_typesWhereInput
  }

  export type vehicle_typesUpdateToOneWithWhereWithoutFeature_groupsInput = {
    where?: vehicle_typesWhereInput
    data: XOR<vehicle_typesUpdateWithoutFeature_groupsInput, vehicle_typesUncheckedUpdateWithoutFeature_groupsInput>
  }

  export type vehicle_typesUpdateWithoutFeature_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUpdateManyWithoutVehicle_typesNestedInput
    categories?: CategoryUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateWithoutFeature_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type ListingCreateWithoutListing_imagesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutListing_imagesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutListing_imagesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutListing_imagesInput, ListingUncheckedCreateWithoutListing_imagesInput>
  }

  export type ListingUpsertWithoutListing_imagesInput = {
    update: XOR<ListingUpdateWithoutListing_imagesInput, ListingUncheckedUpdateWithoutListing_imagesInput>
    create: XOR<ListingCreateWithoutListing_imagesInput, ListingUncheckedCreateWithoutListing_imagesInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutListing_imagesInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutListing_imagesInput, ListingUncheckedUpdateWithoutListing_imagesInput>
  }

  export type ListingUpdateWithoutListing_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutListing_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingCreateWithoutListing_propertiesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutListing_propertiesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutListing_propertiesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutListing_propertiesInput, ListingUncheckedCreateWithoutListing_propertiesInput>
  }

  export type ListingUpsertWithoutListing_propertiesInput = {
    update: XOR<ListingUpdateWithoutListing_propertiesInput, ListingUncheckedUpdateWithoutListing_propertiesInput>
    create: XOR<ListingCreateWithoutListing_propertiesInput, ListingUncheckedCreateWithoutListing_propertiesInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutListing_propertiesInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutListing_propertiesInput, ListingUncheckedUpdateWithoutListing_propertiesInput>
  }

  export type ListingUpdateWithoutListing_propertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutListing_propertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingCreateWithoutModelsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutModelsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutModelsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput>
  }

  export type ListingCreateManyModelsInputEnvelope = {
    data: ListingCreateManyModelsInput | ListingCreateManyModelsInput[]
    skipDuplicates?: boolean
  }

  export type brandsCreateWithoutModelsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    vehicle_types: vehicle_typesCreateNestedOneWithoutBrandsInput
    listings?: ListingCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutModelsInput = {
    id: string
    name: string
    vehicle_type_id: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    listings?: ListingUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutModelsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
  }

  export type variantsCreateWithoutModelsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutVariantsInput
  }

  export type variantsUncheckedCreateWithoutModelsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutVariantsInput
  }

  export type variantsCreateOrConnectWithoutModelsInput = {
    where: variantsWhereUniqueInput
    create: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput>
  }

  export type variantsCreateManyModelsInputEnvelope = {
    data: variantsCreateManyModelsInput | variantsCreateManyModelsInput[]
    skipDuplicates?: boolean
  }

  export type ListingUpsertWithWhereUniqueWithoutModelsInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutModelsInput, ListingUncheckedUpdateWithoutModelsInput>
    create: XOR<ListingCreateWithoutModelsInput, ListingUncheckedCreateWithoutModelsInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutModelsInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutModelsInput, ListingUncheckedUpdateWithoutModelsInput>
  }

  export type ListingUpdateManyWithWhereWithoutModelsInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutModelsInput>
  }

  export type brandsUpsertWithoutModelsInput = {
    update: XOR<brandsUpdateWithoutModelsInput, brandsUncheckedUpdateWithoutModelsInput>
    create: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutModelsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutModelsInput, brandsUncheckedUpdateWithoutModelsInput>
  }

  export type brandsUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutBrandsNestedInput
    listings?: ListingUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    listings?: ListingUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type variantsUpsertWithWhereUniqueWithoutModelsInput = {
    where: variantsWhereUniqueInput
    update: XOR<variantsUpdateWithoutModelsInput, variantsUncheckedUpdateWithoutModelsInput>
    create: XOR<variantsCreateWithoutModelsInput, variantsUncheckedCreateWithoutModelsInput>
  }

  export type variantsUpdateWithWhereUniqueWithoutModelsInput = {
    where: variantsWhereUniqueInput
    data: XOR<variantsUpdateWithoutModelsInput, variantsUncheckedUpdateWithoutModelsInput>
  }

  export type variantsUpdateManyWithWhereWithoutModelsInput = {
    where: variantsScalarWhereInput
    data: XOR<variantsUpdateManyMutationInput, variantsUncheckedUpdateManyWithoutModelsInput>
  }

  export type variantsScalarWhereInput = {
    AND?: variantsScalarWhereInput | variantsScalarWhereInput[]
    OR?: variantsScalarWhereInput[]
    NOT?: variantsScalarWhereInput | variantsScalarWhereInput[]
    id?: StringFilter<"variants"> | string
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    created_at?: DateTimeFilter<"variants"> | Date | string
    updated_at?: DateTimeFilter<"variants"> | Date | string
  }

  export type ListingCreateWithoutVariantsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutVariantsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutVariantsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput>
  }

  export type ListingCreateManyVariantsInputEnvelope = {
    data: ListingCreateManyVariantsInput | ListingCreateManyVariantsInput[]
    skipDuplicates?: boolean
  }

  export type modelsCreateWithoutVariantsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingCreateNestedManyWithoutModelsInput
    brands: brandsCreateNestedOneWithoutModelsInput
  }

  export type modelsUncheckedCreateWithoutVariantsInput = {
    id: string
    name: string
    brand_id: string
    created_at?: Date | string
    updated_at: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutModelsInput
  }

  export type modelsCreateOrConnectWithoutVariantsInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
  }

  export type ListingUpsertWithWhereUniqueWithoutVariantsInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutVariantsInput, ListingUncheckedUpdateWithoutVariantsInput>
    create: XOR<ListingCreateWithoutVariantsInput, ListingUncheckedCreateWithoutVariantsInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutVariantsInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutVariantsInput, ListingUncheckedUpdateWithoutVariantsInput>
  }

  export type ListingUpdateManyWithWhereWithoutVariantsInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutVariantsInput>
  }

  export type modelsUpsertWithoutVariantsInput = {
    update: XOR<modelsUpdateWithoutVariantsInput, modelsUncheckedUpdateWithoutVariantsInput>
    create: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    where?: modelsWhereInput
  }

  export type modelsUpdateToOneWithWhereWithoutVariantsInput = {
    where?: modelsWhereInput
    data: XOR<modelsUpdateWithoutVariantsInput, modelsUncheckedUpdateWithoutVariantsInput>
  }

  export type modelsUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutModelsNestedInput
    brands?: brandsUpdateOneRequiredWithoutModelsNestedInput
  }

  export type modelsUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type brandsCreateWithoutVehicle_typesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    listings?: ListingCreateNestedManyWithoutBrandsInput
    models?: modelsCreateNestedManyWithoutBrandsInput
  }

  export type brandsUncheckedCreateWithoutVehicle_typesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
    listings?: ListingUncheckedCreateNestedManyWithoutBrandsInput
    models?: modelsUncheckedCreateNestedManyWithoutBrandsInput
  }

  export type brandsCreateOrConnectWithoutVehicle_typesInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type brandsCreateManyVehicle_typesInputEnvelope = {
    data: brandsCreateManyVehicle_typesInput | brandsCreateManyVehicle_typesInput[]
    skipDuplicates?: boolean
  }

  export type category_attributesCreateWithoutVehicle_typesInput = {
    id: string
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
    categories: CategoryCreateNestedOneWithoutCategory_attributesInput
  }

  export type category_attributesUncheckedCreateWithoutVehicle_typesInput = {
    id: string
    category_id: string
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesCreateOrConnectWithoutVehicle_typesInput = {
    where: category_attributesWhereUniqueInput
    create: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput>
  }

  export type category_attributesCreateManyVehicle_typesInputEnvelope = {
    data: category_attributesCreateManyVehicle_typesInput | category_attributesCreateManyVehicle_typesInput[]
    skipDuplicates?: boolean
  }

  export type feature_groupsCreateWithoutVehicle_typesInput = {
    id: string
    name: string
    label: string
    sort_order?: number
    feature_definitions?: feature_definitionsCreateNestedManyWithoutFeature_groupsInput
  }

  export type feature_groupsUncheckedCreateWithoutVehicle_typesInput = {
    id: string
    name: string
    label: string
    sort_order?: number
    feature_definitions?: feature_definitionsUncheckedCreateNestedManyWithoutFeature_groupsInput
  }

  export type feature_groupsCreateOrConnectWithoutVehicle_typesInput = {
    where: feature_groupsWhereUniqueInput
    create: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type feature_groupsCreateManyVehicle_typesInputEnvelope = {
    data: feature_groupsCreateManyVehicle_typesInput | feature_groupsCreateManyVehicle_typesInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutVehicle_typesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsCreateNestedManyWithoutListingsInput
    conversations?: conversationsCreateNestedManyWithoutListingsInput
    favorites?: FavoriteCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesCreateNestedManyWithoutListingsInput
    brands?: brandsCreateNestedOneWithoutListingsInput
    categories: CategoryCreateNestedOneWithoutListingsInput
    cities?: citiesCreateNestedOneWithoutListingsInput
    districts?: districtsCreateNestedOneWithoutListingsInput
    models?: modelsCreateNestedOneWithoutListingsInput
    users: UserCreateNestedOneWithoutListingsInput
    variants?: variantsCreateNestedOneWithoutListingsInput
  }

  export type ListingUncheckedCreateWithoutVehicle_typesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
    complaints?: complaintsUncheckedCreateNestedManyWithoutListingsInput
    conversations?: conversationsUncheckedCreateNestedManyWithoutListingsInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutListingsInput
    listing_images?: listing_imagesUncheckedCreateNestedManyWithoutListingsInput
    listing_properties?: listing_propertiesUncheckedCreateNestedManyWithoutListingsInput
  }

  export type ListingCreateOrConnectWithoutVehicle_typesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput>
  }

  export type ListingCreateManyVehicle_typesInputEnvelope = {
    data: ListingCreateManyVehicle_typesInput | ListingCreateManyVehicle_typesInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutVehicle_typesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesCreateNestedManyWithoutCategoriesInput
    listings?: ListingCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutVehicle_typesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    category_attributes?: category_attributesUncheckedCreateNestedManyWithoutCategoriesInput
    listings?: ListingUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutVehicle_typesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutVehicle_typesInput, CategoryUncheckedCreateWithoutVehicle_typesInput>
  }

  export type brandsUpsertWithWhereUniqueWithoutVehicle_typesInput = {
    where: brandsWhereUniqueInput
    update: XOR<brandsUpdateWithoutVehicle_typesInput, brandsUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<brandsCreateWithoutVehicle_typesInput, brandsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type brandsUpdateWithWhereUniqueWithoutVehicle_typesInput = {
    where: brandsWhereUniqueInput
    data: XOR<brandsUpdateWithoutVehicle_typesInput, brandsUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type brandsUpdateManyWithWhereWithoutVehicle_typesInput = {
    where: brandsScalarWhereInput
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyWithoutVehicle_typesInput>
  }

  export type brandsScalarWhereInput = {
    AND?: brandsScalarWhereInput | brandsScalarWhereInput[]
    OR?: brandsScalarWhereInput[]
    NOT?: brandsScalarWhereInput | brandsScalarWhereInput[]
    id?: StringFilter<"brands"> | string
    name?: StringFilter<"brands"> | string
    vehicle_type_id?: StringFilter<"brands"> | string
    created_at?: DateTimeFilter<"brands"> | Date | string
    updated_at?: DateTimeFilter<"brands"> | Date | string
    image_url?: StringNullableFilter<"brands"> | string | null
  }

  export type category_attributesUpsertWithWhereUniqueWithoutVehicle_typesInput = {
    where: category_attributesWhereUniqueInput
    update: XOR<category_attributesUpdateWithoutVehicle_typesInput, category_attributesUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<category_attributesCreateWithoutVehicle_typesInput, category_attributesUncheckedCreateWithoutVehicle_typesInput>
  }

  export type category_attributesUpdateWithWhereUniqueWithoutVehicle_typesInput = {
    where: category_attributesWhereUniqueInput
    data: XOR<category_attributesUpdateWithoutVehicle_typesInput, category_attributesUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type category_attributesUpdateManyWithWhereWithoutVehicle_typesInput = {
    where: category_attributesScalarWhereInput
    data: XOR<category_attributesUpdateManyMutationInput, category_attributesUncheckedUpdateManyWithoutVehicle_typesInput>
  }

  export type feature_groupsUpsertWithWhereUniqueWithoutVehicle_typesInput = {
    where: feature_groupsWhereUniqueInput
    update: XOR<feature_groupsUpdateWithoutVehicle_typesInput, feature_groupsUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<feature_groupsCreateWithoutVehicle_typesInput, feature_groupsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type feature_groupsUpdateWithWhereUniqueWithoutVehicle_typesInput = {
    where: feature_groupsWhereUniqueInput
    data: XOR<feature_groupsUpdateWithoutVehicle_typesInput, feature_groupsUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type feature_groupsUpdateManyWithWhereWithoutVehicle_typesInput = {
    where: feature_groupsScalarWhereInput
    data: XOR<feature_groupsUpdateManyMutationInput, feature_groupsUncheckedUpdateManyWithoutVehicle_typesInput>
  }

  export type feature_groupsScalarWhereInput = {
    AND?: feature_groupsScalarWhereInput | feature_groupsScalarWhereInput[]
    OR?: feature_groupsScalarWhereInput[]
    NOT?: feature_groupsScalarWhereInput | feature_groupsScalarWhereInput[]
    id?: StringFilter<"feature_groups"> | string
    vehicle_type_id?: StringFilter<"feature_groups"> | string
    name?: StringFilter<"feature_groups"> | string
    label?: StringFilter<"feature_groups"> | string
    sort_order?: IntFilter<"feature_groups"> | number
  }

  export type ListingUpsertWithWhereUniqueWithoutVehicle_typesInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutVehicle_typesInput, ListingUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<ListingCreateWithoutVehicle_typesInput, ListingUncheckedCreateWithoutVehicle_typesInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutVehicle_typesInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutVehicle_typesInput, ListingUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type ListingUpdateManyWithWhereWithoutVehicle_typesInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutVehicle_typesInput>
  }

  export type CategoryUpsertWithoutVehicle_typesInput = {
    update: XOR<CategoryUpdateWithoutVehicle_typesInput, CategoryUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<CategoryCreateWithoutVehicle_typesInput, CategoryUncheckedCreateWithoutVehicle_typesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutVehicle_typesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutVehicle_typesInput, CategoryUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type CategoryUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUpdateManyWithoutCategoriesNestedInput
    listings?: ListingUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_attributes?: category_attributesUncheckedUpdateManyWithoutCategoriesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type complaintsCreateManyUsers_complaints_target_user_idTousersInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type complaintsCreateManyUsers_complaints_user_idTousersInput = {
    id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    target_listing_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type conversationsCreateManyUsers_conversations_participant1_idTousersInput = {
    id: string
    participant2_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type conversationsCreateManyUsers_conversations_participant2_idTousersInput = {
    id: string
    participant1_id: string
    listing_id?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FavoriteCreateManyUsersInput = {
    id?: string
    listing_id: string
    created_at?: Date | string
  }

  export type ListingCreateManyUsersInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type MessageCreateManyUsersInput = {
    id?: string
    conversation_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type NotificationCreateManyUsersInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    created_at?: Date | string
  }

  export type complaintsUpdateWithoutUsers_complaints_target_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutComplaintsNestedInput
    users_complaints_user_idTousers?: UserUpdateOneRequiredWithoutComplaints_complaints_user_idTousersNestedInput
  }

  export type complaintsUncheckedUpdateWithoutUsers_complaints_target_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUncheckedUpdateManyWithoutUsers_complaints_target_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUpdateWithoutUsers_complaints_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutComplaintsNestedInput
    users_complaints_target_user_idTousers?: UserUpdateOneWithoutComplaints_complaints_target_user_idTousersNestedInput
  }

  export type complaintsUncheckedUpdateWithoutUsers_complaints_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUncheckedUpdateManyWithoutUsers_complaints_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsUpdateWithoutUsers_conversations_participant1_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutConversationsNestedInput
    users_conversations_participant2_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant2_idTousersNestedInput
    messages?: MessageUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutUsers_conversations_participant1_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateManyWithoutUsers_conversations_participant1_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsUpdateWithoutUsers_conversations_participant2_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneWithoutConversationsNestedInput
    users_conversations_participant1_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant1_idTousersNestedInput
    messages?: MessageUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutUsers_conversations_participant2_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateManyWithoutUsers_conversations_participant2_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    listing_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    listing_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: conversationsUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_attributesCreateManyCategoriesInput = {
    id: string
    vehicle_type_id?: string | null
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ListingCreateManyCategoriesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type vehicle_typesCreateManyCategoriesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type category_attributesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    vehicle_types?: vehicle_typesUpdateOneWithoutCategory_attributesNestedInput
  }

  export type category_attributesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ListingUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicle_typesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUpdateManyWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    brands?: brandsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    category_attributes?: category_attributesUncheckedUpdateManyWithoutVehicle_typesNestedInput
    feature_groups?: feature_groupsUncheckedUpdateManyWithoutVehicle_typesNestedInput
    listings?: ListingUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type complaintsCreateManyListingsInput = {
    id: string
    user_id: string
    target_type: $Enums.ComplaintTarget
    target_user_id?: string | null
    category: $Enums.ComplaintCategory
    description?: string | null
    status?: $Enums.ComplaintStatus
    admin_response?: string | null
    admin_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type conversationsCreateManyListingsInput = {
    id: string
    participant1_id: string
    participant2_id: string
    last_message_at?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FavoriteCreateManyListingsInput = {
    id?: string
    user_id: string
    created_at?: Date | string
  }

  export type listing_imagesCreateManyListingsInput = {
    id: string
    url: string
    alt?: string | null
    sort_order?: number
  }

  export type listing_propertiesCreateManyListingsInput = {
    id: string
    key: string
    value: string
    type: $Enums.PropertyType
  }

  export type complaintsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_complaints_target_user_idTousers?: UserUpdateOneWithoutComplaints_complaints_target_user_idTousersNestedInput
    users_complaints_user_idTousers?: UserUpdateOneRequiredWithoutComplaints_complaints_user_idTousersNestedInput
  }

  export type complaintsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintsUncheckedUpdateManyWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    target_type?: EnumComplaintTargetFieldUpdateOperationsInput | $Enums.ComplaintTarget
    target_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumComplaintCategoryFieldUpdateOperationsInput | $Enums.ComplaintCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    admin_response?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_conversations_participant1_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant1_idTousersNestedInput
    users_conversations_participant2_idTousers?: UserUpdateOneRequiredWithoutConversations_conversations_participant2_idTousersNestedInput
    messages?: MessageUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateManyWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1_id?: StringFieldUpdateOperationsInput | string
    participant2_id?: StringFieldUpdateOperationsInput | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type listing_imagesUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_imagesUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_imagesUncheckedUpdateManyWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type listing_propertiesUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type listing_propertiesUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type listing_propertiesUncheckedUpdateManyWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type ListingCreateManyBrandsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type modelsCreateManyBrandsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ListingUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type modelsUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutModelsNestedInput
    variants?: variantsUpdateManyWithoutModelsNestedInput
  }

  export type modelsUncheckedUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutModelsNestedInput
    variants?: variantsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type modelsUncheckedUpdateManyWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtsCreateManyCitiesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ListingCreateManyCitiesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type districtsUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyConversationsInput = {
    id?: string
    sender_id: string
    content: string
    is_read?: boolean
    is_edited?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessageUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    is_edited?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateManyDistrictsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type ListingUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutDistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type feature_definitionsCreateManyFeature_groupsInput = {
    id: string
    key: string
    label: string
    sort_order?: number
  }

  export type feature_definitionsUpdateWithoutFeature_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_definitionsUncheckedUpdateWithoutFeature_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type feature_definitionsUncheckedUpdateManyWithoutFeature_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type ListingCreateManyModelsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type variantsCreateManyModelsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ListingUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type variantsUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutVariantsNestedInput
  }

  export type variantsUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutVariantsNestedInput
  }

  export type variantsUncheckedUpdateManyWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateManyVariantsInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    vehicle_type_id: string
    brand_id?: string | null
    model_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type ListingUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type brandsCreateManyVehicle_typesInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at: Date | string
    image_url?: string | null
  }

  export type category_attributesCreateManyVehicle_typesInput = {
    id: string
    category_id: string
    key: string
    label: string
    type: $Enums.PropertyType
    is_required?: boolean
    is_filterable?: boolean
    sort_order?: number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type feature_groupsCreateManyVehicle_typesInput = {
    id: string
    name: string
    label: string
    sort_order?: number
  }

  export type ListingCreateManyVehicle_typesInput = {
    id?: string
    title: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    year: number
    category_id: string
    brand_id?: string | null
    model_id?: string | null
    variant_id?: string | null
    status?: $Enums.ListingStatus
    is_active?: boolean
    is_approved?: boolean
    is_pending?: boolean
    view_count?: number
    is_promoted?: boolean
    approved_by?: string | null
    approved_at?: Date | string | null
    rejected_at?: Date | string | null
    reject_reason?: string | null
    seller_name: string
    seller_phone: string
    seller_email: string
    city_id?: string | null
    district_id?: string | null
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
    color?: string | null
    engine_power?: string | null
    engine_volume?: string | null
    fuel_type?: string | null
    is_exchangeable?: boolean
    km?: number | null
    license_plate?: string | null
    neighborhood_id?: string | null
    transmission?: string | null
    vehicle_condition?: string | null
  }

  export type brandsUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    listings?: ListingUpdateManyWithoutBrandsNestedInput
    models?: modelsUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    listings?: ListingUncheckedUpdateManyWithoutBrandsNestedInput
    models?: modelsUncheckedUpdateManyWithoutBrandsNestedInput
  }

  export type brandsUncheckedUpdateManyWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type category_attributesUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
    categories?: CategoryUpdateOneRequiredWithoutCategory_attributesNestedInput
  }

  export type category_attributesUncheckedUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type category_attributesUncheckedUpdateManyWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    is_required?: BoolFieldUpdateOperationsInput | boolean
    is_filterable?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    options?: NullableJsonNullValueInput | InputJsonValue
  }

  export type feature_groupsUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    feature_definitions?: feature_definitionsUpdateManyWithoutFeature_groupsNestedInput
  }

  export type feature_groupsUncheckedUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    feature_definitions?: feature_definitionsUncheckedUpdateManyWithoutFeature_groupsNestedInput
  }

  export type feature_groupsUncheckedUpdateManyWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type ListingUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUpdateManyWithoutListingsNestedInput
    brands?: brandsUpdateOneWithoutListingsNestedInput
    categories?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cities?: citiesUpdateOneWithoutListingsNestedInput
    districts?: districtsUpdateOneWithoutListingsNestedInput
    models?: modelsUpdateOneWithoutListingsNestedInput
    users?: UserUpdateOneRequiredWithoutListingsNestedInput
    variants?: variantsUpdateOneWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
    complaints?: complaintsUncheckedUpdateManyWithoutListingsNestedInput
    conversations?: conversationsUncheckedUpdateManyWithoutListingsNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutListingsNestedInput
    listing_images?: listing_imagesUncheckedUpdateManyWithoutListingsNestedInput
    listing_properties?: listing_propertiesUncheckedUpdateManyWithoutListingsNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutVehicle_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    year?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: NullableStringFieldUpdateOperationsInput | string | null
    variant_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_pending?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    is_promoted?: BoolFieldUpdateOperationsInput | boolean
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reject_reason?: NullableStringFieldUpdateOperationsInput | string | null
    seller_name?: StringFieldUpdateOperationsInput | string
    seller_phone?: StringFieldUpdateOperationsInput | string
    seller_email?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    district_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine_power?: NullableStringFieldUpdateOperationsInput | string | null
    engine_volume?: NullableStringFieldUpdateOperationsInput | string | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_exchangeable?: BoolFieldUpdateOperationsInput | boolean
    km?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood_id?: NullableStringFieldUpdateOperationsInput | string | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_condition?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListingCountOutputTypeDefaultArgs instead
     */
    export type ListingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CitiesCountOutputTypeDefaultArgs instead
     */
    export type CitiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationsCountOutputTypeDefaultArgs instead
     */
    export type ConversationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictsCountOutputTypeDefaultArgs instead
     */
    export type DistrictsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Feature_groupsCountOutputTypeDefaultArgs instead
     */
    export type Feature_groupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Feature_groupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelsCountOutputTypeDefaultArgs instead
     */
    export type ModelsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VariantsCountOutputTypeDefaultArgs instead
     */
    export type VariantsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VariantsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Vehicle_typesCountOutputTypeDefaultArgs instead
     */
    export type Vehicle_typesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Vehicle_typesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListingDefaultArgs instead
     */
    export type ListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavoriteDefaultArgs instead
     */
    export type FavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavoriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brandsDefaultArgs instead
     */
    export type brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use category_attributesDefaultArgs instead
     */
    export type category_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = category_attributesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use citiesDefaultArgs instead
     */
    export type citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = citiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use complaintsDefaultArgs instead
     */
    export type complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = complaintsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversationsDefaultArgs instead
     */
    export type conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use districtsDefaultArgs instead
     */
    export type districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = districtsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feature_definitionsDefaultArgs instead
     */
    export type feature_definitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feature_definitionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feature_groupsDefaultArgs instead
     */
    export type feature_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feature_groupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use listing_imagesDefaultArgs instead
     */
    export type listing_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = listing_imagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use listing_propertiesDefaultArgs instead
     */
    export type listing_propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = listing_propertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use modelsDefaultArgs instead
     */
    export type modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = modelsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use variantsDefaultArgs instead
     */
    export type variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = variantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use vehicle_typesDefaultArgs instead
     */
    export type vehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = vehicle_typesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}